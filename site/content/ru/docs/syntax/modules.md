---
title: Модули и пакеты
weight: 30
---

В *NewLang* реализована концепция программных модулей и пакетов - которая повторяет идею иерархического расположения файлов 
в каталогах файловой системы, примерно так же, как это сделано в языке Python, но разделителем имен выступает не точка, 
а символ "**\\**" (как разделитель каталогов в Windows).

Под модулем в *NewLang* понимается **файл** с расширением *.nlp. Модули предназначены для того, чтобы в них хранить часто используемые функции, классы, константы и т.п. 
Их можно условно разделить на модули и программы: программы предназначены для непосредственного запуска, а модули для импортирования их в другие программы, 
но функционально модули и программы ничем между собой не отличаются.

Относительное имя программного модуля начинается на символ "**\\**", и в этом случае расположение программного модуля указывается относительно текущего файла.
Абсолютное имя программного модуля начинается на два символа "**\\\\**" и указывает на файл модуля относительно каталога текущего исполняемого файла 
(или в списке каталогов для поиска программных модулей который можно переопределить, например с помощью аргументов командной строки).

### Как импортировать модули?

Самый простой способ импортировать модуль, это записать его имя со скобками как при вызове функции.
Причем в скобках можно передать аргументы для инициализации модуля, список импортируемых функций и т.д.

Так как *NewLang* разрабатывается как компилируемый язык, то загрузка модулей возможна как статически, так и динамически 
(очень похоже на статическую и динамическую ликновку с dll библиотеками).

- \dir\module() - статическая загрузка модуля по относительному пути
- \\\\root\dir\module() - статическая загрузка модуля по абсолютному пути
- \\\\(**"**каталог\файл**"**) - динамическая загрузка модуля во время выполнения программы

При динамической линковке, компиляция исходного кода модуля и все проверки будут выполнятся только во время выполнения приложения, 
тогда как статическая загрузка модуля позволяет выявить возможные ошибки еще на этапе компиляции программы.

По умолчанию импортируются все макросы, функции и переменные модуля.


### Что такое пакет в *NewLang*?

Пакет в *NewLang* – это имя **каталога**, который включает в себя другие каталоги и модули и при этом содержит дополнительный файл \_\_init\_\_.nlp. 

Пакеты используются как дополнение к пространству имен, что позволяет работать с модулями через указание уровня вложенности (через символ **\\**).
Но в отличии от Python и Java, где модули и пакеты *заменяют* собой пространство имен ([namespace](/ru/docs/syntax/namespace/)), 
в *NewLang* модульная структура и области имен используются одновременно и при указании полного имени объекта, 
программные модули и пространства имен можно объединять. 

Например, полное имя переменой можно записать с указанием программного модуля `\root\dir\module::ns::name::var`, 
где **root** и **dir** это каталоги в файловой системе относительно текущего моделя, а **module** — имя файла, т.е. *root/dir/module.nlp*

Для импортирования пакетов используется тот же синтаксис, что и для работы с модулями.


### Использование пакетов

Рассмотрим следующую структуру пакета:

```
    fincalc
    |-- __init__.nlp
    |-- simper.nlp
    |-- compper.nlp
    |-- annuity.nlp
```

Пакет *fincalc* содержит в себе модули для работы с простыми процентами (simper.nlp), сложными процентами (compper.nlp) и аннуитетами (annuity.nlp).
Файл \_\_init\_\_.nlp в отличии от Python, не может быть пустым, а должен в явном виде содержать команды загрузки модулей, входящих в пакет

Например для нашего случая содержимое \_\_init\_\_.nlp может быть вот таким:

```
    \simper();
    \compper();
    \annuity();
```

Для использования функции *fp* из модуля для работы с простыми процентами, можно использовать один из следующих вариантов 
(для сравнения приведен аналогичный код на Python, когда это возможно):

#### Импорт одного модуля без указания псевдонима:

Python:
```python
    import fincalc.simper
    fv = fincalc.simper.fv(pv, i, n)
```

NewLang:
```
    \fincalc\simper();
    fv := \fincalc\simper::fv(pv, i, n);
```

#### С указанием псевдонима имени модуля:

Python:
```python
    import fincalc.simper as sp
    fv = sp.fv(pv, i, n)
```

NewLang:
```
    sp := \fincalc\simper();
    fv := sp.fv(pv, i, n);
```

#### Импорт одной конкретной функции:

Python:
```python
    from fincalc import fv
    result = fv(pv, i, n)
```

NewLang:
```
    \fincalc\simper(__import__="fv");
    result := fv(pv, i, n);
```

#### Импорт всего пакета:

NewLang:
```
    \fincalc();
    result := fv(pv, i, n);
```

