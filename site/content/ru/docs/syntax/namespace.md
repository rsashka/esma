---
title: Пространства имен
weight: 20
---

*NewLang* поддерживает пространства имен, разделителем в которых, как и в С++, выступает двойное двоеточие "**::**".

Область имен может быть указана как для отдельного индетификатора, так и для целого [блока кода](/ru/docs/ops/block/).

В отличии от *namespace* в С++, области имен в *NewLnag* используются не только для организации кода в виде логических групп 
и с целью избежания конфликтов имен, но и для отнесения идентификатора, в котором явно указана область имен, напрямую к глобальным (статическим) объектам.

Глобальное имя не может быть перекрыто макросом или локальной переменной при [разрешении имен (name lookup)](/ru/docs/syntax/naming/).
Создать глобальную (статическую) переменную в текущем пространстве имен можно указав переменную препроцессора **@::**.

Для использования пространства имен в [блоке кода](/ru/docs/ops/block/), его нужно указать перед открывающейся фигурной скобкой.
В таком именованном блоке кода завершающие "**::**" указывать не обязательно.

```bash
::var ::= 0; # Имя глобальной переменной в явном виде (не может быть перекрыто) 

ns { # Можно указать равнозначное ns::

    var ::= 0; # Имя ns::var (может быть перекрыто макросом или локальной переменной)
    @::var ::= 0; # Имя глобальной переменной ::ns::var (не может быть перекрыто) 

    name:: {
        var = 0; # Обращение к переменной ns::var
        var2 ::= 0; # Имя переменной будет ns::name::var2
        ::var = 1; # Переменная из глобального пространства имен
    };

    :: { # Глобальное пространство имен
        var = 1;  # Имя глобальной переменной ::var (может быть перекрыто) 
        ::ns::var = 0; # Имя другой глобальной переменной (не может быть перекрыто) 
    };
};
```

## Пространство имен и модули

Пространство имен в *NewLang* поддерживает одновременно с [модульной структурой кода](/ru/docs/syntax/modules/) как в языках Java и Python
и при указании полного имени объекта, программные модули и пространства имен можно объединять. 

Например, полное имя переменой можно записать с указанием программного модуля `\root\dir\module::ns::name::var`, 
где **root** и **dir** это каталоги в файловой системе относительно текущего модуля, а **module** — имя файла, т.е. *root/dir/module.nlp*


## Пространство имен и ООП

В *NewLang* не применяется декорирование (манглинг) имен, основанный на типах аргументов функций.

Тем не менее при создания уникальных идентификаторов для методов [классов](/ru/docs/types/class/) *NewLang* использует подход, похожий на применяемый в языке Python. 
При создании [метода класса](/ru/docs/types/class/) создается глобальная функция с именем класса и именем метода, объединенные через разделитель "**::**". 

Например, для класса `:NewClass` при создании метода `method` будет создана функция с именем `NewClass::method`.

Такая схема наименований методов полностью соответствует именованию функций в пространстве имен, 
и тем самым позволяет определять методы класса вне тела самого класса, просто указав нужное имя в пространстве имен или в явном виде.

Пример создания метода класса *NewClass* в области имен: 
```
    NewClass::  {
        method() := { };
    }
```

Пример создания метода класса *NewClass* с указанием полного имени: 
```
    NewClass::method() := { };
```


## Декорирование имен объектов
Каждый объект имеет свой уникальный идентификатор, который получатеся из его имени, квалификатора и пространства имен, в котором он опеределен.
Уникальные идентификаторы у объектов бывает двух видов: 
локальный идентификатор в рамках только одного модуля и глобальный идентификатор в рамках всей системы в целом.

Для краткой записи некоторый переменных используются следующие переменные компилятора:
- **"@::"** - Текущая область имен для краткой записи имени статического объекта (DSL макрос `@static`).
- **"@$$"** - Имя модуля (DSL макрос `@module`). Может быть переопределено первым оператором в модуле.
    По умолчанию используется имя файла относительно каталога запуска.


#### Локальный идентификатор объекта
Локальный идентификатор объекта определяется в рамках текщего модуля и используется *компилятором* 
при обработке и анализе исходного текста программы при обработке модуля.

Локальный идентификатор для глобальных и временных объектов в точности соответствует его записи при раскрытии всех областей имен.
В локальном идентификаторе статического объекта модуля, последнее двоеточие перед именем заменяется на два подряд символова '**$$**'.
А в локальном идентификаторе имени типа, последние три двоеточия перед именем, тоже же заменяются, но уже на три подряд символова '**$$$**'.

Примеры локальных идентификаторов
```python
# Глобальный объект
::var ::= 0; # ::var

# Локальный или временный объект модуля
$var := 0;  # $var

# Статический объект модуля
@::var ::= 0; # $$var

# Синоним типа или конструктор класса
:type := :Type;     # $$$type
:cls := Class(){};  # $$$cls

ns {
    $var := 0;  # ns$var
    var ::= 0;  # ns$var
    @::var ::= 0; # ns$$var

    :type := :Type;     # ns$$$type
    :cls := Class(){};  # ns$$$cls

    func() ::= {};      # ns$$func
};
```


#### Глобальный идентификатор объекта
Глобальный идентификатор объекта формируется в рамках всей системы 
и предоставляет способ кодирования дополнительной информации в имени функции, 
структуре, классе или другом типе данных при передачи дополнительной семантической информации от компилятора *компоновщику*.
Это используется для объединения нескольких модулей в рамках одной программы,
а также позволяет обращатся к объектам языка из внешних библиотек.

Для формирования глобального идентификатора используется локальный идентифиукатор,
к которому в начале имени добавляется префикс *nlc_* и информация об имени текущего модуля.

У главного исполняемого файла программы имя модуля не используется (отстуствует).
С помощью этого можно различить выполнение файла в качестве загружаемого модуля или главного исполняемого файла.



- **"@$$"** - Имя модуля/пакета (DSL макрос `@package`). Может быть переопределено первым оператором в модуле.
    По умолчанию используется имя файла относительно каталога запуска.
\dir\file(\_\_package\_\_="\new\module\name");

# \dir\file

@$$ = "\dir\file";



Глобальный идентификатор формирует корректное имя, доступное для обращения из языков C/C++.
Делается это добавлением к 
Манглинг имен объектов при взаимодействии из языков С/C++ происходит путем замены
каждого символа двоеточие '*:*' на один символ '**$**', а в начале имени добавляется префикс nlc_.


Квалификатор локального/временного объекта записывается как есть, одним символом '**$**'.
Пространства имен тоже записывается как есть, двумя символами двоеточие '**::**'.
Квалификатор статического объекта в имени записывается с помощью двух подряд символов '**$**',
т.е. двоеточие пространста имен заменяется на '**$$**', а квалификатор типа тремя символами '**$**', т.е. на '**$$$**'.



Примеры локальных идентификаторов
```python
# Глобальный объект
::var ::= 0; # ::var

# Локальный или временный объект модуля
$var := 0;  # $var

# Статический объект модуля
@::var ::= 0; # $$var

# Синоним типа или конструктор класса
:type := :Type;     # $$$type
:cls := Class(){};  # $$$cls

ns {
    $var := 0;  # ns$var
    var ::= 0;  # ns$var
    @::var ::= 0; # ns$$var

    :type := :Type;     # ns$$$type
    :cls := Class(){};  # ns$$$cls

    func() ::= {};      # ns$$func
};
```


```python
# Глобальный статический объект
::var ::= 0; # Имя объекта '::var'  nlc_var

# Локальный/временный объект модуля
$var := 0; # Имя объекта '$var'  nlc_$var

# Статический объект модуля
@::var ::= 0; # Имя объекта '$$var'  nlc_$$var

# Локальный/временный синоним типа или конструктор класса
:var := :Type; # Имя объекта '$$$var'  nlc_$$$var
:var := Class(){}; # Имя объекта '$$$var'  nlc_$$$var

ns {

    # Глобальный статический объект
    ::var ::= 0; # Имя объекта '::var'  nlc_var

    # Локальный/временный объект модуля
    $var := 0; # Имя объекта 'ns$var'  nlc_ns$var

    # Локальный/временный объект 'ns$var' nlc_ns$var
    var ::= 0;

    # Локальный cтатический объект
    @::var ::= 0; # Имя объекта 'ns$$var'  nlc_ns$$var

    # Локальный/временный синоним типа или конструктор класса
    :var := :Type; # Имя объекта 'ns$$$var'  nlc_ns$$$var
    :var := Class(){}; # Имя объекта 'ns$$$var'  nlc_ns$$$var


    # Локльный статический объект ns$$func nlc_ns$$func
    func() ::= {};

    # Локльный статический объект ns$$func nlc_ns$$func
    @::func() ::= {};

    # Конструтор класса
    :func() ::= Class() {};  # ns$$$func nlc_ns$$$func

    :: { # Глобальное пространство имен
        var ::= 1;  # Имя объекта '::var'  nlc_var

        ns::var ::= 0; # Имя глобального объекта '::ns::var' nlc_ns$$var
    };
};
```

Манглинг имен в модуле

Имя модуля так же кодируется при создании C|C++ имени объекта.
Имя модуля в форме относительного пути вставляется сразу за прeфиксом *nlc_*.
В именах модулей разделители каталогов кодируются заглавной буквой 
или удвоением 


```
\dir\file -> DirFile
\_dir\file -> __dirFile;
\d_ir\file -> D_irFile;
\_\file -> __File;
\__\file -> ___File;
\_\_file -> ___File;
\_\_\file -> ____File;

\dir\file -> LdirLfileLL
\_dir\file -> L_dirLfile;
\d_ir\file -> Ld_irLfile;
\_\file -> _Ifile;
\__\file -> __Ifile;
\_\_file -> _I_file;
\_\_\file -> _I_Ifile;

\0dir\file -> 00dirFile
\00dir\file -> 0000dirFile
\di0r\file -> Di0rFile
\_dir\file -> __dirFile;
\d_ir\file -> D_irFile;
\_\file -> __File;
\_\_\file -> ____File;
\_\_file  -> ___File;

# \dir\file

@$$ = L     LL;

@@ package $name @@ ::= @@@  @$$ = @$name  @@@;


```


\dir\file(\_\_package\_\_="\new\module\name");

```python

# \dir\file

@$$ = "\dir\file";

# Глобальный статический объект
::var ::= 0; # Имя объекта '::var'  nlc_var

# Локальный/временный объект модуля
$var := 0; # Имя объекта '$var'  nlc_LdirLfileLL$var

# Статический объект модуля
@::var ::= 0; # Имя объекта '$$var'  nlc_LdirLfileLL$$var

# Локальный/временный синоним типа или конструктор класса
:var := :Type; # Имя объекта '$$$var'  nlc_LdirLfileLL$$$var
:var := Class(){}; # Имя объекта '$$$var'  nlc_LdirLfileLL$$$var

ns {

    # Глобальный статический объект
    ::var ::= 0; # Имя объекта '::var'  nlc_var

    # Локальный/временный объект модуля
    $var := 0; # Имя объекта '$var'  nlc_LdirLfileLLns$var

    # Локальный/временный объект 'ns$var' nlc_LdirLfileLLns$var
    var ::= 0;

    # Локальный cтатический объект
    @::var ::= 0; # Имя объекта 'ns$$var'  nlc_LdirLfileLLns$$var

    # Локальный/временный синоним типа или конструктор класса
    :var := :Type; # Имя объекта '$$$var'  nlc_LdirLfileLLns$$$var
    :var := Class(){}; # Имя объекта '$$$var'  nlc_LdirLfileLLns$$$var


    # Локльный статический объект ns$$func nlc_LdirLfileLLns$$func
    func() ::= {};

    # Локльный статический объект ns$$func nlc_LdirLfileLLns$$func
    @::func() ::= {};

    # Конструтор класса
    :func() ::= Class() {};  # ns$$$func nlc_LdirLfileLLns$$$func

    :: { # Глобальное пространство имен
        var ::= 1;  # Имя объекта '::var'  nlc_var

        ns::var ::= 0; # Имя глобального объекта '::ns::var' nlc_ns$$var
    };
};
```
