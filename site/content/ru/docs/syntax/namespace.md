---
title: Пространства имен
weight: 20
---

*NewLang* поддерживает пространства имен. 
Синтаксис очень похож на С++ т.к. для этого используется двойное двоеточие "**::**".

В отличии от namespace в С++, области имен в *NewLnag* используются не только для организации кода в виде логических групп и с целью избежания конфликтов имен,
но и для отнесения идентификатора, в котором явно указана область имен, напрямую к глобальным объектам.
Такое имя не может быть перекрыто макросом или локальной переменной при [разрешении имен (name lookup)](/ru/docs/syntax/naming/).

Для использования пространства имен в блоке кода, его нужно указать перед открывающейся фигурной скобкой.

```
ns:: { # Использовать пространство имен ns

    var := 0; # Имя ns::var (может быть перекрыто макросом или локальной переменной)
    ns::var := 0; # Имя глобальной перменной в явном виде не может быть перекрыто 

    name:: {
        var := 0; # Обращение к переменной ns::var
        var2 := 0; # Имя переменной будет ns::name::var2
        ::var := 1; # Переменная из глобального пространства имен
    };

    :: { # Глобальное пространство имен
        var := 1; 
    };
};
```

## Пространство имен и модули

Пространство имен в *NewLang* поддерживает одновременно с [модульной структурой кода](/ru/docs/syntax/modules/) как в языках Java и Python
и при указании полного имени объекта, программные модули и пространства имен можно объединять. 

Например, полное имя переменой можно записать с указанием программного модуля `\root\dir\module::ns::name::var`, 
где **root** и **dir** это каталоги в файловой системе относительно текущего модуля, а **module** — имя файла, т.е. *root/dir/module.nlp*


## Пространство имен и ООП

В *NewLang* не применяется декорирование (манглинг) имен, основанный на типах аргументов функций.

Тем не менее при создания уникальных идентификаторов для методов [классов](/ru/docs/types/class/) *NewLang* использует подход, похожий на применяемый в языке Python. 
При создании [метода класса](/ru/docs/types/class/) создается глобальная функция с именем класса и именем метода, объединенные через разделитель "**::**". 

Например, для класса `:NewClass` при создании метода `method` будет создана функция с именем `NewClass::method`.

Такая схема наименований методов полностью соответствует именованию функций в пространстве имен, 
и тем самым позволяет определять методы класса вне тела самого класса, просто указав нужное имя в пространстве имен или в явном виде.

Пример создания метода класса *NewClass* в области имен: 
```
    NewClass::  {
        method() := { };
    }
```

Пример создания метода класса *NewClass* с указанием полного имени: 
```
    NewClass::method() := { };
```


