---
title: Именование объектов
description:  Правила именования переменных, функций и типов данных
weight: 10
---

В качестве имен объектов и типов данных можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, 
при условии, что первый символ имени не является цифрой. 

Все идентификаторы должны быть уникальны, а для избежания коллизий можно использовать [пространство имен](/ru/docs/syntax/namespace/) 
и [модульную структуру кода](/ru/docs/syntax/modules/), которые *NewLang* поддерживает одновременно.

Перегрузка [функций](/ru/docs/types/funcs/) по типам аргументов *NewLang* отсуствует, поэтому несколько функций с однинаковым именем но разными аругментами определить нельзя,
но можно [переопределить функцию](/ru/docs/types/funcs/), в том числе и расширив типы принимаемых аргументов или увеличив их количество.


Идентификатор объекта может содержать один или несколько специальных символов - квалификаторов 
(или [сигилов](https://en.wikipedia.org/wiki/Sigil_(computer_programming))), за которыми закрепелено определенное значение.
Идентификатор объекта который не содержит квалификатора, называется *простым*:

### Квалификаторы имен: {#sigil}
- '**@**' — префикс *собачка* используется для указания имени [макроса](/ru/docs/syntax/macros/), 
        который обрабатыватся препроцессором до начала синтаксического анализа исходного текста программы.
- '**$**' — знак доллара в начале имени объекта обозначает автоматичекое имя временной переменной, 
        область памяти для которой выделяется динамически во время выполнения приложения, а время [жизни ограничено семантикой яызка](/ru/docs/syntax/memory/)
- '**::**' — двойное двоеточие является разделителем [пространства имен](/ru/docs/syntax/namespace/),
        и является признаком *статического* объекта, область памяти для которого выделяется во время компиляции приложения или модуля.
        Если имя начинается на '**::**', то область видимости объекта будет глобальной и он будет доступен в рамках всего приложения.
        В противном случае, видимость объекта будет ограничена только текущим [программным модулем](/ru/docs/syntax/modules/).
- '**.**' — префикс *точка* используется при обращении к полю модуля или класса (ограничивает область видимости текущим объектом).
        Префикс *точка* может использоваться при определении (вызове) функции для явной идентификации именованного аргумента,
        чтобы его нельзя было перекрыть макросом препроцессора.
- '**\\**' — *обратный слеш* в начале термина обозначает имя [программного модуля](/ru/docs/syntax/modules/), 
        а так же разделяет имена каталогов в иерархии размещения программных модулей.
- '**:**' — двоеточие в начале термина обозначает имя [типа](/ru/docs/types/) данных или конструктор [класса](/ru/docs/types/class/)
- '**%**' — префикс *знак процента* указывается для [импортируемых символов (нативных переменных и функций)](/ru/docs/types/native/)
- '**^**' — символ *карет* (крышечка/домик) после имени используется для придания объекту иммутабельности (константности, не изменяемости). 


### Разрешение имен (name lookup) {#name-lookup}
Если имя объекта не содержит [квалификатора](/ru/docs/syntax/naming/#sigil), оно называется *простым*.
Создание объекта с указанием *простого* имени равнозначно созданию локального объекта.

В других случаях, когда *NewLang* встречает *простое* имя объекта без квалификатора ([сигила](https://en.wikipedia.org/wiki/Sigil_(computer_programming))), 
то в дело вструпает специальный алгоритм, который связывает *простое* имя, встретившееся в исходном тексте программы, 
с его декларацией или конкретным объектом по его [внутреннему имени](/ru/docs/arch/mangling/).

Разрешение *простых* имен *без квалификатора* (*name lookup*, или поиск имени функции/переменной) происходит всегда в строго определенном порядке:
- в первую очередь происходит поиск имени среди макросов
- далее выполняется поиск имени среди локальных объектов до объектов текущего модуля
- в последнюю очередь выполняется поиск среди глобальных объетов с постепенным расширением пространства имен области поиска от текущей до глобальной

Такая последовательность разрешение имен всегда предоставляет возможность переопределить 
глобальные/локальные объекты или имена аргументов у функций для уже существующего кода без его серъезных изменений.

Например, для имени `name` в области имен **`ns`** поиск происходит в следующей последовательности: 
`@name` -> `$name` -> `ns::name` -> `::ns::name` -> `::name`,
а для имени `arg` проверяется только `@arg`:
```python
    ns:: {
        name(arg="value");
    };
```

И в тоже время, всегда остатся возможность указать конкретный объект не зависимо от работы алгоритма разрешение *простых* имен.
Достаточно указать квалификатор в имени объекта в явном виде. 

Например, обратиться к глобальному объекту **name** из пространства имен **ns** из примера выше, нужно по полному имени объекта `::ns::name`,
а именованнй аргумент *'**.** arg'* не будет заменен макросом `@arg`, если такой будет определен:
```python
    ::ns::name(.arg="value");
```

### Расширение поиска простанства имен {#using}
Для указания нескольких областей имен для расширенного поиска при разрешение *простых* имен *без квалификатора*,
используется синтаксическая конструкция `... = ns::name, ns::name2;` или `@using(ns::name, ns::name2);` с использованием DSL. 

Поиск в перечисленных областях имен произволится в порядке их указания до конца текущего модуля или до следущего 
оператора расширенного поиска или до `... = _;`, который расширенный поиск в пространствах имен отменяет.



### Предварительное объявление {#forward-declaration}
В тексте программы можно ссылаться только на реально существующие (созданные) объекты.
Но для тех случаев, когда требуется сослаться на объект, который создан в другом модуле или будет создан позже,
можно сделать предварительное объявление, при котором компилятор регистриурет имя и тип объекта без его реального создания.

За счет предварительного объявления можно ссылаться только на статические объекты (типы данных), 
или локальные поля класса о которых компилятор ещё не знает, но которые будут определены в процессе компиляции позже. 

Для предварительного объявления можно использовать [внутреннее имя](/ru/docs/arch/mangling/)
или полное квалифцированное имя, которое должно будет в точности совпадать с именем обекта при его последующем создании.

Для предварительного объявления используется точто такой же синтаксис, как и при реальном [создании](/ru/docs/ops/create/) объекта,
только с права от операторо создания должно быть указано многоточие.

Область видимости предварительное объявения соответствует области видимости его размещенея, 
а не реальвой области видимости объекта (это касается даже глобальных объектов).

```python

    # Предварительное определение переменной модуля
    # Действует для всего модуля
    var_module:Int32 := ...;

    func() ::= {

        # Предварительное объявление с помощью DSL
        # (действует только внутри тела функции)
        @declare( func2(arg:Int32):Int32 );

        var_module = func2(var_module);
        @return var_module;
    };


    func2(arg:Int32):Int32 ::= {
        @return $arg*$arg;
    }

    var_module:Int32 := 1;
```


### Имена аргументов, специальные, системные имена {#args}
Обозначение имен аргументов у функций очень похоже на обращение к аргументы в bash скриптах, 
где "**$1**" или "**$name**" — порядковый номер или имя соответствующего аргумента.

Зарезервированное имя "**$0**" обозначает текущий объект, а именем "**$$**" обозначается родительский объект.

Все аргументы функции собранны в одном словаре со специальным имеенм **$\***

Неизменяемая переменная "**$^**" содержит результат выполнения последнего оператора или блока кода.

Полное имя текущего модуля содержится в переменной **@\\\\**, а текущая область имен в переменной **@::**, т.е.:
```bash
# Имя файла filename.src в каталоге dir

ns:: { # Использовать пространство имен ns
    name:: {
        # Команда препроцессора "@#" - преобразовать в символьную строку
        ns_str :=  @#  @::; # Строка с областью имен "::ns::name::"
        mod_str :=  @#  @\\; # Строка с именем модуля "\\dir\filename"
    };
};
```

### Константы (неизменяемые объекты)

#### constexpr

> constexpr позволяет определить переменные или функции таким образом, что их значение или результат может быть вычислен на этапе компиляции. 
> Т.е можно проводить вычисления до того, как код будет исполнен, и тем самым сэкономить драгоценные циклы процессора в рантайме.
> 
> Но не все так радужно. constexpr имеет свои ограничения. Например, нельзя использовать его с динамическим выделением памяти. 
> Так что если нужно создать constexpr вектор, который динамически изменяется во время компиляции - не выйдет.
> 
```python
    square^(arg) := {$arg * $arg}; # Во время компиляции
    cube(arg) :- {$arg * $arg * $arg};  # Чистая функция
    func(arg) := {cube(arg) + square($arg)};  # Обычная функция
```

#### consteval

> Отличие consteval от его братца constexpr в том, что constexpr дает выбор: если что-то можно вычислить на этапе компиляции, 
> отлично, но если нет — ну что ж, попробуем в рантайме. consteval же стоит на своем: если мы не можем вычислить это здесь и сейчас 
> (на этапе компиляции), то и в программе это выражение быть не должно.
> 
> Это мастхев, когда нужно гарантировать, что определенные вычисления будут выполнены на этапе компиляции, 
> исключая любую неопределенность и потенциальные накладные расходы в рантайме. consteval приходит на помощь, 
> когда нужна стопроцентная уверенность в том, что код не будет тратить лишнее время на вычисления в момент выполнения.
> 
```python
    consteval^ := "literal";
    pi^ := 3.141592653589793238462643;
    consteval^ := square(123); # Ок
    consteval1^ := square^(123);
    consteval2^ := cube^(123); # Ok для чистых и constexpr функций
    consteval3^ := func^(123); # Ошибка !!!!
```

#### constinit

> В отличие от constexpr, который является своего рода всегда вычисляемым выражением, 
> и consteval, которое требует вычисления на этапе компиляции без исключений, constinit подходит к делу более гибко.
> 
> constinit указывает, что переменная должна быть инициализирована во время старта программы, 
> до входа в main(). constinit обеспечивает инициализацию статического или потокового хранилища без динамической инициализации. 
> Говоря простым языком, constinit гарантирует, что переменная будет инициализирована на этапе загрузки программы, 
> ещё до того, как программа начнет своё выполнение. Отсюда вытекает то, в отличие от constexpr, constinit не требует, 
> чтобы переменная оставалась неизменной после инициализации. 


Аналог `constinit`. Присовить незменяемое значение обычной переменой. Но сама переменная в последствии может быть изменена.
```python
    literal1 := "literal";
    literal2 := 123;
    value := square(123);
    value := square^(123);
    value := cube(123);
    value := cube^(123); # Ок - вычисляется в рантайме
    value := pi;
    value := pi^;
```
