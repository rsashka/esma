---
title: Именование объектов
description:  Правила именования переменных, функций и типов данных
weight: 10
---

В качестве имен объектов и типов данных можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, 
при условии, что первый символ имени не является цифрой. 

Все идентификаторы должны быть уникальны, а для избежания коллизий можно использовать [пространство имен](/ru/docs/syntax/namespace/) 
и [модульную структуру кода](/ru/docs/syntax/modules/), которые *NewLang* поддерживает одновременно.

Перегрузка [функций](/ru/docs/types/funcs/) по типам аргументов *NewLang* отсуствует, поэтому несколько функций с однинаковым именем но разными аругментами определить нельзя,
но можно [переопределить функцию](/ru/docs/types/funcs/), в том числе и расширив типы принимаемых аргументов.


Идентификатор объекта может содержать один или несколько специальных символов - квалификаторов, за которыми закрепелено определенное значение:

### Квалификаторы имен:
- **$** — знак доллара в начале имени обозначает системное (локальное) имя переменной, 
        область памяти для которой выделяется во время выполнения, а время [жизни ограничено семантикой яызка](/ru/docs/syntax/memory/)
- **::** — двойное двоеточие являются разделителем при указании [пространства имен](/ru/docs/syntax/namespace/). 
        Явное указание пространства имен является признаком глобального объекта, область памяти для которого выделяется во время компиляции приложения или модуля.
- **@** — префикс *собачка* используется для указания имени [макроса](/ru/docs/syntax/macros/)
- **\\** — *обратный слеш* в начале имени обозначает [программный модуль](/ru/docs/syntax/modules/), а так же разделяет имена каталогов
- **:** — двоеточие в начале имени обозначает [тип данных](/ru/docs/types/)
- **%** — префикс *знак процента* указывается для [импортируемых символов (нативных переменных и функций)](/ru/docs/types/native/)
- **^** — суффикс карет используется для придания объекту иммутабельности (константности, не изменяемости). 





### Разрешение имен (name lookup)
Когда парсер *NewLang* встречает имя объекта без квалификатора, то в дело вструпает специальный алгоритм,
который связывает имя, встретившееся в исходном тексте программы, с его декларацией или конкретным объектом.

Разрешение имен (name lookup, или поиск имени функции/переменной) происходит всегда в строго определнном порядке:
- в первую очередь происходит поиск имени среди макросов
- далее выполняется поиск имени среди локальных объетов 
- в последнюю очередь выполняется поиск среди глобальных объетов с постепенным расширением пространства имен области поиска от текущей до глобальной

Такая последовательность разрешение имен всегда предоставляет возможность переопределить 
глобальные/локальные объекты для уже существующего кода без его серъезных изменений.

Например, для имени `name` в области имен **`ns`** поиск происходит в следующей последовательности: `@name` -> `$name` -> `::ns::name` -> `::name`.

И в тоже время, всегда остатся возможность указать конкретный объект не зависимо от работы алгоритма разрешение имен.
Достаточно указать квалификатор в имени объекта в явном виде. 

Например, для глобального объекта **name** в пространстве имен **ns** из примера выше, это будет полное имя объекта `ns::name`. 


### Специальные и системные имена
- Семантика аргументов у функций очень похожа на аргументы в bash скриптах, где "**$1**" или "**$name**" — порядковый номер или имя аргумента
- Имя "**$0**" обозначает текущий объект
- Родительский объект обозначается "**$$**"
- Неизменяемая переменная "**$^**" содержит результат выполнения последнего оператора или блока кода


!!!!!!!!- **args** - Все аргументы функции (**$\***)

!!!!!!!!- **sys** - Системный контекст запущенной программы (**@@**)
!!!!!!!!- **current** - Текущий модуль (**@$**)
!!!!!!!!- **cmd** - Все аргументы выполняющегося приложения из командной строки (**@\***)


### Области видимости
Символ подчерка, а так же подчерк в начале имени или двойные подчерки в начале и в конце имени имеют специальное значение.

Области видимости объектов определяются аналогично принятым в языке Python с помощью подчерков перед именем переменной.

Один подчерк соответствует защищенной, а два подчерка - приватной области видимости объекта в соответствующем модуле или классе.

Но так же как и в языке Python, области видимости больше соответствуют "джентльменской" договоренности и при явном указании имени,
доступ к защищенным объектам можно получить указав их полное имя.

Системные поля и объекты начинаются и заканчиваются на два подчерка.
