---
title: Именование объектов
description:  Правила именования переменных, функций и типов данных
weight: 10
---

В качестве имен объектов и типов данных можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, 
при условии, что первый символ имени не является цифрой. 

Все идентификаторы должны быть уникальны, а для избежания коллизий можно использовать [пространство имен](/ru/docs/syntax/namespace/) 
и [модульную структуру кода](/ru/docs/syntax/modules/), которые *NewLang* поддерживает одновременно.

Перегрузка [функций](/ru/docs/types/funcs/) по типам аргументов *NewLang* отсуствует, поэтому несколько функций с однинаковым именем но разными аругментами определить нельзя,
но можно [переопределить функцию](/ru/docs/types/funcs/), в том числе и расширив типы принимаемых аргументов или увеличив их количество.


Идентификатор объекта может содержать один или несколько специальных символов - квалификаторов (или [сигилов](https://en.wikipedia.org/wiki/Sigil_(computer_programming))), за которыми закрепелено определенное значение:

### Квалификаторы имен:
- '**$**' — знак доллара в начале имени обозначает системное (локальное) имя временной переменной, 
        область памяти для которой выделяется во время выполнения, а время [жизни ограничено семантикой яызка](/ru/docs/syntax/memory/)
- '**::**' — двойное двоеточие являются разделителем при указании [пространства имен](/ru/docs/syntax/namespace/). 
        Явное указание пространства имен является признаком статического объекта, область памяти для которого выделяется во время компиляции приложения или модуля.
        Если имя начинается на '**::**', то такой объект будет глобальным и доступен в рамках всей системы. 
        В противном случае, видимость объекта будет ограничена только текущим [программным модулем](/ru/docs/syntax/modules/).
- '**@**' — префикс *собачка* используется для указания имени [макроса](/ru/docs/syntax/macros/)
- '**.**' — префикс *точка* используется при обращении к полю объекта или для явной идентификации именованного аргумента при определении/вызове функции
- '**\\**' — *обратный слеш* в начале термина обозначает имя [программного модуля](/ru/docs/syntax/modules/), 
        а так же разделяет имена каталогов в иерархии размещения программных модулей.
- '**:**' — двоеточие в начале термина обозначает имя [типа данных](/ru/docs/types/) или конструктор [класса](/ru/docs/types/class/)
- '**%**' — префикс *знак процента* указывается для [импортируемых символов (нативных переменных и функций)](/ru/docs/types/native/)
- '**^**' — символ *карет* (крышечка/домик) после имени используется для придания объекту иммутабельности (константности, не изменяемости). 





### Разрешение имен (name lookup)
Когда парсер *NewLang* встречает имя объекта *без квалификатора*, то в дело вструпает специальный алгоритм,
который связывает имя, встретившееся в исходном тексте программы, с его декларацией или конкретным объектом.

Разрешение имен *без квалификатора* (name lookup, или поиск имени функции/переменной) происходит всегда в строго определенном порядке:
- в первую очередь происходит поиск имени среди макросов
- далее выполняется поиск имени среди локальных объетов 
- следующим по очереди ищуются имена текущего модуля
- в последнюю очередь выполняется поиск среди глобальных объетов с постепенным расширением пространства имен области поиска от текущей до глобальной
- если поиск не дал результатов, то имя считается локальным, т.е. аналогом обращения к локальной переменой (именованному аргументу в определении или при вызове функции)

Такая последовательность разрешение имен всегда предоставляет возможность переопределить 
глобальные/локальные объекты или имена аргументов у функций для уже существующего кода без его серъезных изменений.

Например, для имени `name` в области имен **`ns`** поиск происходит в следующей последовательности: 
`@name` -> `$name` -> `ns::name` -> `::ns::name` -> `name` -> `::name`,
а для имени `arg` проверяется только `@arg`:
```python
    ns:: {
        name(arg="value");
    };
```

И в тоже время, всегда остатся возможность указать конкретный объект не зависимо от работы алгоритма разрешение имен.
Достаточно указать квалификатор в имени объекта в явном виде. 

Например, обратиться к глобальному объекту **name** из пространства имен **ns** из примера выше, нужно по полному имени объекта `::ns::name`,
а именованнй аргумент *'**.** arg'* не будет заменен макросом `@arg`, если такой будет определен:
```python
    ::ns::name(.arg="value");
```


### Аргументы, специальные, системные имена и области видимости
Обозначение имен аргументов у функций очень похоже на обращение к аргументы в bash скриптах, 
где "**$1**" или "**$name**" — порядковый номер или имя соответствующего аргумента.

Зарезервированное имя "**$0**" обозначает текущий объект, а именем "**$$**" обозначается родительский объект.

Все аргументы функции собранны в одном словаре со специальным имеенм **$\***

Неизменяемая переменная "**$^**" содержит результат выполнения последнего оператора или блока кода.

Полное имя текущего модуля содержится в переменной **@\\\\**, а текущая область имен в переменной **@::**, т.е.:
```bash
# Имя файла filename.nlp в каталоге dir

ns:: { # Использовать пространство имен ns
    name:: {
        # Команда препроцессора "@#" - преобразовать в символьную строку
        ns_str :=  @#  @::; # Строка с областью имен "::ns::name::"
        mod_str :=  @#  @\\; # Строка с именем модуля "\\dir\filename"
    };
};
```

### Области видимости
Символ подчерка, а так же подчерк в начале имени или двойные подчерки в начале и в конце имени имеют специальное значение.

Один подчерк соответствует защищенной, а два подчерка - приватной области видимости объекта в модуле или классе,
что соответствует принятым соглашениям в языке Python. 

Но так же, как и в языке Python, области видимости больше соответствуют "джентльменской" договоренности и при явном указании имени,
доступ к защищенным объектам можно получить, просто указав полное имя объекта.

В дополнении к этому, существуют еще системные поля и объекты, которые начинаются и заканчиваются на два подчерка.
