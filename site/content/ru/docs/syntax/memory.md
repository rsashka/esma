---
title: Ссылки и совместный доступ
# description:  Правила синтаксиса языка
# date: 2017-01-05
weight: 40
---

https://habr.com/ru/companies/otus/articles/763810/
https://habr.com/ru/articles/764420/


- Последовательная согласованность отсутствует (отсутствуют атомарныти типы)

Любой язык программирования так или иначе вынужден управлять опретивной памятью. 
В *NewLang* реализовано автоматическое управление памятью без сборщика мусора.

За основу была взята модель "владения" из языка Rust, но она переработа под концепцию сильных 
и слабых указателей (аналоги shared_ptr и weak_ptr из С++), 
где каждое значение в памяти может иметь только одну переменную-владельца с сильным указателем. 

И когда такая переменная-владелец уходит из области видимости, счетчик ссылок уменьшается и при достжении нуля память освобождается. 

Фактически, это автоматическое управление памятью с помощью подсчёта ссылок на этапе компиляции и без использования сборщика мусора.


Существование ссылок на объекты предполагает и возможность 
одновременного доступа к данным из нескольких потоков выполнения.
Из-за чего управление памятью включает в себя и элементы межпотокового взаимодействия, 
так как совместное владение ссылками по любому будет требовать каких либо 
механизмов синхронизации доступа к переменным. 

Поэтому, при определении объекта указывается какие типы ссылок допускается создавать на него,
а так-же какая используемая модель совместного доступа к переменной.

Весь механизм подсчета ссылок и проверки их корректности реализован на **уровне синтаксиса**.
В рантайме выполняется только контроль идентификатора потока для однопоточных ссылок, а все остальные проверки выполняются во время компиляции.


## Правила владения ссылками и терминология
- Вручную выделить или освобондить память нельзя
- Память выделяется и освобожадется автоматически при создании/удалении объектов которые сохраняются в переменных.
- Переменные могут быть двух видов:
    - **глобальные** - переменные модулей (они определяются вне тела функций и блоков кода), 
        память для них выделяется во время компиляции модуля, 
        а время жизни, пока модуль остается загруженным в памяти. 
    - **локальные** - переменные, область видимости которых строго ограничена синтаксисом языка
        (переменные внутри функций и её аргументы, переменные внутри блоков кода и т.д.).
        Память для локальной переменной выделяется по мере необходимости 
        и при выходе из области видимости локальная переменная автоматически удаляется. 
- Любая переменная - это ссылка на объект, расположенный в памяти (в куче или на стеке)
- Ссылки бывают двух видов:
  - Сильные/Владеющие (аналог shared_ptr из С++) - которая увеличивает счетчик ссылок на объект на единицу.
  - Слабые/Не владеющие (аналог weak_ptr из С++) - указатели на объекты, 
      которые перед использование требуют обязательного захвата (т.е. преобразования в сильную ссылку).
- Переменная со слабой/не владеющей ссылкой создается только тогда, когда 
в правой части операции присвоения присутствует любой из операторов получения ссылки 
(**&**, **&&**, **&\*** или **&^**, **&&^**, **&\*^**).  
- Во всех остальных случаях создается переменная владелец с сильной/владеющей ссылкой. 
- Чистые функции не могут напрямую обращаться к любым глобальным объектам.

### Захват ссылки и значение переменной
- Захват ссылки - это преобразование слабой ссылки в сильную с инкрементом счетчика ссылок и 
получением доступа к значению объекта. Для захвата используются операторы 
"**\***" - автоматический выбор доступа (чтения/запись или только чтение) 
или "**\*^**" - захват доступа только для чтение.

Упрощенный условный пример:
```
    ref := & owner;  # переменная ref - слабая ссылка на owner
    ref_ro := &^ owner;  # слабая ссылка на owner только для чтения

    val := * ref;  # Автоматический захват только для чтения 
    *ref = val;    # Автоматический захват для чтения/записи

    val := *^ ref; # Захват только для чтения

    val := *^ ref_ro; 
    val := * ref_ro;  # Автоматический захват только для чтения
    *ref_ro = val;    # Ошибка - ссылка только для чтения !!!
    *^ ref_ro = val;  # Ошибка - недопустима конструкция (захват lval - только для чтения)
```

- Слабую ссылку можно захватить (превратить в сильную) сохранив результат в локальной переменной,
    после чего работать с локальной переменной "по значению" 
    без необходимости захватытвать ссылку при каждом обращении к переменной.
- Значения переменных со слабыми ссылками можно копировать в другие переменные без ограничений.
- Значение переменной с сильной ссылкой нельзя скопировать в другую переменную или поле объекта, 
но можно клонировать данные или обменяться значениями "**:=:**" с другой переменной с сильной ссылкой (swap).
```
    owner := 123;
    other := 345;

    owner = other; # Ошибка - нельзя копировать!
    owner = other(); # Глубокое клонирование данных
    owner :=: other; # Обмен значениями (swap)
    other = _; # Очистка данных объекта

```
 


- Переменную, содержащую ссылку на ссылку создать нельзя, 
но можно создать ссылочный тип и после чего создать переменную ссылку на этот тип данных.

Упрощенный условный пример:
```
    value := 123;
    :RefInt := & Integer;
    ref_int :RefInt := & value;
    ref_ref := & ref_int;
    
```

- Если переменная владелец разрешает создавать ссылки на объект, тогда при обращении к такой переменой 
требуется выполнять захват объекта для обеспечения работы механизма совместного доступа.

## Ссылки и совместный доступ

Управление временем жизни переменной включает в себя не только управление памятью, 
но и механизм синхронизации для монопольного/раздельного доступа к объектам из разных потоков.

- При определении переменной необходимо сразу указать какие способы получения ссылок на неё разрешены:
    - без возможности создания ссылок (оператор создания ссылки не указывается), 
    в этом случае компилятор не даст создать ссылку на переменную, а совместный доступ к ней будет не возможен
    - разрешено создавать ссылки на объект только в текущем потоке (операторы "**&**" или "**&\*^**" для неизменяемых данных). 
        В этом случае компилятор не будет создавать объект синхронизации доступа, а к переменной 
        будет нельзя обратиться из других потоков (она будет не видна из другого модуля, 
        а во время выполннения программы при доступе к переменной происходит контроль идентификатора потока).
    - разрешено создавать ссылки с монопольным доступом (операторы "**&&**" или "**&&^**" для неизменяемых данных). 
        Компилятор автоматически создает скрытый **не рекурсивный** мьютекс для синхронизации доступа к переменой.
    - разрешено создавать ссылки с рекурсивным доступом (операторы "**&\***" или "**&\*^**" для неизменяемых данных). 
        Компилятор автоматически создает скрытый **рекурсивный** мьютекс (его можно захватывать в одном потоке несколько раз)
- Все виды ссылок могут быть помечены как не изменяемые (в конце ставится признак иммутабельности **^**), 
тогда захват таких ссылок для модификации данных будет невозможен.
- Если объект в переменной уже является константой, то для него могут быть разрешены ссылки только для чтения, 
а объект синхронизации для такой переменной не потребуется даже для совместного доступа из разных потоков.
- Для получения/изменения значения у переменной со *слабой ссылкой* испольузется оператор "**\***" 
    получения (захвата) доступа к объекту, который не только преобразует слабую ссылку в сильную, 
    но и захватывает объект синхронизации для *чтения/записи* или *только для чтения* в зависимости от контекста. 
    Оператор "**\*^**" используется для получения (захвата) доступа к объекту в режиме *только для чтения*. 
- *Для получения/изменения значения у **переменной - владельца объекта с совместным доступом** 
    требуется захват объекта синхронизации как при работе со слабыми ссылками*.
- Если захват слабой ссылки невозможен (объект-владелец удален), 
возвращается пустая ссылка (**Nil**) или происходит исключение (ошибка времени выполнения). ???????????????????
- Возможные ссылки на переменную указываются при её объявлении перед именем (в левой части оператора создания переменной).

Примеры ссылок:
```
    & local := 123;     # Разрешено создание ссылок только в текущем потоке
    && thread := 456;   # Разрешено создание ссылок с монопольным доступом в любом потоке
    
    ref := & local;     # Создание слабой ссылки на local
    ref2 := && local;   # Ошибка! многопоточные ссылки не разрешены
    ref_th := && thread;  # Создание слабой ссылки на thread 
                          # c монопольной блокировкой доступа

    local += 1; # ОК
    thread  += 1; # Ошибка, требуется захват объекта с разеляемым доступом
    
    *local += 1; # ОК, оператор захвата игнорируется
    *thread  += 1; # Захват объекта (как захват слабой ссылки)
    
    ref += 1;   # Ошибка, требуется захват слабой ссылки
    ref_th += 1;   # Ошибка, требуется захват слабой ссылки
    
    *ref += 1;   
    *ref_th += 1;
```



## Резюме для обозначений
- Без указания типа ссылки - на переменную создать ссылку нельзя
- **&** - разрешено создавать ссылки для чтения/записи в текущем потоке (объект синхронизации доступа не требуется)
- **&&** - разрешено создавать мнопоточные ссылки для чтения/записи с монопольной блокировкой доступа
- **&\*** - разрешено создавать мнопоточные ссылки для чтения/записи с рекурсивной блокировкой доступа
- модификатор **^** (т.е. **&^**, **&&^** или **&\*^**) - ссылки на константный объект, которая разрешает создавать ссылки *только для чтения*
- **\*** - оператор автоматического захвата объекта синхронизации доступа к переменной 
(*чтения/запись* или *только чтение* в зависимости от контекста) 
- **\*\*** - оператор *попытки* захвата объекта синхронизации доступа к переменной с преобразованием слабой ссылку в сильную
- **\***^ или **\*\*^** - захват или попытка захвата объекта синхронизации доступа для неизменяемого объекта (получение блокировки только для чтения)
- **()** после имени переменной - создание копии значения переменной (глубокое клонирование)


## Менеджер контекста

Операторы захвата ссылки и синхронизации доступа к объекту выполняются только для одного действия над переменной.
Но захват объекта синхронизации, это относительно медленная операция и выполнять её для каждого действия над переменной не рационально.

Для того, чтобы однократно захватить объект(ы) синхронизации для выполнения сразу нескольких действий 
над переменными можно захватить объект в локальную переменую или использовать [менеджер контекста](/ru/docs/ops/with/).

```
    **( ... ){  # try_lock
        ...
    };

    **( ... ){  # try_lock
        ...
    } ,[_] {    # Ветка else когда захват не удался
        ...
    };
```

Примеры захвата переменных с менеджером контекста:
```
    && $thread := 456;   # Разрешено получение монопольных ссылок в любом потоке (обычный мьютекс)
    &* $multi := 456;    # Возможны ссылки с рекурсивными блокировками доступа
    
    $ref_th := && $thread;    # получение слабой ссылки на thread
    $ref_mt := && $multi;     # получение слабой ссылки на multi

    $ref_th += 1;   # Ошибка, требуется захват объекта
    $ref_mt += 1;   # Ошибка, требуется захват объекта
    
    *$ref_th += 1;   # ОК
    *$ref_mt += 1;   # ОК

    **( val_th = *$ref_th ) { 
        $val_th += 1;   # ОК, объект захвачен в локальной переменной
        *$val_th += 1;   # ОК, оператор захвата игнорируется, т.к. объекта уже захвачен
    },[_]{
        $lock_fail := $^; # Получить ошибку захвата переменной
    }

```

Подробнее про [менеджер контекста написано тут](/ru/docs/ops/with/).












Примеры владения:
```
    owner := 123; # Переменная - владелец объекта
    
    copy := owner; # Ошибка - владелец может быть только один

    clone := owner(); # ОК, клонирование данных объекта
```


Примеры ссылок:
```
    & $local := 123;     # Разрешено получение ссылок только в текущем потоке
    && $thread := 456;   # Разрешено получение монопольных ссылок в любом потоке (обычный мьютекс)
    
    $ref := & $local;     # получение слабой ссылки на local
    $ref2 := && $local;   # Ошибка! многопоточные ссылки не разрешены
    $ref_th := && $thread;  # получение слабой ссылки на thread 
                            # c монопольной блокировкой доступа

    $local += 1; # ОК
    $thread  += 1; # ОК, захват объекта происходит автоматически

    $ref += 1;   # Ошибка, требуется захват слабой ссылки
    $ref_th += 1;   # Ошибка, требуется захват слабой ссылки
    
    *$local += 1; # ОК, оператор захвата игнорируется (происходит автоматически)
    *$thread  += 1; # ОК, оператор захвата игнорируется (происходит автоматически)
    *$ref += 1;   # ОК
    *$ref_th += 1;   # ОК
```





- Присовить значение переменной со слабой 
- Переменной со слабой ссылкой можно присовоить Операторы присвоения значения 


- Любая переменная имеет владельца, которыми могут быть переменная более высокого уровня или модуль.
- Когда переменная с сильной ссылкой уходит из области видимости (или модуль выгружается из памяти) - уменьшается счетчик ссылок и при достижении нуля - память освобождатеся.
- Объект может иметь только одну **глобальную** переменную с сильной ссылкой и произвольное количество любых типов ссылок в **локальных** переменных. 
- Для **глобальных** переменных разрешается делать только слабые ссылки, которые перед использованием требуется захватить (превратить в сильную ссылку в **локальной** переменной).






!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
???????????????????????????????????????????????????????????????????????
### Пример программы

```
    rand():Int32 := %rand;
    usleep(usec:DWord64):None := %usleep;
    printf(format:FmtChar, ...):Int32 := %printf;

    func(count:Integer, target:String) := {
        $iter := 1..$count?; # Итератор для диапазона от 1 до $count
        [ $iter ?! ] <-> {   # Цикл, пока итератор валидный
            
            $step := $iter!;  # Получить текущий и перейти на следующий элемент итератора
            
            printf('Number %d from %s!', $step, $target);
                
            usleep( rand() % 1000 );    # Случайная задержка

        }
    }

    thread = :Thread(func, 5, 'thread');

    thread.start();

    func(5, 'main');

    thread.join();

```


Number 1 from the thread!
Number 1 from the main!
Number 2 from the thread!
Number 2 from the main!
Number 3 from the thread!
Number 4 from the thread!
Number 3 from the main!
Number 4 from the main!
Number 5 from the main!
Number 5 from the thread!



























## Термины и понятия
- Врчную выделить или освобондить память нельзя
- Память выделяется и освобожадется автоматически при создании/удалении объектов
- Любая переменная - это ссылка на объект, расположенный в памяти (в куче или на стеке)
- Ссылки бывают двух видов:
  - Сильные/Владеющие (аналог shared_ptr из С++) - которая увеличивает счетчик ссылок на объект на единицу.
  - Слабые/Не владеющие (аналог weak_ptr из С++) - указатели на объекты, 
      которые перед использование требуют обязательного захвата (т.е. преобразования в сильную ссылку).
- Переменные могут быть двух видов:
    - **глобальные** - переменные модулей (определенные вне тела функций), а память для них выделяется во время компиляции программы
    - **локальные** - их область жизни строго ограничена правилами синтаксиса языка (переменные внутри функций и её аргументы, переменные внутри блоков кода и т.д.). 
- Захват ссылки (объекта) - это преобразование слабой ссылки в сильную  

- Любая переменная имеет владельца, которыми могут быть переменная более высокого уровня или модуль.
- Когда переменная с сильной ссылкой уходит из области видимости (или модуль выгружается из памяти) - уменьшается счетчик ссылок и при достижении нуля - память освобождатеся.
- Объект может иметь только одну **глобальную** переменную с сильной ссылкой и произвольное количество любых типов ссылок в **локальных** переменных. 
- Для **глобальных** переменных разрешается делать только слабые ссылки, которые перед использованием требуется захватить (превратить в сильную ссылку в **локальной** переменной).


## Ссылки и совместный доступ

Управление временем жизни переменной включает в себя не только управление памятью, 
но и механизм синхронизации для монопольного/раздельного доступа к объектам из разных потоков.

- При определении переменной указываются возможные способы получения ссылок на неё, которые могут быть:
    - без возможности создания ссылок, т.е. компилятор не даст создать ссылку на такую переменную, 
      а совместный доступ к ней будет не возможен
    - возможно создание ссылки только в текущем потоке. 
        Компилятор при генерации машинного кода не будет создавать объект синхронизации доступа к такой переменой. 
        Но к ней нельзя будет получить доступ из других потоков (т.е. переменная будет не видна из другого модуля, 
        а во время выполннения программы при доступе к такой переменной происходит контроль идентификатора потока).
    - разрешено создавать ссылки с монопольным доступом. 
        Компилятор автоматически создает скрытый не рекурсивный мьютекс для синхронизации доступа к переменой.
    - разрешено создавать ссылки с рекурсивным доступом. 
        Компилятор автоматически создает скрытый рекурсивный мьютекс (его можно захватывать в одном потоке несколько раз)
- Все виды ссылок могут быть константными, т.е. захватывается доступ только для чтения.
- Если объект уже является константой, то объект синхронизации для управления совместным доступом для него не требуется.
- Для получения/изменения значения у переменной - владельца объекта с совместным доступом перед обращением к данным происходит 
    захват объекта синхронизации автоматический.
- Для получения/изменения значения у переменной со *слабой ссылкой* испольузется оператор "**\***" для получения (захвата) 
    доступа к объекту, который не только преобразует слабую ссылку в сильную, но и захватывает объект синхронизации у объектов с совместным доступом.
    - Для **локальных** переменных без совместного доступа оператор захвата объекта "**\***" игнорируется.
    - Так как все ссылки для **глобальных** переменных создаются как слабые, то для работы с ними используется тот же самый оператор 
        получения (захвата) объекта в **локальную** переменную.  
        Такое использование логики захвата объектов на 
        *уровне синтаксиса языка гарантирует последующее автоматическое освобождение временной переменной*, 
        что исключает возможность создания циклических ссылок.
- Если захват слабой ссылки невозможен (объект-владелец удален), происходит исключение (ошибка времени выполнения). 
- Поведение захвата объекта синхронизации зависит от типа ссылки (мьютекс рекурсивный или не рекрусивный). 
    При использовании не рекрусивного мьютекса, чтобы избежать дидлока, можно для захвата ссылки и объекта синхронизации доступа 
    использовать оператор "**\*\***" без генерации исключения (аналог try_lock).



## Используемые обозначения
- Без указания типа ссылки - на переменную создать ссылку нельзя
- **&** - разрешено создавать ссылки для чтения/записи в текущем потоке (объект синхронизации доступа не требуется)
- **&&** - разрешено создавать мнопоточные ссылки для чтения/записи с монопольной блокировкой доступа
- **&\*** - разрешено создавать мнопоточные ссылки для чтения/записи с рекурсивной блокировкой доступа
- модификатор **^** (т.е. **&^**, **&&^** или **&\*^**) - ссылки на константный объект, которая блокирует объект только для чтения
- **\*** - оператор захвата объекта синхронизации доступа к переменной, который преобразует слабую ссылку в сильную
- **\*\*** - оператор *попытки* захвата объекта синхронизации доступа к переменной с преобразованием слабой ссылку в сильную
- **\***^ или **\*\*^** - захват или попытка захвата объекта синхронизации доступа для неизменяемого объекта (получение блокировки только для чтения)
- **()** после имени переменной - создание копии значения переменной (глубокое клонирование)


Примеры владения:
```
    owner := 123; # Переменная - владелец объекта
    
    copy := owner; # Ошибка - владелец может быть только один

    clone := owner(); # ОК, клонирование данных объекта
```


Примеры ссылок:
```
    & $local := 123;     # Разрешено получение ссылок только в текущем потоке
    && $thread := 456;   # Разрешено получение монопольных ссылок в любом потоке (обычный мьютекс)
    
    $ref := & $local;     # получение слабой ссылки на local
    $ref2 := && $local;   # Ошибка! многопоточные ссылки не разрешены
    $ref_th := && $thread;  # получение слабой ссылки на thread 
                            # c монопольной блокировкой доступа

    $local += 1; # ОК
    $thread  += 1; # ОК, захват объекта происходит автоматически

    $ref += 1;   # Ошибка, требуется захват слабой ссылки
    $ref_th += 1;   # Ошибка, требуется захват слабой ссылки
    
    *$local += 1; # ОК, оператор захвата игнорируется (происходит автоматически)
    *$thread  += 1; # ОК, оператор захвата игнорируется (происходит автоматически)
    *$ref += 1;   # ОК
    *$ref_th += 1;   # ОК
```

## Менеджер контекста

Операторы захвата ссылки и синхронизации доступа к объекту выполняются только для одного действия над переменной.
Но захват объекта синхронизации, это относительно медленная операция и выполнять её для каждого действия над переменной не рационально.

Для того, чтобы однократно захватить объект(ы) синхронизации для выполнения сразу нескольких действий 
над переменными используется [менеджер контекста](/ru/docs/ops/with/).

```
    *( ... ){   # lock
        ...
    };

    **( ... ){  # try_lock
        ...
    };

    **( ... ){  # try_lock
        ...
    } ,[_] {    # Ветка else
        ...
    };
```

Примеры захвата переменных с менеджером контекста:
```
    && $thread := 456;   # Разрешено получение монопольных ссылок в любом потоке (обычный мьютекс)
    &* $multi := 456;    # Возможны ссылки с рекурсивными блокировками доступа
    
    $ref_th := && $thread;    # получение слабой ссылки на thread
    $ref_mt := && $multi;     # получение слабой ссылки на multi

    $ref_th += 1;   # Ошибка, требуется захват объекта
    $ref_mt += 1;   # Ошибка, требуется захват объекта
    
    *$ref_th += 1;   # ОК
    *$ref_mt += 1;   # ОК

    *( val_th = *$ref_th ) { 
        $val_th += 1;   # ОК, объект захвачен в локальной переменной
        *$val_th += 1;   # ОК, оператор захвата игнорируется, т.к. объекта уже захвачен
    },[_]{
        $lock_fail := $^; # Получить ошибку захвата переменной
    }

    **( val_th = *$ref_th, val_mt = *$ref_mt ) { 
        $val_th += 1;   # ОК, объект захвачен в локальной переменной
        *$val_th += 1;   # ОК, оператор захвата игнорируется, т.к. объекта уже захвачен
    },[_]{
        $lock_fail := $^; # Получить ошибку захвата переменной
    }
```

Подробнее про [менеджер контекста написано тут](/ru/docs/ops/with/).




!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
???????????????????????????????????????????????????????????????????????
### Пример программы

```
    rand():Int32 := %rand;
    usleep(usec:DWord64):None := %usleep;
    printf(format:FmtChar, ...):Int32 := %printf;

    func(count:Integer, target:String) := {
        $iter := 1..$count?; # Итератор для диапазона от 1 до $count
        [ $iter ?! ] <-> {   # Цикл, пока итератор валидный
            
            $step := $iter!;  # Получить текущий и перейти на следующий элемент итератора
            
            printf('Number %d from %s!', $step, $target);
                
            usleep( rand() % 1000 );    # Случайная задержка

        }
    }

    thread = :Thread(func, 5, 'thread');

    thread.start();

    func(5, 'main');

    thread.join();

```


Number 1 from the thread!
Number 1 from the main!
Number 2 from the thread!
Number 2 from the main!
Number 3 from the thread!
Number 4 from the thread!
Number 3 from the main!
Number 4 from the main!
Number 5 from the main!
Number 5 from the thread!