---
title: Ссылки и совместный доступ
# description:  Правила синтаксиса языка
# date: 2017-01-05
weight: 40
---

Любой язык программирования так или иначе вынужден управлять памятью. 
В *NewLang* реализовано автоматическое управление памятью без сборщика мусора.

За основу была взята модель "владения" из языка Rust, но переработанная под концепцию сильных и слабых указателей 
(аналоги shared_ptr и weak_ptr из С++), где каждое значение в памяти может иметь только одну не контроллируемую переменную-владельца 
с сильным указателем. И когда такая переменная-владелец уходит из области видимости, память сразу же освобождается. 
Фактически, это автоматическое управление памятью с помощью подсчёта ссылок, но только на этапе компиляции и без использования сборщика мусора.

Существование ссылок на объекты предполагает и возможность одновременного доступа к данным из нескольких потоков выполнения.

Поэтому управление памятью включает в себя и декларирование способов межпотокового взаимодействия, так как 
совместное владение ссылками по любому будет требовать каких либо механизмов синхронизации доступа к переменным. 
При определении объекта указывается возможность получения ссылок на него,
а так же используемая модель совместного доступа к переменной.

Весь механизм подсчета ссылок и проверки их корректности реализован на **уровне синтаксиса**.
В рантайме выполняется только контроль идентификатора потока для однопоточных ссылок, а все остальные проверки выполняются во время компиляции.


## Термины и понятия
- Объект - это область памяти с данными (в куче или на стеке)
- Переменная - это ссылка на объект
- Ссылки бывают двух видов:
  - Сильные/Владеющие (аналог shared_ptr из С++) - которая увеличивает счетчик ссылок на единицу.
  - Слабые/Не владеющие (аналог weak_ptr из С++) - указатели на объекты, которые перед использование требуют обязательного захвата (т.е. преобразования в сильную ссылку).
- Переменные могут быть двух видов:
    - **глобальные** - переменные модулей (определенные вне тела функций), а память для них выделяется во время компиляции программы
    - **локальные** - их область жизни строго ограничена правилами синтаксиса языка (переменные внутри функций и её аргументы, переменные внутри блоков кода и т.д.). 
- Любая переменная имеет владельца, которыми могут быть переменная более высокого уровня или модуль.
- Когда переменная с сильной ссылкой уходит из области видимости (или модуль выгружается из памяти) - уменьшается счетчик ссылок и при достижении нуля - память освобождатеся.
- Объект может иметь только одну **глобальную** переменную с сильной ссылкой и произвольное количество любых типов ссылок в **локальных** переменных. 
- Для **глобальных** переменных разрешается делать только слабые ссылки, которые перед использованием требуется захватить (превратить в сильную ссылку в **локальной** переменной).


## Ссылки и совместный доступ

Управление временем жизни переменной включает в себя не только управление памятью, но и механизм синхронизации доступа к объектам.
- При определении переменной указываются возможные способы получения ссылок на неё, которые могут быть:
    - без возможности создания ссылок, т.е. компилятор не даст создать ссылку на такую переменную, а совместный доступ к ней будет не возможен
    - возможно создание ссылки только в текущем потоке. 
        Компилятор при генерации машинного кода не будет создавать объект синхронизации доступа к такой переменой. 
        Но к ней нельзя будет получить доступ из других потоков (т.е. переменная будет не видна из другого модуля, 
        а во время выполннения программы при доступе к такой переменной происходит контроль идентификатора потока).
    - разрешено создавать ссылки с монопольным доступом. 
        Компилятор автоматически создает скрытый не рекурсивный мьютекс для синхронизации доступа к переменой.
    - разрешено создавать ссылки с рекурсивным доступом. 
        Компилятор автоматически создает скрытый рекурсивный мьютекс (его можно захватывать несколько раз)
- Все виды ссылок могут быть константными, т.е. только для чтения, а если сам объект тоже является константой, 
    то объект синхронизации для управления совместным доступом для него не требуется.
- Для получения/изменения значения у переменной - владельца объекта с совместным доступом перед обращением к данным происходит 
    захват объекта синхронизации автоматический.
- Для получения/изменения значения у переменной со *слабой ссылкой* испольузется оператор "**\***" для получения (захвата) 
    доступа к объекту, который не только преобразует слабую ссылку в сильную, но и захватывает объект синхронизации у объектов с совместным доступом.
    - Для **локальных** переменных без совместного доступа оператор захвата объекта "**\***" игнорируется.
    - Так как все ссылки для **глобальных** переменных создаются как слабые, то для работы с ними используется тот же самый оператор 
        получения (захвата) объекта в **локальную** переменную.  
        Такое использование логики захвата объектов на 
        *уровне синтаксиса языка гарантирует последующее автоматическое освобождение временной переменной*, 
        что исключает возможность создания циклических ссылок.
- Если захват слабой ссылки невозможен (объект-владелец удален), происходит исключение (ошибка времени выполнения). 
- Поведение захвата объекта синхронизации зависит от типа ссылки (мьютекс рекурсивный или не рекрусивный). 
    При использовании не рекрусивного мьютекса, чтобы избежать дидлока, можно для захвата ссылки и объекта синхронизации доступа 
    использовать оператор "**\*\***" без генерации исключения (аналог try_lock).



## Используемые обозначения
- Без указания типа ссылки - на переменную создать ссылку нельзя
- **&** - разрешено создавать ссылки для чтения/записи в текущем потоке (объект синхронизации доступа не требуется)
- **&&** - разрешено создавать мнопоточные ссылки для чтения/записи с монопольной блокировкой доступа
- **&\*** - разрешено создавать мнопоточные ссылки для чтения/записи с рекурсивной блокировкой доступа
- модификатор **^** (т.е. **&^**, **&&^** или **&\*^**) - ссылки на константный объект, которая блокирует объект только для чтения
- **\*** - оператор захвата объекта синхронизации доступа к переменной, который преобразует слабую ссылку в сильную
- **\*\*** - оператор *попытки* захвата объекта синхронизации доступа к переменной с преобразованием слабой ссылку в сильную
- **\***^ или **\*\*^** - захват или попытка захвата объекта синхронизации доступа для неизменяемого объекта (получение блокировки только для чтения)
- **()** после имени переменной - создание копии значения переменной (глубокое клонирование)


Примеры владения:
```
    owner := 123; # Переменная - владелец объекта
    
    copy := owner; # Ошибка - владелец может быть только один

    clone := owner(); # ОК, клонирование данных объекта
```


Примеры ссылок:
```
    & $local := 123;     # Разрешено получение ссылок только в текущем потоке
    && $thread := 456;   # Разрешено получение монопольных ссылок в любом потоке (обычный мьютекс)
    
    $ref := & $local;     # получение слабой ссылки на local
    $ref2 := && $local;   # Ошибка! многопоточные ссылки не разрешены
    $ref_th := && $thread;  # получение слабой ссылки на thread 
                            # c монопольной блокировкой доступа

    $local += 1; # ОК
    $thread  += 1; # ОК, захват объекта происходит автоматически

    $ref += 1;   # Ошибка, требуется захват слабой ссылки
    $ref_th += 1;   # Ошибка, требуется захват слабой ссылки
    
    *$local += 1; # ОК, оператор захвата игнорируется (происходит автоматически)
    *$thread  += 1; # ОК, оператор захвата игнорируется (происходит автоматически)
    *$ref += 1;   # ОК
    *$ref_th += 1;   # ОК
```

## Менеджер контекста

Операторы захвата ссылки и синхронизации доступа к объекту выполняются только для одного действия над переменной.
Но захват объекта синхронизации, это относительно медленная операция и выполнять её для каждого действия над переменной не рационально.

Для того, чтобы однократно захватить объект(ы) синхронизации для выполнения сразу нескольких действий 
над переменными используется [менеджер контекста](/ru/docs/ops/with/).

```
    *( ... ){   # lock
        ...
    };

    **( ... ){  # try_lock
        ...
    };

    **( ... ){  # try_lock
        ...
    } ,[_] {    # Ветка else
        ...
    };
```

Примеры захвата переменных с менеджером контекста:
```
    && $thread := 456;   # Разрешено получение монопольных ссылок в любом потоке (обычный мьютекс)
    &* $multi := 456;    # Возможны ссылки с рекурсивными блокировками доступа
    
    $ref_th := && $thread;    # получение слабой ссылки на thread
    $ref_mt := && $multi;     # получение слабой ссылки на multi

    $ref_th += 1;   # Ошибка, требуется захват объекта
    $ref_mt += 1;   # Ошибка, требуется захват объекта
    
    *$ref_th += 1;   # ОК
    *$ref_mt += 1;   # ОК

    *( val_th = *$ref_th ) { 
        $val_th += 1;   # ОК, объект захвачен в локальной переменной
        *$val_th += 1;   # ОК, оператор захвата игнорируется, т.к. объекта уже захвачен
    },[_]{
        $lock_fail := $^; # Получить ошибку захвата переменной
    }

    **( val_th = *$ref_th, val_mt = *$ref_mt ) { 
        $val_th += 1;   # ОК, объект захвачен в локальной переменной
        *$val_th += 1;   # ОК, оператор захвата игнорируется, т.к. объекта уже захвачен
    },[_]{
        $lock_fail := $^; # Получить ошибку захвата переменной
    }
```

Подробнее про [менеджер контекста написано тут](/ru/docs/ops/with/).




!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
???????????????????????????????????????????????????????????????????????
### Пример программы

```
    rand():Int32 := %rand;
    usleep(usec:DWord64):None := %usleep;
    printf(format:FmtChar, ...):Int32 := %printf;

    func(count:Integer, target:String) := {
        $iter := 1..$count?; # Итератор для диапазона от 1 до $count
        [ $iter ?! ] <-> {   # Цикл, пока итератор валидный
            
            $step := $iter!;  # Получить текущий и перейти на следующий элемент итератора
            
            printf('Number %d from %s!', $step, $target);
                
            usleep( rand() % 1000 );    # Случайная задержка

        }
    }

    thread = :Thread(func, 5, 'thread');

    thread.start();

    func(5, 'main');

    thread.join();

```


Number 1 from the thread!
Number 1 from the main!
Number 2 from the thread!
Number 2 from the main!
Number 3 from the thread!
Number 4 from the thread!
Number 3 from the main!
Number 4 from the main!
Number 5 from the main!
Number 5 from the thread!