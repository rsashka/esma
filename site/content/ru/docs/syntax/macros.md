---
title: Макросы
# description:  Правила синтаксиса языка
# date: 2017-01-05
weight: 50
---


Макросы в **NewLang**, это один или несколько последовательных терминов, которые заменяются на другой термин 
или на целую синтаксическую конструкцию (последовательность лексем). 

Макросы обработываются во время работы **лексера**, т.е. перед передачей последовательности лексем в парсер, 
что позволяет с их помощью изменять даже сам синтаксис языка, например, при реализации собственных диалектов DSL.

### Определение макросов

Определение макросов аналогично [определению](/ru/docs/ops/create/) других объектов и состоит из трех частей 
**<имя макроса> <оператор создания/присвоения> <тело макроса>** и завершающая точка с запятой "**;**",
т.е. применяются обычные операторы **::=**, **=** или **:=** для создания нового или переопределения уже существующего объекта,
а имя макроса указывается между двумя символами **"@@"** и может содержать одну или нескольких лексем (терминов).

Все макросы относятся к глобальному пространству имен, поэтому первый термин в имени макроса должен быть уникальным,
иначе он будет прекрывать имена локальных и глобальных переменных при [разрешении имен](/ru/docs/syntax/naming/), 
если они указаны в коде без квалификаторов.

Телом макроса могут быть корректное выражение языка, последовательность лексем (которые заключается в двойные собачки **"@@"**, 
т.е. **`@@ лексема1 лексема1 @@`**) или обычная текстовая строка (которую нужно указать между тройными собачками **"@@@"**, т.е. **`@@@ текстовая строка @@@`**).

В имени макроса, кроме первого термина, могут присутствовать один или несколько шаблонов. 
*Шаблон* — это термин, который при сопоставлении последовательности лексем с идентификатором макроса 
может заменяться любым другим одиночным термином (т.е. фактически это сопоставление по образцу/шаблону).

Для создания термина-шаблона в начале его идентификатора нужно поставить знак доллара (что соответствует квалификатору локальной переменой), 
т.е. имя макроса `@@ FUNC $name @@` будет соответствовать последовательности лексем как `FUNC my_func_name`, так и `FUNC other_name_func`.

Для удаления макроса используется специальный синтаксис: `@@@@ name @@@@;` или `@@@@ два термина @@@@;`, 
т.е. необходимо указать идентификатор макроса между четырмя символами **"@@@@"**.

```bash
    # Тело макроса из текстовой строки (как в препроцессоре С/С++)
    @@macro_str@@ := @@@ строка - тело макроса @@@; # Строка для лексера

    # Удаления макроса @macro_str
    @@@@ macro_str @@@@;
```

### Аргументы макросов и их раскрытие

Макросы можно определять как с аргументами (параметрами в скобках), так и без них. 
Если макрос был определен с аргументами, то их проверка будет выполнятся макропроцессором при определении и раскрытии макроса.
Если макрос был определен без аргументов, то их наличие макропроцессором игнорируется.

Так как макропроцессор считает макросы с аргументами и без оных идентичными, то нельзя создать два макроса 
с одинаковыми именами, один из которых будет с аргументами (скобками), а другой без них.  

Поэтому, если требуется использовать макрос в двух разных вариантах (с аргументами и без них), 
тогда следует определять макрос без аргументов и в этом случае контроль параметров будет производить компилятор.

```bash
    @@macro@@ := term; # Макрос без аргументов
    
    macro(args); # ОК -> term(args);
    macro; # ОК -> term;

    # Но 
    @@call()@@ := term(); 

    call(); # ОК -> term();
    call; # Ошибка (@call определен с аргументами) 
```

Если при определении макроса указаны аргументы, то место для их вставки в теле макроса 
записывается как имя локальной переменой, перед которой добавлен символ **"@"**, т.е. **@$arg**.

Произвольное количество аргументов у макроса отмечается троеточием **"..."**, а место для их вставки отмечается в теле макроса лексемой **"@$..."**.

Место для вставки числа реально переданных аргументов отмечается лексемой **"@$#"**.
Если требуется вставить переданные аргументы в виде элементов словаря, 
то место для вставки отмечается лексемой **"@$\*"**.

По аналогии с препроцессором С/С++, для соединения двух лексем в одну, в теле макроса используется оператор **"@##"**, 
а для преобразование лексемы в текстову строку применяется операторы **@#**, **@#"** или **@#'**, например, 
`@@macro($arg)@@ := @@ func_ @## @$arg( @#" arg ) @;`, тогда вызов `macro(name);` будет преобразован в `func_name ("name");`


{{% pageinfo %}}

#### Ограничения макропроцессора в текущей версии

На текущий момент макросы реализованы в минимальном объеме для самых простых сценариев использования:

- DSL для keyword based syntax (if, else, return, match, while  и т.д.) - (1 термин с произвольными аргументами и без) - требуется сейчас !!!

*Парсер при обработке макросов может анализировать информацию о типах данных, если она указана.* 
*Но на текущий момент типы данных в макросах никак не обрабатываются и это одна из обязательных фич, которая будет реализована в будущем.*

- Определения (func, class) - (несколько терминов с аргументами и без аргументов) - Реализация ООП и импорт С++ классов
- Модификации при определениях (override) - (несколько терминов и шаблоны с аргументами и без аргументов) - Реализация ООП и импорт С++ классов

{{% /pageinfo %}}


# МАКРОСЫ БЕЗ АРГУМЕНТОВ ИЛИ ВСЕ АРГУМЕНТЫ СРАЗУ !!!!!
# анализа аргументов или их типов не производится !!!




Lambda
@@ lambda $name(...) @@ ::= @@  @$name( @$... ) ::= ( _( @$... ) ::=  @__PRAGMA_FINALIZE__( @\), {, {+, {-, {* ) @@


### Примеры использования макросов

```bash
    # Обычные макросы (тело макроса корректное выражение)
    @@macro@@        := replace();
    @@macro2(arg)@@  := { call(@$arg); call()};

    # Тело макросов из последовательности лексем
    @@if(...)@@    := @@ [ \$if(*) ]--> @@; # Выражение может быть не полным
    @@elif(...)@@  := @@ ,[ \$elif(*) ]--> @@;
    @@else@@       := @@ ,[_]--> @@;
 
    # Запись условного оператора с использованием 
    # определенных выше макросов
    if( condition ){
        ...
    } elif( condition2 ) {
        ...
    } else {
        ...
    };
```










Зачем нужна трансформация синтаксиса?
Нативная поддержка других языков нужна чтобы не переписывать легаси код на этих языках.

Чтобы можно было использовать существующие исходники как собственные требуется настройка работы 
препроцессора и лексера под конкретный язык программирования (описание DSL).
Для **С/С++** потребуется выделять лексером комментарии из-за пересечения синтаксиса (которые сейчас игнорируются).
Для **Python** требуется выделять лексером отступы (которые сейчас тоже игнорируются), причем потребуется реализация не только синтаксиса, 
но и зависимых пакетов с последующая трансляцией этого кода в С++, что в настоящий момент делать не целесообразно (cython ???).

Но так как возможность трансформации кода с других языков программирования принципиальная возможна, 
стоит над этим думать только после полноценного релиза NewLang и его перехода в прод.



Для реализации DSL требуется передача команд в парсер для управления его работой (по аналогии с командой #pragma)
Но так как обработка таких команд должна происходить в лексере до передачи данных в парсер (анализатор),
то команды для макропроцессора должны быть в максимально простом виде и состоять из элементов, 
которые лексер может самостоятельно идентифицировать, т.е. термины, строки и цифры (без выражений и именованных аргументов).

После обработки такой команды она анализируется макропроцессором и удаляется из потока лексем, т.е. в парсер (анализатор) не передается. 
Но в случае ошибки с синтаксисе, данные команды нужно уметь однозначно идентифировать и самый простой способ, 
комбинация признака макроса и системного имени, т.е. что-то вроде 
```
    @__PRAGMA_DIAG__(push)
    @__PRAGMA_DIAG__(ignored, "-Wundef")
    @__PRAGMA_DIAG__(warning, "-Wformat")
    @__PRAGMA_DIAG__(error "-Wuninitialized")
    @__PRAGMA_DIAG__(pop)

    #pragma message "Compiling " __FILE__ "..."
    @__PRAGMA_MESSAGE__("Compiling ", __FILE__, "...")

    #pragma error "Error " __FILE__ "..."
    @__PRAGMA_ERROR__("Error ", __FILE__, "...")


#define DO_PRAGMA(x) _Pragma (#x)
#define TODO(x) DO_PRAGMA(message ("TODO - " #x))

@@TODO( ... )@@ := @__PRAGMA_MESSAGE__("TODO - ", @*)

@TODO(Remember to fix this)  # note: TODO - Remember to fix this

\\.__lexer__ignore_space__ = 1;
\\.__lexer__ignore_indent__ = 1;
\\.__lexer__ignore_comment__ = 1;
\\.__lexer__ignore_crlf__ = 1;


```


Таким образом можно трансформировать условный оператор на питоне в синтаксис NewLang следующим макросом:
```

#pragma clang attribute push
#pragma clang diagnostic ignored "-Wundef"
#pragma clang diagnostic ignored "-Wunused-variable"


#elif __GNUC__

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"

#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wextra"
    
    @pragma warning(pop)

    @@ pragma warning(...) @@ := __PRAGMA_TERM_DIAG_WARNING__();
@__PRAGMA_DIAG__(warning, pop);

Обработка терминов в макропроцессоре в максимально простом виде. 
Агрументы только термины, строки и цифры без вложенных выражений и именованных аргументов, 
т.е. только элементы, которые может самостоятельно идентифицировать лексер.

@warning("--")
    @@ if ... : @@ := @@ [ @$* ]-> __TERM_BLOCK_INDENT__("{", force_semicolon=1) @@
    
    if __name__ == "__main__":
        run1()
        run2()

    [ __name__ == "__main__" ]-> {
        run1();
        run2();
    };
    
        

```








Ключ --parser-syntax-only только текстовый парсинг исходного кода без загрузки модулей, раскрытия макросов и проверки имен.

Ключ --parser-no-macros - без раскрытия макросов 
Ключ --parser-no-module - без загрузки модулей (и мокросов, если они в них определяются)
Ключ --parser-no-check-prototype - без проверки имен при обращении

prototype
@__PRAGMA_PROTOTYPE__(define)
@__PRAGMA_PROTOTYPE__(implement)

$$

\\$ - корень системы (система)

\$ - текущий модуль

# Макросы для конвертора проверки в Python
# if __name__ == "__main__": 

@@ __name__ @@ ::= @@   \$. @__PRAGMA_NO_MACRO__() __name__ @@
@@ if $... @\: @@ ::= @@ [ @$... ] -->  @@

@if( \$.__name__ == "__main__" ) {


}

\\каталог\модуль() - статический импорт модуля
\\("каталог\модуль")() - динамический импорт модуля


printf := :Pointer('printf(format:FmtChar, ...):Int32');
printf := %printf(format:FmtChar, ...):Int32;


# Регистрация прототипа нативной функции
@prototype
%puts(format:StrChar):Int32;

# Импорт нативной функции с предварительной проверкой её наличия во время компиляции (статическая линковка)
puts2(format:StrChar):Int32 := %puts(format:StrChar):Int32;
# Импорт нативной функции по её прототипу во время выполнения (динамическая линковка)
puts3(format:StrChar):Int32 := :Pointer('puts(format:StrChar):Int32');

%puts('Тест вывода строки'); # Линковка с нативной функцией во время компиляции и непосредственный вызов с оптимизацией передачи параметров
puts2('Тест 2 вывода строки'); # Линковка с нативной функцией во время компиляции
puts3('Тест 3 вывода строки'); # Линковка с нативной функцией во время выполнения при первом вызове puts3



- Парсинг исходного текста без раскрытия макросов и загрузки модулей
- Парсинг исходного текста с раскрытием макросов (требуется загрузка модулей для зависимых и переопределяемых макросов)
- Загружатся модули могут как в виде исходников (которые требуется парсить и компилировть/выполнять) 
или в виде бинарников (в них должны быть список макросов, типов и имена объектов)
- После парсинга получается список **имен** макросов, типов и объектов (TermPtr)
- После выполнения модуля - список **имен** заполняется реальными объектами (ObjPtr).


# Компиляция файла
- Парсинг исходника для построения AST (без анализа имен, связей, загрузки модулей и пр. только исходые тексты с раскрытием макросов
- 


# Систематизация реализации макросов

последовательность лексем MACRO_SEQ мужду @@  @@ сохраняется в m_block, так как фрагменты блоков не могут быть идентификаторами

Разбор макросов происходит в лексере. Определением макроса всегда является целая строка, 
которая заканчивается точкой с запятой, а идентификатором макроса всегда выступает последовательность лексем:
```bash
    @@ id @@ := macro;
    @@ id @@ := @@ @@;
    @@ id @@ := @@@ @@@;
```
Хранилищем текущих максросов является объект класса MacroBuffer. 
Последовательность лексем идентификатора (id) макроса должна сохраняется в отдельном поле термина и однозначно его идентифицирует.
Первый термин в идентификаторе хранится как ключ hashmap, а дальше происходит поиск полным перебором.
Этапы работы с макросами

- Входные термины из лексера получаются вызовом GetNextToken, внутри которой и происходит раскрытие макросов.
Внутренний буфер заполняется до окончания строки (выражения), т.е. до символа ';' или <END>, после чего производится 
поиск макросов в объекте MacroBuffer для текущей последовательности лексем в буфере.

- Если макрос найден, то соответствющая ему последоваетльность заменяется на тело макроса и происходит переход 
на повторный анализ входного буфера.

- Если макрос не найден, то данные передаются в парсер для дальнейшего синтаксическго анализа.

- Для этого во входном потоке лексем (parser.y) во время оператората создания/присвоения вызывается функция проверки на макрос.
MacroBuffer::CheckMacroAndConvertDel($$), и после этого выходному значению присваивается результат выполнения driver.MacroEval($$),
и в дальнейшем этот макрос никак не обработывается.

- Создание макросов, проверка на дубликаты и логические ошибки в определении происходит путем обращения к методам объекта MacroBuffer.






    /*
     * Макросы хрянтся как фрагменты AST в виде объектов типа Term,
     * так как создаются после обработки парсером по правилам стандратной грамматики.
     * 
     * Но анализ входных данных на предмет раскрытия макросов проиходит из потока (последовательности) лексем,
     * т.е. **ДО** обработки парсером, так как при раскрытии макросов может меняться грамматика выражений.
     * 
     * Функция \ref CompareMacro сравнивает входной буфер (последовательность лексем)
     * на предмет возможного соответствия одному конкретному макросу.
     * Сравниваются только ключевые словам без учета аргументов в скобках, 
     * но само наличие аргументов проверяется ??????????????????
     * 
     * Проблема:
     * К функции можно обратится с целью её вызова (указав после имени скобки), 
     * так и по имени без скобок (например для получения ссылки на объект).
     * Так и к переменной можно обратиться только по имени, 
     * так и указав скобки после имени как к функции (при копировании объекта).
     * 
     * Сделать один макрос под оба сценария (со скобками и без скобок) не получится, так как непонятно, 
     * что делать с аргументами при раскрытии тела макроса, когда они не указаны.
     * 
     * Но может быть следует переименовывать только одно имя без учета скобок,
     * например, оставив такую возможность только для одиночных макросов.
     * 
     * \name -> name или name (...), hash: name
     * но \name(...) -> name(...), а name - ошибка !!!!  hash: name
     * 
     * Или все же следует различать макросы со скобками и без скобок как два разных объекта???
     * \name := name2;  и \name(...) := name2(...); будут разными объектами
     * 
     * Или добавить макросы-алиасы без аргументов только для переименования отдельных терминов?
     * \alias :- name2; но как их отличать от обычных макросов в операции удаления?
     * Или вообще не нужно отличать и оставить только один варинат (либо макрос, либо алиас)
     * Тода вопрос со скобками закрывается сам собой, алиасы всегда без скобок,
     * макросы со скбками или без скобок, но должно быть полное соответствие.
     * 
     * @ name name2 @ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * @ name name2(...) @ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * @ name name2[...](...) @ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * @ name $tmpl[...](...) name3@ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Но!
     * @ name name2 @ ::-  -> name name2 - ок, но name name2(...) - ок
     * @ name $tmpl name3@ ::- -> name $tmpl[...](...) name3 - ок, name $tmpl(...) name3[...] - ок
     * 
     * 
     * 
     * Для последовательности лексем требуется полное соответствие с учетом скобок ???
     * и может ли быть несколько скобок одного типа (несколько крыглях, или несколько квардратных????
     * <Может быть несколько скобок одного типа, например, при указании типа у аргументов или типа возвращаемого значения.>
     * 
     * @ name name2 @ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * @ name name2(...) @ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * @ name name2[...](...) @ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * @ name $tmpl[...](...) name3@ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Проблема скобок возникает из-за сценария замены одного термина на другой, 
     * который есть в препроцессоре С/С++, но отсутствует при реализации с использованием шаблонов.
     * 
     *      
     */






Макросы используются и для превращеня исходного кода *NewLang* в более привычный синтаксис на основе [ключевых слов](https://newlang.net/syntax_dsl.html), так как такой тест гораздо легче воспринимается при последующем чтении исходного кода.


[Например:](https://newlang.net/syntax_dsl.html).
```
    @@if(...)@@    ::= @@ [ \$* ]--> @@;
    @@while(...)@@ ::= @@ [\$*] <-> @@;
    @@return $arg@@::=  @@ -- \$arg -- @@;
    @@true@@ ::= 1;
```

Тогда цикл до 5:
```
count:=1;
[ 1 ] <-> {
    [count>5] --> {
        -- 42 --;
    };
    count+=1;
};
```

будет выглядеть более привычно
```
count:=1;
while( true ) {
    if(count>5) {
        return 42;
    };
    count+=1;
};
```




## Идеи на будущее
### Символьное программирование

> Символьное программирование, часто называемое декларативным программированием, представляет собой парадигму программирования, которая использует математическую логику, отношения и символы для представления знаний и помощи в решении проблем. Вместо того, чтобы сосредотачиваться на описании последовательности операций, необходимых для выполнения вычислений, как в императивном программировании, символическое программирование делает упор на выражении отношений и ограничений между структурами данных, уделяя особое внимание «что», а не «как».
>
> В контексте парадигм программирования символическое программирование часто противопоставляется процедурному или императивному программированию, где программы определяют пошаговые процедуры для достижения своих целей. В то время как императивное программирование фокусируется на описании потока управления с использованием таких конструкций, как циклы и условные выражения, для управления выполнением, символическое программирование сосредоточено на выражении фактов о проблеме и позволяет выполнению естественным образом выводить последующие последствия из предоставленной информации.
>
> Одним из основных преимуществ символьного программирования является его способность обеспечивать более высокий уровень абстракции, что упрощает анализ кода и снижает вероятность ошибок. Непосредственно выражая отношения и ограничения, символическое программирование позволяет разработчикам сосредоточиться на моделировании и спецификации проблем, позволяя базовой системе управлять реализацией и выполнением алгоритмов.
>
> Существует несколько языков программирования и сред, использующих парадигму символьного программирования, например Prolog, Lisp и Haskell. Например, Пролог — это язык логического программирования, который позволяет разработчикам выражать взаимосвязи и факты о проблемных областях, в то время как выполнение автоматически обосновывает и извлекает новые факты на основе исходной информации. В том же духе Лисп, функциональный язык программирования, использует символьные вычисления для манипулирования структурами данных и выполнения сложных операций над ними, используя краткий и математически обоснованный синтаксис. Haskell, еще один функциональный язык программирования, использует строгую типизацию и ленивые вычисления, чтобы обеспечить символическое рассуждение и облегчить эффективное создание программ.
>
> Символьное программирование может быть полезным в широком спектре проблемных областей, включая искусственный интеллект, экспертные системы, программирование логики ограничений и символьную математику, среди других. Более высокий уровень абстракции, обеспечиваемый декларативными языками программирования, облегчает разработку сложных систем, сводя к минимуму вероятность ошибки и улучшая удобство обслуживания. В частности, использование символьного программирования в искусственном интеллекте позволяет разработчикам создавать системы представления знаний и механизмы рассуждения, которые можно применять для обработки естественного языка, машинного обучения и автоматического доказательства теорем.


Различие между символьным программированием и препроцессором
- Задача препроцессора - раскрыть(расширить) макрос, тогда как при символьном программировании нужно сокращать (сворачивать) выражения
- Препроцессор обрабатывает последовательности лексем (плоские данные), тогда как символьное программирование оперирует выражениями (деревом лексем)
- Макрос у препроцессора идентифицируется первым термином, и если макрос не может быть раскрыт, то возникает ошибка. В символьном программировани требуется точное соответствие всего выражения и только в этом случае производится сокращение выражения.

Предпосылки для реализации символьного программирования
Компилятор - интерепретатор с REPL и обработка AST как во время компиляции, так и во время выполнения.
Необходимо добавить конструкции для определения правил символьного программрования (чистые функции?)
Необходимо добавить конструкцию для вычисления выражений в символьном программировании.


Wolfram
https://habr.com/ru/articles/772984/
```
diffRules = {
  Sin[x] -> Cos[x], 
  Cos[x] -> -Sin[x], 
  x^2 -> 2*x, 
  x -> 1, 
  Log[x] -> 1/x
}; 
```

```
diffRules := (
  Sin(x) @-> Cos(x), 
  Cos(x) @-> -Sin(x), 
  x^2  @->  2*x,
  x @-> 1, 
  Log(x) @-> 1\x,
); 

expr @-> Sin(x) - x^2 + Log(x);  

# И применим к нему правила дифференцирования

#expr /. diffRules
#(* 1/x - 2 x + Cos[x] *)

sym := SymEval(expr, diffRules);
res := Eval(sym, x=0.123);

```




```
expr = a^2 + 3 * b^3 - c^4 + 2 * x^2 - x + 4*c + 3

И я хочу это выражение линеаризовать, т.е. отбросить все степени выше первой. Я могу сделать это напрямую, как в примерах выше:

expr /. {
  a^2 -> 0, 
  b^3 -> 0, 
  c^4 -> 0, 
  x^2 -> 0
}
(* 3 + 4 c - x *)

Но это слишком неудобно. Что если я не знаю ни точную степень, ни имя переменной? Как просто указать, что нужно заменить все места, где встречается возведение в степень на ноль? Это можно сделать при помощи шаблонов вот так:

expr /. Power[_, _] -> 0
(* 3 + 4 c - x *)

Либо вот так:

expr /. _ ^ _ -> 0
(* 3 + 4 c - x *)

```



```
:diffRules() := {
  {@ Sin(x) @} ::- {@ Cos(x) @};
  Cos(x) @-> -Sin(x), 
  x^2  @->  2*x,
  x @-> 1, 
  Log(x) @-> 1\x,
}; 

expr @-> Sin(x) - x^2 + Log(x);  

# И применим к нему правила дифференцирования

#expr /. diffRules
#(* 1/x - 2 x + Cos[x] *)

sym := SymEval(expr, diffRules);
res := Eval(sym, x=0.123);

```

