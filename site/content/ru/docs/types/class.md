---
title: Классы
# linkTitle: Docs
# menu: {main: {weight: 20}}
weight: 35
#categories: [типыExamples, Placeholders]
tags: [типы данных, ООП, коллекции]

---

Тип данных *:Class* аналогичен словарю, но все его поля обязаны иметь имена (хотя доступ к свойствам класса по индексу так же возможен).
При создании экземпляра класса, создается новая переменная, для которой копируются свойства и методы всех родителей. 

Создание нового сложного типа (класса), происходит согласно [правилам синтаксиса](/ru/docs/ops/create/) как создание функции
в пользовательском [пространстве имен](/ru/docs/syntax/namespace/). 
Имя функции является именем нового класса, а сама функция будет выступает в роли конструктора экземпляров класса.

Синтаксис создание класса выглядит следующим образом:
```python
# Новый тип (класс) :NewClass
ns::NewClass() := :Class() { # Родительские класс или несколько классов через запятую

    # Конструктор класса - весь блок кода с определением полей и методов

    @::static := 1; # Поле класса (у всех объектов одно значение)
    static := 1; # Поле класса (у всех объектов одно значение)
    .field := 1; # Поле объекта
    func() := {}; # Метод класса всегда статический
    #.method() := {}; # Метод объекта (у каждого объекта свой)

    ~NewClass() ::= { # Деструктор класса

    };
};
obj := ns::NewClass(); # Экземпляр класса
```

Так как *NewLang* реализует полный набор вариантов проверок при создании объектов, 
то переопределения наследуемых функций не требует никаких ключевых слов:
```python
NewClass2() := NewClass() { # Новый класс на базе существующего
    .field ::= 2;    # Будет ошибка, т.к. поле field уже есть в базовом классе
    method() = {};  # Аналог override, т.к. method должен существовать в базовом классе
};
```

## Интерфейсы, именование методов классов и пространства имен
Для создания уникальных идентификаторов на основе имен методов классов, *NewLang* использует подход, похожий на применяемый в языке Python. 
При создании метода класса, создается глобальная функция с именем класса и именем метода, объединенные через разделитель области имен. 
Например, в классе `NewClass2` при создании метода `method` будет создана функция с именем `::NewClass2::method`.

Такая схема наименований методов полностью соответствует именованию функций в пространствах имен, 
и тем самым позволяет определять классы c чистыми виртуальными функциями (методами без реализации), 
а в последствии определять их в пространстве имен или указав полное имя в явном виде.

```python
ns:: {
    NewClass3 := NewClass() { # Новый класс на базе существующего
        virtual() := _; # Виртуальный метод
    };
};

obj := ns::NewClass3(); # объект создать нельзя, будет ошибка

# Определить функцию для виртуального метода
ns::NewClass3::virtual() := {}; 

obj := ns::NewClass3(); # ОК
```

## Конструкторы, деструкторы и финализаторы у объектов
```python
ns::NewClass() :=  Class() {    # Новый класс на базе существующего

    # Блок кода функции - конструктор объекта

    __NewClass__() = {...}; # Метод с системным именем типа - деструктор объекта (вызывается сразу после удаления)

    _NewClass() := {...}; # Скрытый метод с именем типа - защищенный конструктор объекта ?????????????????
    __NewClass() := {...}; # Скрытый метод с именем типа - приватный конструктор объекта ?????????????????

    :NewClass(type) ::= {...}:NewClass; # Функция для приведения типа объекта $type к типу :NewClass
    ~NewClass() = {...}; # Скрытый метод - финализатор (вызывается перед освобождением памяти)

    __equals__(obj):Bool = { __compare__($obj) == 0 };
    __compare__(obj):Int8 =  { :: __compare__(@this, $obj) };


    _() := {...}; # ?????????????????????????????????????
    
};
```


