---
title: Преобразование типов
# linkTitle: Docs
# menu: {main: {weight: 20}}
weight: 100
tags: [типы данных]
---

Несмотря на динамическую типизацию языка, если тип переменной указан явно, то автоматическое приведение типов не выполняется, 
и чтобы присвоить переменой значение не совместимого типа, требуется его явное преобразование.

Так как символьные названия типов относятся к деталям реализации, то явное преобразование в конкретный тип данных производится 
с помощью вызова функции с именем типа, т.е. :Bool(), :StrWide(), :Int64() и т.д.

Примеры:

## Строки и тензоры
```
# Создать тензор из строки широких символов с автоматическим выводом типа
#(тип Int32 будет на системах с Linux, а под Windows тип тензора будет Int16)
> tstr := :Tensor("Тест"); 
[1058, 1077, 1089, 1090,]:Int32

# Тоже самое, но тензор заданной размерности
> t2 := :Tensor[2,2]("Тест");
[
  [1058, 1077,], [1089, 1090,],
]:Int32

# Создать символьную строку из тензора
> :StrWide(tstr) 
Тест

# Изменить тип данных тензора без изменения размерности
> :Float64(t2) 
[
  [1058, 1077,], [1089, 1090,],
]:Float64

# Изменить размерность тензора и его тип 
# (в данном случае с частичной потерей данных)
> t3 := :Int8[4]( t2 ) 
[34, 53, 65, 66,]:Int8
```

## Словари
```
# Создать тензор из словаря
>:Tensor( (1,2,3,) ); 
[1, 2, 3,]:Int8

# Преобразовать байтовую строку в тензор
>:Tensor( 'first second' ) 
[102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Int8

# Получаем тензор из словаря с такими же данными
>:Tensor( ('first', space=32, second='second',) ) 
[102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Int8
```

## Дополнение данными
```
# Тензор заданного формата с нулями,
# где многоточие повторяет последнее значение до требуемого размера
>:Float64[10,2]( 0, ...) 
[
  [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,],
]:Float64

# Тензор со случайными данными, где между многоточиями указана функция,
# которую следует вызывать каждый раз при получении нового элемента тензора
#
# Тут пришлось придумывать новую синтаксическую конструкцию 
# для вызова функции для каждого нового элемента, т.к. многоточие 
# перед идентификатором, это оператор раскрытия словаря, 
# а многоточие после идентификатора, это повторение последнего 
# значения до конца заданной размерности.
>:Int32[3,2]( ... rand() ...) 
[
  [1804289383, 846930886,], [1681692777, 1714636915,], [1957747793, 424238335,],
]:Int32

# Создание тензора из диапазона
>:Int32[5,2]( 0..10 ); 
[
  [0, 1,], [2, 3,], [4, 5,], [6, 7,], [8, 9,],
]:Int32

# Или даже так
>:Tensor( 0..0.99..0.1 ); 
[0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9,]:Float64
```

