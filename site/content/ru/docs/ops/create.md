---
title: Создание объектов
# description: Виды перемнных и правила их наименования
weight: 10
---

{{% pageinfo %}}
##### Область видимости объекта =/= время жизни объекта
Область видимости объекта определяется его расположением в программном коде (блоки кода, пространство имен, модели и т.д.)
Объект может существовать, но может быть не доступен из текущей области видимости.

#####  Имя объекта, создание объекта и его расположение
Имя объекта - его уникальный идентификатор, который однозначно определяется местом его расположения (нахождение сильной ссылки на объект).
Имя у объекта может быть всегда, даже тогда, когда сам объект физически еще не создан (например при предварительном объявлении).
{{% /pageinfo %}}

### Создания объектов и присвоения новых значений

Для создания объектов и присвоения им новых значений в NewLang используется несколько операторов:
- "**::=**" или "**::-**" - используется для создания только новых объектов.
                        Если объект с таким именем был определен ранее, то произойдет ошибка компиляции.
- "**:=**" или "**:-**" - используется для создания новых объектов с возможностью перекрытия имен.
                        Если локальный объект с таким именем был определен ранее, то новый объект будет его перекрывать.
- "**=**" - применяется только для присвоения значения уже существующим объектам. 
                        Если объект с указанным именем отсутствует, то возникает ошибка компиляции.
- "**:=:**" - Оператор не создает нового объекта, а обменивает значения уже существуюих (переменные должны иметь одинаковые/совместимые типы данных).

?????????????????????????????????????
- "**[]=**" - добавлеят новый элемент к словарю или переопределяет созданное ранее имя [функции](/ru/docs/types/funcs/) или [метод класса](/ru/docs/types/class/).
    Похож на оператор присвоения значения "**=**", но в отличии от него не *удаляет* старое значение, а сохраняет его в стек переопределнных имен,
    и к старому значению можно обратиться по системному имени "**$$**" ????????????????? [*)](). Не может применяться к макросам.

Использование трех разных видов операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе. 

Например, при определении класса `:NewClass2`:
```bash
    :NewClass := :Class() { # Базовый класс
        filed ::= 2; # Однократная инициализация (статическоого) члена класса
        method() ::= {}; # Регистрация метода
    };
    :NewClass2 := :NewClass() {
        filed ::= 2; # Будет ошибка, т.к. field уже есть в базовом классе
        method() = {}; # Аналог override, т.к. method должен существовать в базовом классе
    };
```

Если же контролировать момент создание объектов и присвоения им значений не требуется, то можно пользоваться единственным оператором **:=**.

```python
    var := 1.0; # Создать новую переменную var без явного указания типа
    var := 100; # Присвоить новое значение уже существующей переменной
    printf(format:FmtChar, ...):Int32 ::= %printf...; 
# Создать новый или переопределить printf ???????????????????????????????????????????
```

### Присваивание значения сразу нескольким переменным и оператор распаковки словаря
*NewLang* поддерживает операцию присваивания значения сразу нескольким переменным, 
которые должны быть перечислены через запятую слева от оператора присвоения. 
С правой стороны от оператора присвоения может находится только одно значение.
А для обмена занчениями двух переменных, вместо традиционной записи:
```python
    a,b = b,a;
```
Нужно использовать отдельный оператор обмена:
```python
    a :=: b;
```

В качестве правого операнда в операторе присвоения допускается использовать оператор распаковки словаря **...** (многоточие),
который можно использовать и при передаче аргументов в функцию. 

```python
    args := (arg1=1, arg2=2, 3,4,);
    call(arg=0, ... args);

    # Что равносильно вызову
    call(arg=0, arg1=1, arg2=2, 3, 4);
```

Словарь может быть указан и с левой стороны от оператора присвоения. 
Таким образом можно записать самый простой способ перебора всех его элементов: 
`item, dictionary := ... dictionary;`, т.е. когда первый элемент словаря сохраняется в переменную `item`, а из самого словаря удаляется,
и так в цикле пока словарь не станет пустым.

Пример реализации цикла *foreach* для суммирования всех элементов словаря (или одномерного тензора) 
с использованием оператора раскрытия словаря (списка):
```python
    summa := 0;
    dictionary := (1,2,3,4,5,);
    @while( dictionary ) {
        # Первый элемент словаря перемещается в item
        item, dictionary := ... dictionary; 
        summa += item;
    };
```

