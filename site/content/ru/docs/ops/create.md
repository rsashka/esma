---
title: Создание объектов
# description: Виды перемнных и правила их наименования
weight: 10
---

{{% pageinfo %}}
##### Область видимости объекта != время жизни объекта
*Имя* у объекта есть всегда, даже тогда, когда сам объект физически еще не создан (например при предварительном объявлении).
Область видимости объекта определяется его расположением в программном коде (блок кода, пространство имен, модуль и т.д.)
Объект может существовать, но быть не доступен из текущей области видимости, например, перекрыт другим объектом с таким же именем.

Время жизни автоматического (временного) объекта ограничено видимостью текущего блока кода,
время жизни статического объекта ограничено временм жизни модуля, в котором он определен,
но инициализация статического объекта выполняется в соответствии с выполняемым программным кодом.
{{% /pageinfo %}}

### Создания объектов и присвоения новых значений

Для создания объектов и присвоения им новых значений в NewLang используется несколько операторов:
- "**::=**" или "**::-**" - используется для создания только новых объектов.
                        Если объект с таким именем был определен ранее, то происходит ошибка компиляции.
- "**:=**" или "**:-**" - используется для создания новых объектов с возможностью перекрытия имен.
                        Если объект с таким именем был определен ранее, то новый объект будет его перекрывать,
                        но нельзя создать два объекта с одинаковым именем в одной области видимости.  
- "**=**" - применяется только для присвоения значения уже существующим объектам. 
                        Если объект с указанным именем отсутствует, то возникает ошибка компиляции.

?????????????????????????????????????

- "**:=:**" - Оператор не создает нового объекта, а обменивает значения уже существующих (переменные должны иметь одинаковые/совместимые типы данных).
- "**[]=**" - добавляет новый элемент к словарю, переопределяет созданное ранее имя [функции](/ru/docs/types/funcs/) или [метод класса](/ru/docs/types/class/).
    Похож на оператор присвоения значения "**=**", но в отличии от него не *удаляет* старое значение, 
    а заменяет его создавая стек переопределенных имен (своего рода таблицу вирутальных имен),
    и к старому (предыдущему) значению можно обратиться по системному имени "**$$**" ????????????????? [*)](). Не может применяться к макросам.

Использование трех разных видов операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе. 

Например, при определении класса `:NewClass2`:
```bash
    :NewClass := :Class() { # Базовый класс
        filed ::= 2; # Однократная инициализация (статическоого) члена класса
        method() ::= {}; # Регистрация метода
    };
    :NewClass2 := :NewClass() {
        filed ::= 2; # Будет ошибка, т.к. field уже есть в базовом классе
        method() = {}; # Аналог override, т.к. method должен существовать в базовом классе
    };
```

```python
    $var := 99; # Создать переменную var
    {
        $var := 100; # Новая переменная перекрывает var более высокого уровня
        print('%d', $var)  # > 100
    }
    print('%d', $var)  # > 99
```

### Присваивание значения сразу нескольким переменным и оператор распаковки словаря {#expand}
*NewLang* поддерживает операцию присваивания значения сразу нескольким переменным, 
которые должны быть перечислены через запятую слева от оператора присвоения. 
С правой стороны от оператора присвоения может находится только одно значение.

????????????????????????????????????????????????????????????????????
А для обмена занчениями двух переменных, вместо традиционной записи:
```python
    a,b = b,a;
```
Нужно использовать отдельный оператор обмена:
```python
    a :=: b;
```

В качестве правого операнда в операторе присвоения допускается использовать оператор распаковки словаря **...** (многоточие),
который можно использовать и при передаче аргументов в функцию. 

```python
    args := (arg1=1, arg2=2, 3, 4,);
    call(arg=0, ... args);

    # Что равносильно вызову
    call(arg=0, arg1=1, arg2=2, 3, 4);
```

Словарь может быть указан и с левой стороны от оператора присвоения. 
Таким образом можно записать самый простой способ перебора всех его элементов: 
`item, dictionary := ... dictionary;`, т.е. когда первый элемент словаря сохраняется в переменную `item`, а из самого словаря удаляется,
и так в цикле до тех пор, пока словарь не станет пустым.

Пример реализации цикла *foreach* для суммирования всех элементов словаря (или одномерного тензора) 
с использованием оператора раскрытия словаря (списка):
```python
    summa := 0;
    dictionary := (1,2,3,4,5,);
    @while( dictionary ) {
        # Первый элемент словаря перемещается в item
        item, dictionary := ... dictionary; 
        summa += item;
    };
```

## Заполнение размерных тензороов {#comprehensions}

При заполнении данными *размерных* тензоров существует краткий способ указания их начальных значений.
Для этого используется многоточие в следующих вариантах:
- `:Tensor[10](2,3, ...)` - повторение ***всех*** предыдущих данных до полного заполнения тензора, 
что равносильно записи `:Tensor[10](2,3,  2,3,  2,3,  2,3,  2,3)`.

- `:Tensor[10](2, 3, ... 42 ...)` - заполнение значением `42` до конца тензора, 
что равносильно записи `:Tensor[10](2,3, 42,42,42,42,42,42,42,42)`.

- `:Tensor[10](2, 3, ... rand() ...)` - заполнение до конца тензора значением, которое будет возвращать функция.
Указанная функция будет вызываться для **каждого элемента** до полного заполнения тензора (8 раз).

- `:Tensor[10]( rand(), rand(), ...)` - заполнение тензора *двумя* произвольными заначениями,
то есть функция `rand()` будет вызвана дважды только для *двух первых элементов*,
после чего эти значения будут использоваться до полного заполнения тензора (как в первом примере).

- `:Tensor[10]( ... 0..0.99..0.1 )` - заполнение тензора элементами диапазона, что равносильно записи   
`:Tensor[10](0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)`. Раскрытие диапазона создает 
фиксированное количество значений. Поэтому в данном примере размерность тензора можно не указывать,
так как она будет создана автоматически.

- `:Tensor[15]( ... 0..5  ,  ... )` - заполнение тензора элементами диапазона с их повторением до заданного размера тензора:
`:Tensor(0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4)`

### Заполнение данными в словарях и аргументах функций
Предыдущие способы заполнения данными возможны только для тензоров *фиксированного размера*, 
так как позволяют получить произвольное количество значений, 
но их можно применять только в конце списка значения для инициализации.

Операторы раскрытия словаря или диапазона создают *ограниченное* количество значений,
но за счет этого их можно использовать не только для инициализации тензоров,
но и в качестве начальных значений у словарей или аргументов при вызове функций,
причем в произвольном месте, а не только в конце списка инициализации:

- `:Tensor( ... 0..0.99..0.1 )` - заполнение тензора без указания его размера элементами диапазона,
что равносильно записи  `:Tensor(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)`

- `funtcion( 0, ... dict, 42 )` - раскрытие словаря как индивидуальных *не именованных* аргументов функции,
к примеру funtcion( 0, 1, 2, 3, 42), если словарь `dict` содержал три элемента `1`, `2` и `3`.

- `funtcion( ...  ... dict, end=4)` - раскрытие словаря как индивидуальных **именованных** аргументов функции.
Если словарь *dict* будет содержать элементы `(1, two=2, three=3,)`, 
то это будет равносильно вызову функции `funtcion( 1, two=2, three=3, end=4)`.


