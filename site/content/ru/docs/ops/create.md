---
title: Создание объектов
# description: Виды перемнных и правила их наименования
weight: 10
---

{{% pageinfo %}}
##### Область видимости объекта != время жизни объекта {#important}
У объекта *имя* есть всегда, даже тогда, когда сам объект физически еще не создан.
Область видимости объекта определяется его расположением в программном коде (блок кода, пространство имен, модуль и т.д.).
Объект может существовать, но быть не доступен из текущей области видимости, например, перекрыт другим объектом с таким же именем.

Время жизни локального/автоматического (временного) объекта ограничено областью видимости текущего блока кода,
время жизни статического объекта ограничено временем жизни модуля, в котором он определен,
однако *инициализация начального занчения статического объекта* происходит в соответствии с выполняемым программным кодом,
(т.е. при выполнении кода с оператором создания статического объекта).

Локальные переменные модуля (которые определены на самом верхнем уровне файла модуля), 
являются статическими переменными, индивидуальными для каждого потока, т.е. аналогом *thread_local* из C++11.
*Из-за этого для переменных на самом верхнем уровне файле нужно обязательно указаывать [квалификатор имени (сигил)](/ru/docs/syntax/naming/#sigil). 
Во всех остальных случаях, при указании [простого имени](/ru/docs/syntax/naming/#name-lookup) создается локальная переменная*.
{{% /pageinfo %}}

### Создания объектов и присвоения новых значений {#create}

Для создания объектов и присвоения им новых значений в NewLang используется несколько операторов:
- "**::=**" или "**::-**" - используется для создания только новых объектов.
                        Если объект с таким именем был определен ранее, то происходит ошибка *компиляции*.
- "**:=**" или "**:-**" - используется для создания новых объектов с возможностью перекрытия имен.
                        Если объект с таким именем был определен ранее, то новый объект будет его перекрывать,
                        хотя нельзя создать два объекта с одинаковым именем в одной области видимости ([блоке кода](/ru/docs/ops/block/)).  
- "**=**" - применяется только для присвоения значения уже существующим объектам. 
                        Если объект с указанным именем отсутствует, то возникает ошибка *компиляции*.

Использование трех разных видов операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе. 

---
**\*)** *- Если переопределяется созданная ранее [функция](/ru/docs/types/funcs/) или [метод класса](/ru/docs/types/class/),
то старое значение не *удаляется*, а создается стек переопределенных имен (своего рода таблицу вирутальных имен времени компиляции),
и к старому (предыдущему) значению можно обратиться  из новой функции по системному имени "**$$**".* 

*Например, при определении класса `:NewClass2`:*
```bash
    :NewClass := :Class() { # Базовый класс
        filed ::= 2; # Однократная инициализация (статическоого) члена класса
        method() ::= {}; # Регистрация метода
    };
    :NewClass2 := :NewClass() {
        filed ::= 2; # Будет ошибка, т.к. field уже есть в базовом классе
        method() = {}; # Аналог override, т.к. method должен существовать в базовом классе
    };
```

```python
    $var := 99; # Создать переменную var
    {
        $var := 100; # Новая переменная перекрывает var более высокого уровня
        print('%d', $var)  # > 100
    }
    print('%d', $var)  # > 99
```

#### Оператор обмена значениями {#swap}
- "**:=:**" - Оператор не создает нового объекта, а обменивает значения уже существующих. 
                Переменные должны иметь одинаковые/совместимые типы данных, либо тип **`:None`**, т.е. **"`_`"**.   
                Используется для реализации идиомы копирования и замены (copy-and-swap idiom), так как выполнении оператора не может быть ошибок. 

#### Оператор добавления элемента {#append}
- "**:[]=**" или - "**:[ 'name' ]=**" - добавляет новый элемент к словарю / тензору / строке, увеличивая их размер на единицу.
                Правый объект оператора должен быть совместим с типом единичного элемента левого объекта.
                С помощью второго оператора "**:[ 'name' ]=**" при добавлении элемента словаря можно дополнительно указать имя элемента.


### Присваивание значения сразу нескольким переменным и оператор распаковки словаря {#expand}
*NewLang* поддерживает операцию присваивания значения сразу нескольким переменным, 
которые должны быть перечислены через запятую слева от оператора присвоения. 

С правой стороны от оператора присвоения может находится только одно значение,
а для обмена занчениями двух переменных, вместо записи `a,b = b,a;` 
нужно использовать оператор [обмена](#swap):
```python
    a :=: b;
```

В качестве правого операнда в операторе присвоения допускается использовать оператор распаковки словаря **...** (многоточие),
который можно использовать и при передаче аргументов в функцию. 

```python
    args := (arg1=1, arg2=2, 3, 4,);
    call(arg=0, ... args);

    # Что равносильно вызову
    call(arg=0, arg1=1, arg2=2, 3, 4);
```

Словарь может быть указан и с левой стороны от оператора присвоения. 
Таким образом можно записать самый простой способ перебора всех его элементов: 
`item, dictionary := ... dictionary;`, т.е. когда первый элемент словаря сохраняется в переменную `item`, а из самого словаря удаляется,
и так в цикле до тех пор, пока словарь не станет пустым.

Пример реализации цикла *foreach* для суммирования всех элементов словаря (или одномерного тензора) 
с использованием оператора раскрытия словаря (списка):
```python
    summa := 0;
    dictionary := (1,2,3,4,5,);
    @while( dictionary ) {
        # Первый элемент словаря перемещается в item
        item, dictionary := ... dictionary; 
        summa += item;
    };
```

## Заполнение размерных тензороов {#comprehensions}

При заполнении данными *размерных* тензоров существует краткий способ указания их начальных значений.
Для этого используется многоточие в следующих вариантах:
- `:Tensor[10](2,3, ...)` - повторение ***всех*** предыдущих данных до полного заполнения тензора, 
что равносильно записи `:Tensor[10](2,3,  2,3,  2,3,  2,3,  2,3)`.

- `:Tensor[10](2, 3, ... 42 ...)` - заполнение значением `42` до конца тензора, 
что равносильно записи `:Tensor[10](2,3, 42,42,42,42,42,42,42,42)`.

- `:Tensor[10](2, 3, ... rand() ...)` - заполнение до конца тензора значением, которое будет возвращать функция.
Указанная функция будет вызываться для **каждого элемента** до полного заполнения тензора (8 раз).

- `:Tensor[10]( rand(), rand(), ...)` - заполнение тензора *двумя* произвольными заначениями,
то есть функция `rand()` будет вызвана дважды только для *двух первых элементов*,
после чего эти значения будут использоваться до полного заполнения тензора (как в первом примере).

- `:Tensor[10]( ... 0..0.99..0.1 )` - заполнение тензора элементами диапазона, что равносильно записи   
`:Tensor[10](0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)`. Раскрытие диапазона создает 
фиксированное количество значений. Поэтому в данном примере размерность тензора можно не указывать,
так как она будет создана автоматически.

- `:Tensor[15]( ... 0..5  ,  ... )` - заполнение тензора элементами диапазона с их повторением до заданного размера тензора:
`:Tensor(0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4)`

### Заполнение данными в словарях и аргументах функций
Предыдущие способы заполнения данными возможны только для тензоров *фиксированного размера*, 
так как позволяют получить произвольное количество значений, 
но их можно применять только в конце списка значения для инициализации.

Операторы раскрытия словаря или диапазона создают *ограниченное* количество значений,
но за счет этого их можно использовать не только для инициализации тензоров,
но и в качестве начальных значений у словарей или аргументов при вызове функций,
причем в произвольном месте, а не только в конце списка инициализации:

- `:Tensor( ... 0..0.99..0.1 )` - заполнение тензора без указания его размера элементами диапазона,
что равносильно записи  `:Tensor(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)`

- `funtcion( 0, ... dict, 42 )` - раскрытие словаря как индивидуальных *не именованных* аргументов функции,
к примеру funtcion( 0, 1, 2, 3, 42), если словарь `dict` содержал три элемента `1`, `2` и `3`.

- `funtcion( ...  ... dict, end=4)` - раскрытие словаря как индивидуальных *именованных* аргументов функции.
Если словарь *dict* будет содержать элементы `(1, two=2, three=3,)`, 
то это будет равносильно вызову функции `funtcion( 1, two=2, three=3, end=4)`.

- `funtcion( ...  ... dict, end=4)` - раскрытие словаря как индивидуальных *именованных* аргументов функции.
Если словарь *dict* будет содержать элементы `(1, two=2, three=3,)`, 
то это будет равносильно вызову функции `funtcion( 1, two=2, three=3, end=4)`.

- `funtcion( ...  :Tensor[5](... rand() ...) )` - раскрытие тензора с пятью случайными значениями в качестве аргументов при вызове функции.


