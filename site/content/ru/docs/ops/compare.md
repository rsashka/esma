---
title: Операторы сравнения и типизация
# description: Виды перемнных и правила их наименования
weight: 30
---

### Арифметическое сравнение
Операторы арифметического сравнения представленными классическими **<**, **>**, **<=**, **>=**, **==** и **!=**.
Они использются для сравнения между собой скаляров и рациональных чисел, а операторы сранвения на равенство **==** и **!=**,
позвоялют сравнивать между собой в том числе и матрицы.


### Операторы сравнения

- **==** и **!=** — операторы сравнения с автоматическим приведением совместимых типов для любых объектов

- **==** и **!=** — операторы сравнения с автоматическим приведением совместимых типов для любых объектов


- **===** и **!==** — операторы точного сравнения для любых объектов (автоматического приведения типов не выполняется).
Для объектов сравниваются адреса размещения 


### Статическая строгая типизация


Статическая номинальная проверка типа объектов во время любых операций производится автоматически 
во время компиляции исходного текста программы, если хотя бы у одной из переменных 
при опеределении был указан её тип в явном виде.

Результат статической номинальной проверки типов будет успешным, если тип правого объекта может быть автоматически преобразован 
к типу левого операнда или тип правого операнада присутствует у левого в иерархии наследования.

### Статическая (номинальная) типизация
Статическая номинальная проверка типа объектов во время любых операций производится автоматически 
во время компиляции исходного текста программы, если хотя бы у одной из переменных 
при опеределении был указан её тип в явном виде.

Результат статической номинальной проверки типов будет успешным, если тип правого объекта может быть автоматически преобразован 
к типу левого операнда или тип правого операнада присутствует у левого в иерархии наследования.


### Динамическая номинальная типизация
Для проверки имени типа (класса) объекта во время выполнения используется оператор тильда "**~**". 
Это таже номинальная проверка типов, но только во время выполнения приложения. 
Левым операндом должен быть проверяемый объект, а правым — тип с которым сравнивается левый оператор.

Правый оператор может быть строкой литералом, переменной строкового типа или именем проверяемого класса непосредственно. 
Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта 
или он присутствует у него в иерархии наследования.

```python
    name := "class"; # Строковая переменная с именем класса
    var ~ name; 
    var ~ :class; # Сравнение с типом
    var ~ "class"; # Имя типа как строка литерал
```

### Динамическая утиная типизация
Оператор утиной типизации, два символа тильды "**~~**".
Проверяемым типом является левый оператор, а правый выступает в роли облазца для сравнения.
Для простых типов сравнивается совместимость типа левого операнда по отношению к правому. 
А для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда, т.е.:

```python
    # Истина (т. е. левый операнд словарь)
    (field1="value", field2=2,) ~~ (); 

    # Тоже истина (т. к. поле field1 присутствует у левого операнда)
    (field1="value", field2=2,) ~~ (field1=_); 

    # Ложь, т.к. поле not_found у левого операнда отсутствует
    (field1="value", field2=2,) ~~ (not_found=_); 
```

### Строгая утиная типизация

Строгая утиная типизация "**~~~**" для простых типов сравнивается идентичности типов без учета совместимости, 
а для составных типов происходит сравнение всех свойств с помощью оператора строгого равенства. 

Для данной операции, пустой тип совместим только с другим пустим типом.





### Статическая номинальная типизация
Статическая номинальная проверка типа объектов во время любых операций производится автоматически 
во время компиляции исходного текста программы, если хотя бы у одной из переменных 
при опеределении был указан её тип в явном виде.

Результат статической номинальной проверки типов будет успешным, если тип правого объекта может быть автоматически преобразован 
к типу левого операнда или тип правого операнада присутствует у левого в иерархии наследования.


### Динамическая номинальная типизация
Для проверки имени типа (класса) объекта во время выполнения используется оператор тильда "**~**". 
Это таже номинальная проверка типов, но только во время выполнения приложения. 
Левым операндом должен быть проверяемый объект, а правым — тип с которым сравнивается левый оператор.

Правый оператор может быть строкой литералом, переменной строкового типа или именем проверяемого класса непосредственно. 
Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта 
или он присутствует у него в иерархии наследования.

```python
    name := "class"; # Строковая переменная с именем класса
    var ~ name; 
    var ~ :class; # Сравнение с типом
    var ~ "class"; # Имя типа как строка литерал
```

### Динамическая утиная типизация
Оператор утиной типизации, два символа тильды "**~~**".
Проверяемым типом является левый оператор, а правый выступает в роли облазца для сравнения.
Для простых типов сравнивается совместимость типа левого операнда по отношению к правому. 
А для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда, т.е.:

```python
    # Истина (т. е. левый операнд словарь)
    (field1="value", field2=2,) ~~ (); 

    # Тоже истина (т. к. поле field1 присутствует у левого операнда)
    (field1="value", field2=2,) ~~ (field1=_); 

    # Ложь, т.к. поле not_found у левого операнда отсутствует
    (field1="value", field2=2,) ~~ (not_found=_); 
```




```python
    func(arg:Int32) := {...};
    func(arg:~Int32) := {...};
    func(arg:~~Int32) := {...};
    func(arg:~~~Int32) := {...};

    func( & arg:Int32 ) := {...};
    func( &? arg:Int32 ) := {...};
    func( &* arg:Int32 ) := {...};
    func( && arg:Int32 ) := {...};

    func( & arg:Int32 = 0 ) := {...};
    func( &? arg:Int32 = 0 ) := {...};
    func( &* arg:Int32 = 0 ) := {...};
    func( && arg:Int32 = 0 ) := {...};

    func( & arg ) := {...};
    func( &? arg ) := {...};
    func( &* arg ) := {...};
    func( && arg ) := {...};

    func( & arg = 0 ) := {...};
    func( &? arg = 0 ) := {...};
    func( &* arg = 0 ) := {...};
    func( && arg = 0 ) := {...};

    func( & arg = term(0) ) := {...};
    func( &? arg = term(0) ) := {...};
    func( &* arg = term(0) ) := {...};
    func( && arg = term(0) ) := {...};

    func( & arg:Int32 = 0 ) := {...};
    func( &? arg:~Int32 = 0 ) := {...};
    func( &* arg:~~Int32 = 0 ) := {...};
    func( && arg:~~~Int32 = 0 ) := {...};

    func( & arg:Int32 = term(0) ) := {...};
    func( &? arg:~Int32 = term(0) ) := {...};
    func( &* arg:~~Int32 = term(0) ) := {...};
    func( && arg:~~~Int32 = term(0) ) := {...};

    func( arg = & val );
    func( arg = &? val  );
    func( arg = &* val );
    func( arg = && val );

    :RefInt32 := & :Int32;
    :RefInt32 := &? :Int32;
    :RefInt32 := &* :Int32;
    :RefInt32 := && :Int32;

    var:Int32 := 0;
    & var:Int32 := 0;
    &? var:Int32 := 0;
    && var:Int32 := 0;
    &* var:Int32 := 0;

    &?(var) var:Int32 := 0;
    &?(var, __timeout__=1000) var:Int32 := 0;
```

