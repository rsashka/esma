---
title: Архитектура
weight: 5
description: > 
    Описание реализация архитектуры для лучшего понимания отдельных важных моментов
simple_list: false
---

Ключем поиска объектов явялется строка с полным именем в иерархии имен относительно корня

## Система классов

RunTime - единственный класс для приложения (процесса) - интерфейс для взаимодействия с операционной системой
- Загружат и выгружает модули и является их владельцем (shared_ptr)
- Хранит глобальные объекты (ObjPtr) для глобальных объектов (встроенных типов и функций).
    Ключем явялется строка с полным именем объекта в иерархии имен относительно корня
- Хранит список **глобальных** объектов (типы данных и прототипы функций в TermPtr, которые создаются на этапе компиляции). 
    Используется парсером и компилятором для разбора исходного текста и создания исполняемого файла.

Module - класс для модуля
- Хранение объектов модуля (shared_ptr) и добавляет weak_ptr в глобальный список объектов в RunTime 

Context - класс для хранения временных данных при выполнении программы
- Один класс создается сразу при создании RunTime
- В дальнейшем создается по одному объекту для каждого нового потока (:Thread)
- Хранение списка объектов (weak_ptr<Obj>)
- Хранение локальных объектов (ObjPtr), которые создаются на этапе выполнения



Исходный текст -> Парсинг -> AST (TermPtr) -+->  Компиляция в модуль (LLVM) -> Выполнение модуля
                                            |
                                            +->  Интерпретация (Выполнение AST)



## Шаги сборки компилятора
- Сборка `nlc`
- Генерация с помощью `nlc --no-runtime  --no-dsl -emit-cpp` модуля *dsl*
- Сборка модуля *dsl*
- Генерация с помощью `nlc --no-runtime  -emit-cpp` пакета *runtime*
- Сборка пакета *runtime*

В результате имеем готовый **nlc** с модулями **runtime.nlm** и **dsl.nlm**, а заодно и проверяем:
- генерацию С++ кода без макросов
- сборку модуля
- загрузку модуля
- генерацию С++ кода с макросами
- сборку пакета
- загрузку пакета

Выполнение тестов с модулями **runtime.nlm** и **dsl.nlm**

## Опции компилятора
- \-no-dsl - не использовать автоматически загружаемый модуль **dsl**
- \-no-runtime - не использовать автоматически загружаемый модуль **runtime**
- \-emit-cpp - генерировать выходной **\*.cpp** файл
- \-module-always-inline - Всегда раскрывать исходный текст модуля?????


## Реализация загрузки модулей и пакетов

При загрузке пакета может потребоваться обработать сразу несколько файлов (\_\_init\_\_.nlp и непосредстенно сами файлы модулей, входящие в пакет).
Это кроме того, что в любом файле могут встречаться команды загрузки других модулей.
Еще хотелось бы иметь возможность поучить последовательность обработываемых терминов в виде одного единственного файла.
Это было бы полезно как при отладке, так и для упрощении логики работы в целом.

- Первый проход - раскрываем все модули и пакеты в одну последовательность токенов для обработки 
(это можно сохранить как один файл) - первая фаза препроцессора.


  * Загрузка модуля, например:
     * \runtime\os(args);
     * 
     * Раскрывается в описание класса??? __name__="os" или __name__="__main__" для приложения
     * :Module(args, __module__="\\\\runtime\\os", __file__="runtime\\os.nlp", __md5__="..." ... ) { @__PRAGMA_LOCATION__( push, 'runtime\\os.nlp', 0)
     * ..... текст модуля ..... начинается с 1 строки т.к. @__PRAGMA_LOCATION__( push устанавливает номер строки **0**
     * @__PRAGMA_LOCATION__( pop) };



