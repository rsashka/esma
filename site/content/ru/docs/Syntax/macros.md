---
title: Макросы
# description:  Правила синтаксиса языка
# date: 2017-01-05
weight: 40
---


Макросы в **NewLang**, это один или несколько последовательных терминов, которые заменяются на другой термин 
или на целую синтаксическую конструкцию (последовательность лексем). 

Макросы обработываются во время работы **лексера**, т.е. перед передачей лексем в парсер, 
что позволяет изменять даже сам синтаксис языка, например, при реализации собственных диалектов DSL.

### Определение макросов

Определение макросов аналогично определению других объектов и состоит из трех частей **<имя макроса> <оператор создания/присвоения> <тело макроса>** и завершающая точка с запятой **;**,
т.е. применяются операторы **::=**, **=** или **:=** для создания нового макроса, переопределения уже существующего макроса
или для создания/присвоения нового значения макросу не зависимо от его наличия или отсутствия.

Телом макроса могут быть корректное выражение языка, последовательность лексем (которые заключается в двойные собачки @@, 
т.е. `@@ лексема1 лексема1 @@`) или обычная текстовая строка (обрамленная в тройные @@@, т.е. `@@@ текстовая строка @@@`).

Именем макроса может быть одна или нескольких лексем (терминов), которые указываются между двумя символами @@.
В имени макроса кроме лексем (терминов) могут присутствовать один или несколько шаблонов.

*Шаблон* — это термин, который при сопоставлении последовательности лексем с идентификатором макроса 
может заменяться любым другим одиночным термином (т.е реализуется сопоставление по образцу/шаблону).

Для создания термина-шаблона в начале его идентификатора нужно поставить знак доллара (что соответствует записи имени локальной переменой), 
т.е. имени макроса `@@ func $name@@` будут соответствовать как `func my_func_name`, так и `func other_name_func`.

Для удаления макросов используется специальный синтаксис: `@@@@ name @@@@;` или `@@@@ два термина @@@@;`, 
т.е. необходимо указать идентификатор макроса между четырмя символами @.

```bash
    # Тело макроса из текстовой строки (как в препроцессоре С/С++)
    @@macro_str@@  := @@@ строка - тело макроса @@@; # Строка для лексера

    # Оператор удаления макроса
    @@@@ macro_str @@@@;
```

### Аргументы макросов и их раскрытие

Макросы можно определять как с аргументами (параметрами в скобках), так и без них. 
Если макрос был определен с аргументами, то их проверка будет выполнятся макропроцессором при определении и раскрытии макроса.
Если макрос был определен без аргументов, то их наличие макропроцессором игнорируется при раскрытии макроса.

Так как макропроцессор считает макросы с аргументами и без оных идентичными, то нельзя создать два макроса 
с одинаковыми именами, один из которых будет с аргументами (скобками), а другой без них.  

Поэтому, если требуется использовать макрос в двух разных вариантах (с аргументами и без них), 
тогда следует определять макрос без аргументов, тогда контроль его параметров будет производить компилятор.

```bash
    @@macro@@ := term; # Макрос без аргументов
    
    macro(args); # ОК -> term(args);
    macro; # ОК -> term;

    # Но 
    @@call()@@ := term(); 

    call(); # ОК -> term();
    call; # Ошибка (call определен с аргументами) 
```

Если при определении макроса указаны аргументы, то чтобы в теле макроса указать место для их вставки, 
их нужно записать как имя локальной переменой, но перед аргументом добавить символ @, т.е. **@$arg**.

Произвольное количество аргументов у макроса отмечается троеточием "...", а место для их вставки отмечается 
лексемой с указанием соотвутствующего имени, например, **@$name(\*)**, **@$name<\*>** или **@$name[\*]** в зависимости от типов использованных скобок, 
где **name**, это имя термина или шаблона, который имеет аргументы (т.е. после которого стоят скобки соответствующего вида).  

Для вставки количества реально переданных аргументов используется лексемы **@$name(#)**, **@$name<#>** 
или **@$name[#]** с указанием соответствующего идентификатора.

Для вставки произвольного количества терминов шаблона используется лексема @$* - в виде словаря ??????, 
Для вставки произвольного количества терминов шаблона используется лексема @$... - индивидуальным аргументом, 
а для вставки количества реально присутствующих терминов лексема @$#.




По аналогии с препроцессором С/С++ для соединения двух лексем в одну в теле макроса используется оператор **@##**, 
а для преобразование лексемы в текстову строку применяется операторы **@#**, **@#"** или **@#'**, например, 
`@@macro($arg)@@ := @@ func_ @## @$arg(@#arg) @;`, тогда вызов `macro(name);` будет преобразован в `func_name ("name");`


# Ограничения макропроцессора в текущей версии

На текущий момент макросы реализованы в минимальном объеме для самых простых сценариев использования:

- DSL для keyword based syntax (if, else, return, match, while  и т.д.) - (1 термин с произвольными аргументами и без) - требуется сейчас !!!

*Парсер при обработке макросов может анализировать информацию о типах данных, если она указана.* 
*Но на текущий момент типы данных в макросах никак не обрабатываются и это одна из обязательных фич, которая будет реализована в будущем.*

- Определения (func, class) - (несколько терминов с аргументами и без аргументов) - Реализация ООП и импорт С++ классов
- Модификации при определениях (override) - (несколько терминов и шаблоны с аргументами и без аргументов) - Реализация ООП и импорт С++ классов

# МАКРОСЫ БЕЗ АРГУМЕНТОВ ИЛИ ВСЕ АРГУМЕНТЫ СРАЗУ !!!!!
# анализа аргументов или их типов не производится !!!




Lambda
@@ lambda $name(...) @@ ::= @@  @$name( @$... ) ::= ( _( @$... ) ::=  @__PRAGMA_FINALIZE__( @\), {, {+, {-, {* ) @@


### Примеры использования макросов

```bash
    # Обычные макросы (тело макроса корректное выражение)
    @@macro@@        := replace();
    @@macro2(arg)@@  := { call(@$arg); call()};

    # Тело макросов из последовательности лексем
    @@if(...)@@    := @@ [ \$if(*) ]--> @@; # Выражение может быть не полным
    @@elif(...)@@  := @@ ,[ \$elif(*) ]--> @@;
    @@else@@       := @@ ,[_]--> @@;
 
    # Запись условного оператора с использованием 
    # определенных выше макросов
    if( condition ){
        ...
    } elif( condition2 ) {
        ...
    } else {
        ...
    };
```










Зачем нужна трансформация синтаксиса?
Нативная поддержка других языков нужна чтобы не переписывать легаси код на этих языках.

Чтобы можно было использовать существующие исходники как собственные требуется настройка работы 
препроцессора и лексера под конкретный язык программирования (описание DSL).
Для **С/С++** потребуется выделять лексером комментарии из-за пересечения синтаксиса (которые сейчас игнорируются).
Для **Python** требуется выделять лексером отступы (которые сейчас тоже игнорируются), причем потребуется реализация не только синтаксиса, 
но и зависимых пакетов с последующая трансляцией этого кода в С++, что в настоящий момент делать не целесообразно (cython ???).

Но так как возможность трансформации кода с других языков программирования принципиальная возможна, 
стоит над этим думать только после полноценного релиза NewLang и его перехода в прод.



Для реализации DSL требуется передача команд в парсер для управления его работой (по аналогии с командой #pragma)
Но так как обработка таких команд должна происходить в лексере до передачи данных в парсер (анализатор),
то команды для макропроцессора должны быть в максимально простом виде и состоять из элементов, 
которые лексер может самостоятельно идентифицировать, т.е. термины, строки и цифры (без выражений и именованных аргументов).

После обработки такой команды она анализируется макропроцессором и удаляется из потока лексем, т.е. в парсер (анализатор) не передается. 
Но в случае ошибки с синтаксисе, данные команды нужно уметь однозначно идентифировать и самый простой способ, 
комбинация признака макроса и системного имени, т.е. что-то вроде 
```
    @__PRAGMA_DIAG__(push)
    @__PRAGMA_DIAG__(ignored, "-Wundef")
    @__PRAGMA_DIAG__(warning, "-Wformat")
    @__PRAGMA_DIAG__(error "-Wuninitialized")
    @__PRAGMA_DIAG__(pop)

    #pragma message "Compiling " __FILE__ "..."
    @__PRAGMA_MESSAGE__("Compiling ", __FILE__, "...")

    #pragma error "Error " __FILE__ "..."
    @__PRAGMA_ERROR__("Error ", __FILE__, "...")


#define DO_PRAGMA(x) _Pragma (#x)
#define TODO(x) DO_PRAGMA(message ("TODO - " #x))

@@TODO( ... )@@ := @__PRAGMA_MESSAGE__("TODO - ", @*)

@TODO(Remember to fix this)  # note: TODO - Remember to fix this

\\.__lexer__ignore_space__ = 1;
\\.__lexer__ignore_indent__ = 1;
\\.__lexer__ignore_comment__ = 1;
\\.__lexer__ignore_crlf__ = 1;


```


Таким образом можно трансформировать условный оператор на питоне в синтаксис NewLang следующим макросом:
```

#pragma clang attribute push
#pragma clang diagnostic ignored "-Wundef"
#pragma clang diagnostic ignored "-Wunused-variable"


#elif __GNUC__

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"

#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wextra"
    
    @pragma warning(pop)

    @@ pragma warning(...) @@ := __PRAGMA_TERM_DIAG_WARNING__();
@__PRAGMA_DIAG__(warning, pop);

Обработка терминов в макропроцессоре в максимально простом виде. 
Агрументы только термины, строки и цифры без вложенных выражений и именованных аргументов, 
т.е. только элементы, которые может самостоятельно идентифицировать лексер.

@warning("--")
    @@ if ... : @@ := @@ [ @$* ]-> __TERM_BLOCK_INDENT__("{", force_semicolon=1) @@
    
    if __name__ == "__main__":
        run1()
        run2()

    [ __name__ == "__main__" ]-> {
        run1();
        run2();
    };
    
        

```








Ключ --parser-syntax-only только текстовый парсинг исходного кода без загрузки модулей, раскрытия макросов и проверки имен.

Ключ --parser-no-macros - без раскрытия макросов 
Ключ --parser-no-module - без загрузки модулей (и мокросов, если они в них определяются)
Ключ --parser-no-check-prototype - без проверки имен при обращении

prototype
@__PRAGMA_PROTOTYPE__(define)
@__PRAGMA_PROTOTYPE__(implement)

$$

\\$ - корень системы (система)

\$ - текущий модуль

# Макросы для конвертора проверки в Python
# if __name__ == "__main__": 

@@ __name__ @@ ::= @@   \$. @__PRAGMA_NO_MACRO__() __name__ @@
@@ if $... @\: @@ ::= @@ [ @$... ] -->  @@

@if( \$.__name__ == "__main__" ) {


}

\\каталог\модуль() - статический импорт модуля
\\("каталог\модуль")() - динамический импорт модуля


printf := :Pointer('printf(format:FmtChar, ...):Int32');
printf := %printf(format:FmtChar, ...):Int32;


# Регистрация прототипа нативной функции
@prototype
%puts(format:StrChar):Int32;

# Импорт нативной функции с предварительной проверкой её наличия во время компиляции (статическая линковка)
puts2(format:StrChar):Int32 := %puts(format:StrChar):Int32;
# Импорт нативной функции по её прототипу во время выполнения (динамическая линковка)
puts3(format:StrChar):Int32 := :Pointer('puts(format:StrChar):Int32');

%puts('Тест вывода строки'); # Линковка с нативной функцией во время компиляции и непосредственный вызов с оптимизацией передачи параметров
puts2('Тест 2 вывода строки'); # Линковка с нативной функцией во время компиляции
puts3('Тест 3 вывода строки'); # Линковка с нативной функцией во время выполнения при первом вызове puts3



- Парсинг исходного текста без раскрытия макросов и загрузки модулей
- Парсинг исходного текста с раскрытием макросов (требуется загрузка модулей для зависимых и переопределяемых макросов)
- Загружатся модули могут как в виде исходников (которые требуется парсить и компилировть/выполнять) 
или в виде бинарников (в них должны быть список макросов, типов и имена объектов)
- После парсинга получается список **имен** макросов, типов и объектов (TermPtr)
- После выполнения модуля - список **имен** заполняется реальными объектами (ObjPtr).


# Компиляция файла
- Парсинг исходника для построения AST (без анализа имен, связей, загрузки модулей и пр. только исходые тексты с раскрытием макросов
- 


# Систематизация реализации макросов

последовательность лексем MACRO_SEQ мужду @@  @@ сохраняется в m_block, так как фрагменты блоков не могут быть идентификаторами

Разбор макросов происходит в лексере. Определением макроса всегда является целая строка, 
которая заканчивается точкой с запятой, а идентификатором макроса всегда выступает последовательность лексем:
```bash
    @@ id @@ := macro;
    @@ id @@ := @@ @@;
    @@ id @@ := @@@ @@@;
```
Хранилищем текущих максросов является объект класса MacroBuffer. 
Последовательность лексем идентификатора (id) макроса должна сохраняется в отдельном поле термина и однозначно его идентифицирует.
Первый термин в идентификаторе хранится как ключ hashmap, а дальше происходит поиск полным перебором.
Этапы работы с макросами

- Входные термины из лексера получаются вызовом GetNextToken, внутри которой и происходит раскрытие макросов.
Внутренний буфер заполняется до окончания строки (выражения), т.е. до символа ';' или <END>, после чего производится 
поиск макросов в объекте MacroBuffer для текущей последовательности лексем в буфере.

- Если макрос найден, то соответствющая ему последоваетльность заменяется на тело макроса и происходит переход 
на повторный анализ входного буфера.

- Если макрос не найден, то данные передаются в парсер для дальнейшего синтаксическго анализа.

- Для этого во входном потоке лексем (parser.y) во время оператората создания/присвоения вызывается функция проверки на макрос.
MacroBuffer::CheckMacroAndConvertDel($$), и после этого выходному значению присваивается результат выполнения driver.MacroEval($$),
и в дальнейшем этот макрос никак не обработывается.

- Создание макросов, проверка на дубликаты и логические ошибки в определении происходит путем обращения к методам объекта MacroBuffer.






    /*
     * Макросы хрянтся как фрагменты AST в виде объектов типа Term,
     * так как создаются после обработки парсером по правилам стандратной грамматики.
     * 
     * Но анализ входных данных на предмет раскрытия макросов проиходит из потока (последовательности) лексем,
     * т.е. **ДО** обработки парсером, так как при раскрытии макросов может меняться грамматика выражений.
     * 
     * Функция \ref CompareMacro сравнивает входной буфер (последовательность лексем)
     * на предмет возможного соответствия одному конкретному макросу.
     * Сравниваются только ключевые словам без учета аргументов в скобках, 
     * но само наличие аргументов проверяется ??????????????????
     * 
     * Проблема:
     * К функции можно обратится с целью её вызова (указав после имени скобки), 
     * так и по имени без скобок (например для получения ссылки на объект).
     * Так и к переменной можно обратиться только по имени, 
     * так и указав скобки после имени как к функции (при копировании объекта).
     * 
     * Сделать один макрос под оба сценария (со скобками и без скобок) не получится, так как непонятно, 
     * что делать с аргументами при раскрытии тела макроса, когда они не указаны.
     * 
     * Но может быть следует переименовывать только одно имя без учета скобок,
     * например, оставив такую возможность только для одиночных макросов.
     * 
     * \name -> name или name (...), hash: name
     * но \name(...) -> name(...), а name - ошибка !!!!  hash: name
     * 
     * Или все же следует различать макросы со скобками и без скобок как два разных объекта???
     * \name := name2;  и \name(...) := name2(...); будут разными объектами
     * 
     * Или добавить макросы-алиасы без аргументов только для переименования отдельных терминов?
     * \alias :- name2; но как их отличать от обычных макросов в операции удаления?
     * Или вообще не нужно отличать и оставить только один варинат (либо макрос, либо алиас)
     * Тода вопрос со скобками закрывается сам собой, алиасы всегда без скобок,
     * макросы со скбками или без скобок, но должно быть полное соответствие.
     * 
     * @ name name2 @ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * @ name name2(...) @ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * @ name name2[...](...) @ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * @ name $tmpl[...](...) name3@ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Но!
     * @ name name2 @ ::-  -> name name2 - ок, но name name2(...) - ок
     * @ name $tmpl name3@ ::- -> name $tmpl[...](...) name3 - ок, name $tmpl(...) name3[...] - ок
     * 
     * 
     * 
     * Для последовательности лексем требуется полное соответствие с учетом скобок ???
     * и может ли быть несколько скобок одного типа (несколько крыглях, или несколько квардратных????
     * <Может быть несколько скобок одного типа, например, при указании типа у аргументов или типа возвращаемого значения.>
     * 
     * @ name name2 @ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * @ name name2(...) @ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * @ name name2[...](...) @ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * @ name $tmpl[...](...) name3@ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Проблема скобок возникает из-за сценария замены одного термина на другой, 
     * который есть в препроцессоре С/С++, но отсутствует при реализации с использованием шаблонов.
     * 
     *      
     */






Макросы используются и для превращеня исходного кода *NewLang* в более привычный синтаксис на основе [ключевых слов](https://newlang.net/syntax_dsl.html), так как такой тест гораздо легче воспринимается при последующем чтении исходного кода.


[Например:](https://newlang.net/syntax_dsl.html).
```
    @@if(...)@@    ::= @@ [ \$* ]--> @@;
    @@while(...)@@ ::= @@ [\$*] <-> @@;
    @@return $arg@@::=  @@ -- \$arg -- @@;
    @@true@@ ::= 1;
```

Тогда цикл до 5:
```
count:=1;
[ 1 ] <-> {
    [count>5] --> {
        -- 42 --;
    };
    count+=1;
};
```

будет выглядеть более привычно
```
count:=1;
while( true ) {
    if(count>5) {
        return 42;
    };
    count+=1;
};
```




