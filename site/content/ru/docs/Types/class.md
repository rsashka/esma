---
title: Классы
# linkTitle: Docs
# menu: {main: {weight: 20}}
weight: 35
---

Тип данных *:Class* аналогичен словарю, но все свойства обязаны иметь имена (хотя доступ к свойствам класса по индексу так же возможен).
При создании экземпляра класса создается новая переменная, для которой копируются свойства свойства и методы всех родителей. 

Синтаксис определения класса использует выглядит следующим образом:
```
# Новый тип (класс) :NewClass
:NewClass := :Class() { # Родительские класс или несколько классов через запятую
    field := 1;
    method() := {};
};
obj := :NewClass(); # Экземпляр класса
```
Так как *NewLang* реализует полный набор вариантов проверок при создании объектов (**::=** - создать новый объект, **:=** - создать новый или присвоить значение существующему, **=** - только присвоить значение, а если объект не существует будет ошибка), то переопределения наследуемых функций не требует вообще никаких ключевых слов:
```
:NewClass2 := :NewClass() { # Новый класс на базе существующего
    field ::= 2;    # Будет ошибка, т. к. поле field уже есть в базовом классе
    method() = {};  # Аналог override, т.к. method должен существовать в базовом классе
};
```

## Интерфейсы, именование методов классов и пространства имен
Для создания уникальных идентификаторов у методов классов *NewLang* использует подход, примерно как в языке Python. При создании метода класса создается глобальная функция с именем класса и именем метода, объединенные через разделитель области имен. 
Например, в классе `:NewClass2` при создании метода `method` будет создана функция с именем `NewClass2::method`.

Такая схема наименований методов полностью соответствует именованию функций в пространствах имен, и тем самым позволяет определять классы в чистыми виртуальными функциями (методами без реализации), а в последствии определять их, указав нужное имя в пространстве имен или в явном виде.

```
:NewClass3 := :NewClass() { # Новый класс на базе существующего
    virtual() := _; # Виртуальный метод
};

obj := :NewClass3(); # объект создать нельзя, будет ошибка

:NewClass3::virtual() := {}; # функция для виртуального метода

obj := :NewClass3(); # ОК

```

## Конструкторы, деструкторы и финализаторы у объектов
Пока в разработке, в настоящий момент планируется следующий синтаксис:
```
:NewClass := :Class() { # Новый класс на базе существующего
    NewClass() := {...}; # Метод с именем типа - конструктор объекта
    _NewClass() := {...}; # Скрытый метод с именем типа - приватный конструктор объекта
    __NewClass__() := {...}; # Системынй метод с именем типа - деструктор объекта (вызывается сразу после удаления)
    _() := {...}; # Скрытый метод без имени - финализатор (вызывается перед освобождением памяти)

};
```


