---
title: NewLang
---

{{< blocks/cover title="Добро пожаловать на сайт проекта NewLang!" image_anchor="top" height="auto" >}}

<a class="btn btn-lg btn-primary me-3 mb-4" href="/ru/docs/">
  Документация <i class="fas fa-arrow-alt-circle-right ms-2"></i>
</a>

<a class="btn btn-lg btn-secondary me-3 mb-4" href="/ru/blog/">
  Статьи <i class="fas fa-arrow-alt-circle-right ms-2 "></i>
</a>

<a class="btn btn-lg btn-secondary me-3 mb-4" href="https://github.com/rsashka/newlang/">
  GitHub <i class="fab fa-github ms-2 "></i>
</a>

{{< blocks/link-down color="info" >}}
{{< /blocks/cover >}}


{{% blocks/lead %}}

<p class="lead"><em>NewLang</em> — это язык программирования высокого уровня общего назначения c логичным и не противоречивым синтаксисом на основе грамматических правил. 
<br>Но помощью макросов препроцесора, синтаксис превращается в DSL на основе ключевых слов.</p>

<p class="lead mt-5">Тензорные вычисления и рациональные числа не ограниченной точности поддерживаются на уровне синтаксиса языка и базовых типов данных без использования дополнительных библиотек.</p>

{{% /blocks/lead %}}


{{% blocks/section %}}

<h3>
Основные свойства и особенности языка:
</h3>

<ul>
<li>возможность работы как в режиме интерпретатора, так и компилятора<b>*</b>
</li>

<li>динамическая и статическая типизация с возможностью указания типов в явном виде
</li>

<li>статическая типизация является условно-строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных. Например, целое число может быть автоматически преобразовано в вещественное или рациональное, но не наоборот)
</li>

<li>автоматическое управление памятью без сборщика мусора
</li>

<li>ООП в виде явного наследования классов и «утиная типизация»
</li>

<li>на уровне синтаксиса поддерживается несколько типов функций (обычные и чистые функции без побочных эффектов)
</li>

<li>необязательные и именованные параметры функций
</li>

<li>возможны вставки кода на языке реализации (С/С++)<b>*</b>
</li>

<li>простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных, функций и классов* из С/С++.)
</li>

<li>имеется <a href="https://ru.wikipedia.org/wiki/REPL">REPL (read-eval-print loop — «цикл: чтение — вычисление — вывод»)</a>
</li>
</ul>

<hr>
<b>*</b>) Данные возможности запланированы к реализации при создании компилятора


{{% /blocks/section %}}

{{% blocks/section %}}

<h2>Зачем нужен <em>NewLang</em>?
</h2>

<p>
У всех современных языков программирования происходит постоянное <a href="/ru/blog/complex-prog/">развитие (усложнение) синтаксиса</a> по мере выхода новых версий.<br> 
Это является своего рода платой за появление новых возможностей и воспринимается пользователями как естественное явление.
<p>
    
<p>
Но одновременно является и серьезной проблемой, так как с выходом версий добавляются новые ключевые слова и синтаксические конструкции, 
что неизбежно повышает порог входа для новых пользователей.
<p>    
<p>
Еще одним следствием этого процесса становится постоянное повышение сложности разработки и поддержки уже созданных программных продуктов, 
когда старый код дорабатывается с применением уже новых стандартов.
</p>

<p>
У <em>NewLang</em> сложность языковых конструкций ограничена естественным образом за счет разделения синтаксиса языка на две части, что упрощает его изучение и использование.
</p>

<p>
<em>Основной синтаксис</em> — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, 
который основан не на зарезервированных ключевых словах, а на системе строгих <a href="/ru/docs/syntax/">грамматических правил</a>.
Имеется возможность расширения основного синтаксиса за счет использования макросов.<br> 

<em>Расширенный синтаксис</em> — программные вставки на языке реализации (С/С++), когда основного синтаксиса становится недостаточно.
</p>
    
<p>
Еще одно неудобство современных языков в том, что большинство из них были созданы до начала эпохи машинного обучения, 
поэтому тензорные вычисления у них выполнены в виде отдельных библиотек.<br> 
Это же касается и вычислений с неограниченной точностью, которые так же требуют применения дополнительных библиотечных функций.
</p>

<p>
У <em>NewLang</em> тензорные вычисления и рациональные числа неограниченной точности доступны «из коробки».<br> 

Они поддерживаются на уровне синтаксиса для записи литералов соответствующих типов, 
а простые арифметические типы данных являются скалярами (тензорами нулевой размерности).<br> 

Реализация тензорных вычислений сделана на базе библиотеки <a href="">[libtorch](https://pytorch.org/), 
а рациональные числа с использованием <a href="">[OpenSSL](https://github.com/openssl/openssl/blob/master/crypto/bn/README.pod).
</p>


{{% /blocks/section %}}

{{% blocks/section %}}

<h4>Пример скрипта Hello world! на NewLang</h4>

<br>
<code>
<pre>
    #!../output/nlc --eval

    hello(str) := {
        # Импорт и вызов стандартной функции printf
        printf := :Pointer('printf(format:FmtChar, ...):Int32');
        printf('call: %s', $str);
        $str;
    };
    hello('Привет, мир!');
</pre>
</code>

Вывод:   
<code><pre>
    call: Привет, мир!
    Привет, мир!
</pre></code>


<h4>Пример вычисления факториала 40 на NewLang</h4>

<br>
<code>
<pre>
    #!../output/nlc --eval

    fact := 1\1; # Рациональное число без ограничений точности
    mult := 40..1..-1?; # Создать итератор из диапазона для множителей от 40 до 2
    [mult ?!] <-> { # Цикл, пока не закончатся данные итератора
        fact *= mult !; # Получить текущий множитель и перейти на следующий элемент итератора
    };

    fact # Вывести итоговый результат
</pre>
</code>

Вывод:
<code>
<pre>
    815915283247897734345611269596115894272000000000\1
</pre>
</code>


{{% /blocks/lead %}}

