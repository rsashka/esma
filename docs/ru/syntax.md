# Синтаксис

## Основы
- Операторы разделяются точкой с запятой «;».
- Отступы и переводы строк игнорируются.
- Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash.
- Многострочные комментарии соответствуют стилю С/С++ и должны располагаться между символами /\* и \*/. Многосточные комментарии могут быть вложенными.
- Последовательность команд (блок кода), который выполняется как единое целое, заключается в фигурные скобки «{}». Результатом выполнения блока кода является результат последней операции *(что очень похоже на оператор **запятая** в языках С/С++ или **блок** в Ruby)*.

### Правила именования объектов и типов данных

В качестве идентификаторов объектов и типов данных можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой. 
Символ подчерка, а так же подчерк в начале имени или двойные подчерки в начале и в конце имени имеют специальное значение.

Перед именем может быть указан специальный префикс (модификатор), который состоит из одного символа и имеет определенное значение:

#### Префиксы (модификаторы) и специальные символы
- **$** — в начале имени обозначает локальную переменную, время жизни которой ограничено областью видимости текущего блока и при её завершении локальная переменная уничтожается.
- **:** — двоеточие вначале идентификатора используется для указания имени [типа](/ru/types.html)
- **::** — двойное двоеточие являются разделителями для указания пространства имен
- **@** — Префикс **@** является модификатором для имени макроса
- **\\** — Префикс из одного слеша обозначает имя программного модуля относительного текущего и разделяет имена каталогов
- **\\\\** — Два обратных слеша в начале идентификатора обозначает глобальное имя программного модуля

Если перед именем модификатор не указан, то сперва ищется макрос, потом локальная переменная и в последнюю очередь модуль (объекта модуля).

### Локальные и глобальные переменные
В *NewLang* по умолчанию переменная создается как глобальная статическая, которая сохраняет свое состояние между вызовами.

Чтобы создать локальную перемененную, перед её именем необходимо указать знак доллара **$**, тогда такая переменная будет уничтожаться при выходе из текущей области видимости. 
Если условно классифицировать эти два варианта переменных, то можно считать, что переменная по умолчанию создается в куче, а локальная с префиксом **$** на стеке.

Семантика локальных переменных, а так же аргументов у функций очень похожа на аргументы в bash скриптах, где **$1** или **$arg** — порядковый номер или имя аргумента.

### Пространства имен
*NewLang* поддерживает одновременно пространства имен, как в языке C++, так и модульную структуру кода как в языках Java и Python.
Синтаксис для указания пространства имен очень похож на С++, который разделяется двойными двоеточиями.
При указании пространства имен для блока кода, его нужно указать перед открывающейся фигурной скобкой.

```
ns:: { # Пространство имен ns

    var := 0; # Имя переменной будет ns::var

    name:: {
        var := 0; # Имя переменной будет ns::name::var
        ::var := 1; # Переменная из глобального пространства имен
    };

    :: { # Глобальное пространство имен
        var := 1; 
    };
};
```


### Программные модули
В *NewLang* реализована концепция программных модулей - которая повторяет идею иерархического расположения файлов в структуре каталогов файловой системы, 
так же, как это сделано в языках Python и Java. Имя программного модуля начинается и структура каталогов записываются через **\\** (как разделитель каталого в Windows). 

При указании объектов программные модули и пространства имен можно объединять. 
Например, полное имя переменой можно записать с указанием программного модуля `\root\dir\module::ns::name::var`, 
где **root** и **dir** это каталоги в файловой системе относительно текущего моделя, а **module** — имя файла, т.е. *root/dir/module.nlp*


\каталог\файл - относительный путь к модулю
\\каталог\файл - абсолютный путь к модулю
\\('каталог\файл') - динамическая загрузка модуля

Статическая и динамическая - как линковка, проверка выполняется при компиляции или только при выполнении.

\\('каталог\файл', ...) раскрывается в \\каталог\файл(@$...), где @$... агрументы файла при выполнени.
Для определения списка импортируемых функций и переменных для импорта нужно использовать зарезервированные имена аругментов командной строки
(как в java -J-XX:+UseStringDeduplication -J-Xss2m  -J-Dapple.laf.useScreenMenuBar=true, или опиции линковщика у gcc -Wl,option и т.д.)
Соответственно, список импортируемых функций и переменные для импорта можно определять и при статической загрузке модуля:
\\каталог\файл( options )


### Области видимости
Области видимости объектов определяются аналогично принятым в языке Python с помощью подчерков перед именем переменной.

Один подчерк соответствует защищенной, а два подчерка - приватной области видимости объекта в соответствующем модуле или классе.

Но так же как и в языке Python, области видимости больше соответствуют "джентльменской" договоренности и при явном указании имени, 
доступ к защищенным объектам можно получить указав их полное имя. 

Системные поля и объекты начинаются и заканчиваются на два подчерка.



## Макросы

Макросы в **NewLang**, это один или несколько последовательных терминов, которые заменяются на другой термин 
или на целую синтаксическую конструкцию (последовательность лексем). 

Макросы обработываются во время работы **лексера**, т.е. перед передачей лексем в парсер, 
что позволяет изменять даже сам синтаксис языка, например, при реализации собственных диалектов DSL.

### Определение макросов

Определение макросов аналогично определению других объектов и состоит из трех частей **<имя макроса> <оператор создания/присвоения> <тело макроса>** и завершающая точка с запятой **;**,
т.е. применяются операторы **::=**, **=** или **:=** для создания нового макроса, переопределения уже существующего макроса
или для создания/присвоения нового значения макросу не зависимо от его наличия или отсутствия.

Телом макроса могут быть корректное выражение языка, последовательность лексем (которые заключается в двойные собачки @@, 
т.е. `@@ лексема1 лексема1 @@`) или обычная текстовая строка (обрамленная в тройные @@@, т.е. `@@@ текстовая строка @@@`).

Именем макроса может быть одна или нескольких лексем (терминов), которые указываются между двумя символами @@.
В имени макроса кроме лексем (терминов) могут присутствовать один или несколько шаблонов.

*Шаблон* — это термин, который при сопоставлении последовательности лексем с идентификатором макроса 
может заменяться любым другим одиночным термином (т.е реализуется сопоставление по образцу/шаблону).

Для создания термина-шаблона в начале его идентификатора нужно поставить знак доллара (что соответствует записи имени локальной переменой), 
т.е. имени макроса `@@ func $name@@` будут соответствовать как `func my_func_name`, так и `func other_name_func`.

Для удаления макросов используется специальный синтаксис: `@@@@ name @@@@;` или `@@@@ два термина @@@@;`, 
т.е. необходимо указать идентификатор макроса между четырмя символами @.

```bash
    # Тело макроса из текстовой строки (как в препроцессоре С/С++)
    @@macro_str@@  := @@@ строка - тело макроса @@@; # Строка для лексера

    # Оператор удаления макроса
    @@@@ macro_str @@@@;
```

### Аргументы макросов и их раскрытие

Макросы можно определять как с аргументами (параметрами в скобках), так и без них. 
Если макрос был определен с аргументами, то их проверка будет выполнятся макропроцессором при определении и раскрытии макроса.
Если макрос был определен без аргументов, то их наличие макропроцессором игнорируется при раскрытии макроса.

Так как макропроцессор считает макросы с аргументами и без оных идентичными, то нельзя создать два макроса 
с одинаковыми именами, один из которых будет с аргументами (скобками), а другой без них.  

Поэтому, если требуется использовать макрос в двух разных вариантах (с аргументами и без них), 
тогда следует определять макрос без аргументов, тогда контроль его параметров будет производить компилятор.

```bash
    @@macro@@ := term; # Макрос без аргументов
    
    macro(args); # ОК -> term(args);
    macro; # ОК -> term;

    # Но 
    @@call()@@ := term(); 

    call(); # ОК -> term();
    call; # Ошибка (call определен с аргументами) 
```

Если при определении макроса указаны аргументы, то чтобы в теле макроса указать место для их вставки, 
их нужно записать как имя локальной переменой, но перед аргументом добавить символ @, т.е. **@$arg**.

Произвольное количество аргументов у макроса отмечается троеточием "...", а место для их вставки отмечается 
лексемой с указанием соотвутствующего имени, например, **@$name(\*)**, **@$name<\*>** или **@$name[\*]** в зависимости от типов использованных скобок, 
где **name**, это имя термина или шаблона, который имеет аргументы (т.е. после которого стоят скобки соответствующего вида).  

Для вставки количества реально переданных аргументов используется лексемы **@$name(#)**, **@$name<#>** 
или **@$name[#]** с указанием соответствующего идентификатора.

Для вставки произвольного количества терминов шаблона используется лексема @$* - в виде словаря ??????, 
Для вставки произвольного количества терминов шаблона используется лексема @$... - индивидуальным аргументом, 
а для вставки количества реально присутствующих терминов лексема @$#.




По аналогии с препроцессором С/С++ для соединения двух лексем в одну в теле макроса используется оператор **@##**, 
а для преобразование лексемы в текстову строку применяется операторы **@#**, **@#"** или **@#'**, например, 
`@@macro($arg)@@ := @@ func_ @## @$arg(@#arg) @;`, тогда вызов `macro(name);` будет преобразован в `func_name ("name");`


# Ограничения макропроцессора в текущей версии

На текущий момент макросы реализованы в минимальном объеме для самых простых сценариев использования:

- DSL для keyword based syntax (if, else, return, match, while  и т.д.) - (1 термин с произвольными аргументами и без) - требуется сейчас !!!

*Парсер при обработке макросов может анализировать информацию о типах данных, если она указана.* 
*Но на текущий момент типы данных в макросах никак не обрабатываются и это одна из обязательных фич, которая будет реализована в будущем.*

- Определения (func, class) - (несколько терминов с аргументами и без аргументов) - Реализация ООП и импорт С++ классов
- Модификации при определениях (override) - (несколько терминов и шаблоны с аргументами и без аргументов) - Реализация ООП и импорт С++ классов

# МАКРОСЫ БЕЗ АРГУМЕНТОВ ИЛИ ВСЕ АРГУМЕНТЫ СРАЗУ !!!!!
# анализа аргументов или их типов не производится !!!




Lambda
@@ lambda $name(...) @@ ::= @@  @$name( @$... ) ::= ( _( @$... ) ::=  @__PRAGMA_FINALIZE__( @\), {, {+, {-, {* ) @@


### Примеры использования макросов

```bash
    # Обычные макросы (тело макроса корректное выражение)
    @@macro@@        := replace();
    @@macro2(arg)@@  := { call(@$arg); call()};

    # Тело макросов из последовательности лексем
    @@if(...)@@    := @@ [ \$if(*) ]--> @@; # Выражение может быть не полным
    @@elif(...)@@  := @@ ,[ \$elif(*) ]--> @@;
    @@else@@       := @@ ,[_]--> @@;
 
    # Запись условного оператора с использованием 
    # определенных выше макросов
    if( condition ){
        ...
    } elif( condition2 ) {
        ...
    } else {
        ...
    };
```










Зачем нужна трансформация синтаксиса?
Нативная поддержка других языков нужна чтобы не переписывать легаси код на этих языках.

Чтобы можно было использовать существующие исходники как собственные требуется настройка работы 
препроцессора и лексера под конкретный язык программирования (описание DSL).
Для **С/С++** потребуется выделять лексером комментарии из-за пересечения синтаксиса (которые сейчас игнорируются).
Для **Python** требуется выделять лексером отступы (которые сейчас тоже игнорируются), причем потребуется реализация не только синтаксиса, 
но и зависимых пакетов с последующая трансляцией этого кода в С++, что в настоящий момент делать не целесообразно (cython ???).

Но так как возможность трансформации кода с других языков программирования принципиальная возможна, 
стоит над этим думать только после полноценного релиза NewLang и его перехода в прод.



Для реализации DSL требуется передача команд в парсер для управления его работой (по аналогии с командой #pragma)
Но так как обработка таких команд должна происходить в лексере до передачи данных в парсер (анализатор),
то команды для макропроцессора должны быть в максимально простом виде и состоять из элементов, 
которые лексер может самостоятельно идентифицировать, т.е. термины, строки и цифры (без выражений и именованных аргументов).

После обработки такой команды она анализируется макропроцессором и удаляется из потока лексем, т.е. в парсер (анализатор) не передается. 
Но в случае ошибки с синтаксисе, данные команды нужно уметь однозначно идентифировать и самый простой способ, 
комбинация признака макроса и системного имени, т.е. что-то вроде 
```
    @__PRAGMA_DIAG__(push)
    @__PRAGMA_DIAG__(ignored, "-Wundef")
    @__PRAGMA_DIAG__(warning, "-Wformat")
    @__PRAGMA_DIAG__(error "-Wuninitialized")
    @__PRAGMA_DIAG__(pop)

    #pragma message "Compiling " __FILE__ "..."
    @__PRAGMA_MESSAGE__("Compiling ", __FILE__, "...")

    #pragma error "Error " __FILE__ "..."
    @__PRAGMA_ERROR__("Error ", __FILE__, "...")


#define DO_PRAGMA(x) _Pragma (#x)
#define TODO(x) DO_PRAGMA(message ("TODO - " #x))

@@TODO( ... )@@ := @__PRAGMA_MESSAGE__("TODO - ", @*)

@TODO(Remember to fix this)  # note: TODO - Remember to fix this

\\.__lexer__ignore_space__ = 1;
\\.__lexer__ignore_indent__ = 1;
\\.__lexer__ignore_comment__ = 1;
\\.__lexer__ignore_crlf__ = 1;


```


Таким образом можно трансформировать условный оператор на питоне в синтаксис NewLang следующим макросом:
```

#pragma clang attribute push
#pragma clang diagnostic ignored "-Wundef"
#pragma clang diagnostic ignored "-Wunused-variable"


#elif __GNUC__

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"

#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wextra"
    
    @pragma warning(pop)

    @@ pragma warning(...) @@ := __PRAGMA_TERM_DIAG_WARNING__();
@__PRAGMA_DIAG__(warning, pop);

Обработка терминов в макропроцессоре в максимально простом виде. 
Агрументы только термины, строки и цифры без вложенных выражений и именованных аргументов, 
т.е. только элементы, которые может самостоятельно идентифицировать лексер.

@warning("--")
    @@ if ... : @@ := @@ [ @$* ]-> __TERM_BLOCK_INDENT__("{", force_semicolon=1) @@
    
    if __name__ == "__main__":
        run1()
        run2()

    [ __name__ == "__main__" ]-> {
        run1();
        run2();
    };
    
        

```








Ключ --parser-syntax-only только текстовый парсинг исходного кода без загрузки модулей, раскрытия макросов и проверки имен.

Ключ --parser-no-macros - без раскрытия макросов 
Ключ --parser-no-module - без загрузки модулей (и мокросов, если они в них определяются)
Ключ --parser-no-check-prototype - без проверки имен при обращении

prototype
@__PRAGMA_PROTOTYPE__(define)
@__PRAGMA_PROTOTYPE__(implement)

$$

\\$ - корень системы (система)

\$ - текущий модуль

# Макросы для конвертора проверки в Python
# if __name__ == "__main__": 

@@ __name__ @@ ::= @@   \$. @__PRAGMA_NO_MACRO__() __name__ @@
@@ if $... @\: @@ ::= @@ [ @$... ] -->  @@

@if( \$.__name__ == "__main__" ) {


}

\\каталог\модуль() - статический импорт модуля
\\("каталог\модуль")() - динамический импорт модуля


printf := :Pointer('printf(format:FmtChar, ...):Int32');
printf := %printf(format:FmtChar, ...):Int32;


# Регистрация прототипа нативной функции
@prototype
%puts(format:StrChar):Int32;

# Импорт нативной функции с предварительной проверкой её наличия во время компиляции (статическая линковка)
puts2(format:StrChar):Int32 := %puts(format:StrChar):Int32;
# Импорт нативной функции по её прототипу во время выполнения (динамическая линковка)
puts3(format:StrChar):Int32 := :Pointer('puts(format:StrChar):Int32');

%puts('Тест вывода строки'); # Линковка с нативной функцией во время компиляции и непосредственный вызов с оптимизацией передачи параметров
puts2('Тест 2 вывода строки'); # Линковка с нативной функцией во время компиляции
puts3('Тест 3 вывода строки'); # Линковка с нативной функцией во время выполнения при первом вызове puts3



- Парсинг исходного текста без раскрытия макросов и загрузки модулей
- Парсинг исходного текста с раскрытием макросов (требуется загрузка модулей для зависимых и переопределяемых макросов)
- Загружатся модули могут как в виде исходников (которые требуется парсить и компилировть/выполнять) 
или в виде бинарников (в них должны быть список макросов, типов и имена объектов)
- После парсинга получается список **имен** макросов, типов и объектов (TermPtr)
- После выполнения модуля - список **имен** заполняется реальными объектами (ObjPtr).


# Компиляция файла
- Парсинг исходника для построения AST (без анализа имен, связей, загрузки модулей и пр. только исходые тексты с раскрытием макросов
- 


# Систематизация реализации макросов

последовательность лексем MACRO_SEQ мужду @@  @@ сохраняется в m_block, так как фрагменты блоков не могут быть идентификаторами

Разбор макросов происходит в лексере. Определением макроса всегда является целая строка, 
которая заканчивается точкой с запятой, а идентификатором макроса всегда выступает последовательность лексем:
```bash
    @@ id @@ := macro;
    @@ id @@ := @@ @@;
    @@ id @@ := @@@ @@@;
```
Хранилищем текущих максросов является объект класса MacroBuffer. 
Последовательность лексем идентификатора (id) макроса должна сохраняется в отдельном поле термина и однозначно его идентифицирует.
Первый термин в идентификаторе хранится как ключ hashmap, а дальше происходит поиск полным перебором.
Этапы работы с макросами

- Входные термины из лексера получаются вызовом GetNextToken, внутри которой и происходит раскрытие макросов.
Внутренний буфер заполняется до окончания строки (выражения), т.е. до символа ';' или <END>, после чего производится 
поиск макросов в объекте MacroBuffer для текущей последовательности лексем в буфере.

- Если макрос найден, то соответствющая ему последоваетльность заменяется на тело макроса и происходит переход 
на повторный анализ входного буфера.

- Если макрос не найден, то данные передаются в парсер для дальнейшего синтаксическго анализа.

- Для этого во входном потоке лексем (parser.y) во время оператората создания/присвоения вызывается функция проверки на макрос.
MacroBuffer::CheckMacroAndConvertDel($$), и после этого выходному значению присваивается результат выполнения driver.MacroEval($$),
и в дальнейшем этот макрос никак не обработывается.

- Создание макросов, проверка на дубликаты и логические ошибки в определении происходит путем обращения к методам объекта MacroBuffer.






    /*
     * Макросы хрянтся как фрагменты AST в виде объектов типа Term,
     * так как создаются после обработки парсером по правилам стандратной грамматики.
     * 
     * Но анализ входных данных на предмет раскрытия макросов проиходит из потока (последовательности) лексем,
     * т.е. **ДО** обработки парсером, так как при раскрытии макросов может меняться грамматика выражений.
     * 
     * Функция \ref CompareMacro сравнивает входной буфер (последовательность лексем)
     * на предмет возможного соответствия одному конкретному макросу.
     * Сравниваются только ключевые словам без учета аргументов в скобках, 
     * но само наличие аргументов проверяется ??????????????????
     * 
     * Проблема:
     * К функции можно обратится с целью её вызова (указав после имени скобки), 
     * так и по имени без скобок (например для получения ссылки на объект).
     * Так и к переменной можно обратиться только по имени, 
     * так и указав скобки после имени как к функции (при копировании объекта).
     * 
     * Сделать один макрос под оба сценария (со скобками и без скобок) не получится, так как непонятно, 
     * что делать с аргументами при раскрытии тела макроса, когда они не указаны.
     * 
     * Но может быть следует переименовывать только одно имя без учета скобок,
     * например, оставив такую возможность только для одиночных макросов.
     * 
     * \name -> name или name (...), hash: name
     * но \name(...) -> name(...), а name - ошибка !!!!  hash: name
     * 
     * Или все же следует различать макросы со скобками и без скобок как два разных объекта???
     * \name := name2;  и \name(...) := name2(...); будут разными объектами
     * 
     * Или добавить макросы-алиасы без аргументов только для переименования отдельных терминов?
     * \alias :- name2; но как их отличать от обычных макросов в операции удаления?
     * Или вообще не нужно отличать и оставить только один варинат (либо макрос, либо алиас)
     * Тода вопрос со скобками закрывается сам собой, алиасы всегда без скобок,
     * макросы со скбками или без скобок, но должно быть полное соответствие.
     * 
     * @ name name2 @ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * @ name name2(...) @ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * @ name name2[...](...) @ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * @ name $tmpl[...](...) name3@ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Но!
     * @ name name2 @ ::-  -> name name2 - ок, но name name2(...) - ок
     * @ name $tmpl name3@ ::- -> name $tmpl[...](...) name3 - ок, name $tmpl(...) name3[...] - ок
     * 
     * 
     * 
     * Для последовательности лексем требуется полное соответствие с учетом скобок ???
     * и может ли быть несколько скобок одного типа (несколько крыглях, или несколько квардратных????
     * <Может быть несколько скобок одного типа, например, при указании типа у аргументов или типа возвращаемого значения.>
     * 
     * @ name name2 @ -> name name2, но name name2(...) - ошибка!!! (hash: name,name2)
     * @ name name2(...) @ -> name name2(...), но name name2 - ошибка !!!! (hash: name,name2)
     * @ name name2[...](...) @ -> name name2[...](...), но name name2 - ошибка !!!!  ( hash: name,name2 )
     * @ name $tmpl[...](...) name3@ -> name $tmpl[...](...) name3, но name $tmpl name3 - ошибка !!!!  ( hash: name,$,name3 )
     * 
     * Проблема скобок возникает из-за сценария замены одного термина на другой, 
     * который есть в препроцессоре С/С++, но отсутствует при реализации с использованием шаблонов.
     * 
     *      
     */






Макросы используются и для превращеня исходного кода *NewLang* в более привычный синтаксис на основе [ключевых слов](https://newlang.net/syntax_dsl.html), так как такой тест гораздо легче воспринимается при последующем чтении исходного кода.


[Например:](https://newlang.net/syntax_dsl.html).
```
    @@if(...)@@    ::= @@ [ \$* ]--> @@;
    @@while(...)@@ ::= @@ [\$*] <-> @@;
    @@return $arg@@::=  @@ -- \$arg -- @@;
    @@true@@ ::= 1;
```

Тогда цикл до 5:
```
count:=1;
[ 1 ] <-> {
    [count>5] --> {
        -- 42 --;
    };
    count+=1;
};
```

будет выглядеть более привычно
```
count:=1;
while( true ) {
    if(count>5) {
        return 42;
    };
    count+=1;
};
```






## Операторы и управляющие конструкции

### Создания объектов и присвоения новых значений

Для создания объектов и присвоения им новых значений в NewLang используется сразу три вида операторов:
- **::=** или **::-** - используется только для создания новых объектов, а если объект с таким именем уже существует, то генерируется ошибка.
- **:=** или **:-** - используется для тех же целей, но если объект с таким именем уже существует, то ошибки не происходит, а новое значение присваивается уже существующему объекту.
- **=** - применяется только для присвоения значения уже существующим объектам, а если объект с указанным именем отсутствует, то происходит ошибка выполнения.

Использование трех разных видов операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе. 

Например, при определении класса `:NewClass2`:
```bash
    :NewClass := :Class() { # Базовый класс
        filed ::= 2;
        method() ::= {};
    };
    :NewClass2 := :NewClass() {
        filed ::= 2; # Будет ошибка, т.к. field уже есть в базовом классе
        method() = {}; # Аналог override, т.к. method должен существовать в базовом классе
    };
```

Если же контролировать момент создание объектов и присвоения им значений не требуется, то можно пользоваться единственным оператором **:=**.

```bash
    var := 1.0; # Создать новую переменную var без явного указания типа
    var := 100; # Присвоить новое значение уже существующей переменной
    printf := :Pointer('printf(format:FmtChar, ...):Int32'); /* Создать новый или переопределить существующий объект printf */
```

### Присваивание значения сразу нескольким переменным и оператор распаковки словаря
*NewLang* поддерживает операцию присваивания сразу нескольким переменным, которые должны быть перечислены через запятую слева от оператора присвоения. 
С правой стороны от оператора присвоения может находится одно или несколько значений или оператор распаковки словаря **...** (многоточие). 
Оператор распаковки словаря можно использовать и при передаче аргументов в функцию. 

Словарь может быть указан и с левой стороны от оператора присвоения и таким образом можно записать самый простой способ перебора всех его элементов: 
`item, dict := ... dict;`, т.е. когда в цикле первый элемент словаря сохраняется в переменную item, а из самого словаря удаляется.

Пример реализации цикла foreach для суммирования всех элементов словаря (или одномерного тензора) с использованием оператора раскрытия списка:
```
    summa := 0;
    dict := (1,2,3,4,5,);
    while( dict ) {
        # Первый элемент словаря перемещается в item
        item, dict := ... dict; 
        summa += item;
    };
```

### Арифметические операторы

Все операторы имеют парный аналог с присвоением значения:
- **+** и **+=** — сложение арифметических типов данных;
- **-** и **-=** — вычитание арифметических типов данных;
- **/** и **/=** — деление (результат число с плавающей точкой);
- **//** и **//**= — целочисленное деление с округлением к меньшему числу (как в Python);
- **\*** и **\*=** — умножение;
- **\*\*** и **\*\*=** — возведение в степень (он же используется и для повторения текстовых строк);

### Операторы сравнения:
- **<**, **>**, **<=**, **>=** — классические для сравнения скаляров
- **==** и **!=** — операторы сравнения с автоматическим приведением совместимых типов для любых объектов
- **===** и **!==** — операторы точного сравнения для любых объектов (автоматического приведения типов не выполняется)

### Проверка типа (имени класса объекта):
Для оператора проверки имени типа (класса) объекта используется символ тильда **~**. Он немного похож на оператор *instanceof* в Java. Левым операндом должен быть проверяемый объект, а правым — проверяемый тип, который можно указать строкой литералом, переменной строкового типа или именем проверяемого класса непосредственно. Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта или он присутствует в иерархии наследования.

```
    name := "class"; # Строковая переменная с именем класса
    var ~ name; 
    var ~ :class; # Сравнение с типом
    var ~ "class"; # Имя типа как строка литерал
```

### Утиная типизация
Оператор утиной типизации, два символа тильды **~~** — приблизительный аналог функции *isinstance()* в Python, 
который для простых типов сравнивает непосредственную совместимость типа левого операнда по отношению к правому. 
А для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда, т.е.:

```
    (field1=«value», field2=2,) ~~ (); # Истина (т. е. левый операнд словарь)
    (field1=«value», field2=2,) ~~ (field1=_); # Тоже истина (т. к. поле field1 присутствует у левого операнда)
    (field1=«value», field2=2,) ~~ (not_found=_); # Ложь, т.к. поле not_found у левого операнда отсутствует
```

Строгая утиная типизация **~~~** — для простых типов сравнивается идентичности типов без учета совместимости, 
а для составных типов происходит сравнение всех свойств с помощью оператора строгого равенства. 
Для данной операции, пустой тип совместим только с другим пустим типом.

## Управляющие конструкции

К управляющим конструкциям языка NewLang относятся условный оператор, два вида циклов, оператор оценки выражения, 
оператор прерывания последовательности выполнения команд и перехват прерывания. 
Операторы проверки условий всегда указываются в квадратных скобках, а последовательность команд для выполнения — в фигурных.

### Условный оператор

В качестве оператора проверки условия используется синтаксическая конструкция, соответствующая по смыслу термину «следует», 
т.е. два тире и угловая скобка **-->**. Такая запись условного оператора очень похожа на математическую и легко объединяется 
в последовательности для проверки множественных условий вида «else if».

В общем случае условный оператор имеет вид: **[** условие **] --> {** действие **};** или 
с условием иначе **[** условие **] --> {** действие **}, [_] --> {** действие иначе **};**

Для наглядности записанный с отступами:
```bash
    [ условие1 ] --> { действие1 },
    [ условие2 ] --> действие2,
    [ условие3 ] --> действие3,
    [_] --> {действие_иначе};
```

Или тоже самое, но с использованием [макросов из модуля dsl](https://newlang.net/syntax_dsl.html).:
```bash
    if( условие1 ) { 
        действие1 
    } elif( условие2 ) действие2
    elif( условие3 ) действие3
    else { 
        действие_иначе
    };
```

### Оценка выражения

Синтаксическая конструкция с помощью которой реализуется примерный аналог оператора switch или math выглядит следующим образом:
```bash
    [ $var ] ==> {
        [1] --> { code }, # Выполнится проверка условия $var == 1
        [1, 2] --> { code }, # Выполнится проверка условия ($var == 1 || $var == 2)
        [_] --> { code default }; # Ветка условия иначе
    };
```
Или тоже самое, но с использованием [макросов из модуля dsl](https://newlang.net/syntax_dsl.html).:
```bash
    match( $var ) ==> {
        case( 1 ) { code }
        case( 1, 2 ) { code }
        else { code default };
    };
```

Этот оператор очень похож на *Pattern Matching*, но все же не является сопоставлением с образцом, 
а скорее более краткая запись множественного оператора сравнения, 
так как в качестве оператора для оценки могут быть использован любые имеющиеся операторы сравнения на равенство:
- **==>** — проверка на равенство с приведением типов;
- **===>** — проверка на точное равенство;
- **~>** — проверка типа (имени класса);
- **~~>** — утиная типизация;
- **~~~>** — строгая утиная типизация.

Но если в качестве оператора сравнения использовать оператор утиной типизации, то оценка выражения превращается в классический *Pattern Matching*:
```bash
    $value := (f1=1, f2="2",);
    match( $value ) ~~~> {
        case((f1=_, ), (f1=_, f2=0, )) { ... code ... } # Поле f2 отсутствует или число 
        case((f1=_, f2="",), (f1=_, f2='',)) { ... code ... } # Поле f2 строка
        else { ... code default ... }; # Код по умолчанию
    };
```

### Операторы циклов

Для записи циклов используются оператор **<->**, который ставится между условием цикла (проверкой логического выражения) и телом цикла. 
Условие цикла записывается в квадратных скобках и в зависимости от взаимного расположения цикл может быть с предусловием (while) 
или постусловием (dowhile):
```bash
    [условие while] <-> {
        тело цикла while
    };

    {
        тело цикла dowhile
    } <-> [условие dowhile];
```

Пример реализации цикла foreach для суммирования всех элементов словаря (или одномерного тензора) с использованием оператора раскрытия списка:
```
    summa := 0;
    dict := (1,2,3,4,5,);
    [ dict ] <-> { # Условие цикла, пока есть данные
        item, dict := ... dict; # Результат оператора распаковка словаря - первый его элемент перемещается в item
        summa += item; # Вычисление суммы всех элементов словаря
    };
```

Цикл с предусловием (**while**) поддерживает конструкцию **else**, которая выполняется, если условие входа в цикл не было выполнено. 

> *Внимание!* 
> *Это поведение отличается от аналогичных конструкций в языке Python, у которого секция **else** выполняется всегда, кроме прерывания цикла по break.*

Ветка **else** у оператора цикла записывается так же как и ветка *иначе* в условном операторе, т.е. 
```
    [ cond ] <-> {
        ...
    },[_] --> {
        ...
    };
```
Или тоже самое, но с использованием [макросов из модуля dsl](https://newlang.net/syntax_dsl.html).:
```
    while(cond) {
        ...
    } else {
        ... # Выполнится, только если cond будет false при входе в цикл
    };
```


## Операторы прерывания выполнения (оператор возврата)

### Прерывания, возврат и обработка ошибок
Изменена, а точнее полностью переделана идеология возвратов из функций и обработки ошибок. 
Теперь она чем-то похожа на подход, примененный в Ruby. 
Любая последовательность команд заключенные в фигурные скобки (в том числе тело функции), 
рассматривается как блок кода у которого нет специального оператора аналога **return**, который возвращает какое либо значение. 
Просто любой блок кода всегда возвращает последнее вычисленное значение (это чем то похоже на оператор «запятая» в языках C/C++).

Для того, чтобы прервать выполнение кода используются две разные команды - прерывания, которые 
условно можно назвать *положительным* и *отрицательным* результатом, что примерно соответствует семантике их записи. 
"Отрицательное" прерывание записывается в виде двух минусов, а "положительное" прерывание в виде двух плюсов, т.е. **-\-** или **++**.

По умолчанию данные операции возвращают пустое значение. Чтобы прерывание вернуло результат, возвращаемые данные нужно записывать между 
парой соответствующих символов, т.е. **-\-** 100 **-\-**, что является близким аналогом оператора `return 100;` в других языках программирования, 
а **++**«Строка»**++** - аналогом `return «Строка»;`.

Хотя более точным аналогом этих операторов будет все таки не **return**, а **throw**, т.к. эти команды не только прерывают 
выполнение последовательности команд в блоке, но их еще можно «ловить». 
Для этого используется блок кода с соответствующей семантикой, **{+** … **+}** - блок кода, который перехватывает 
положительные прерывания и **{-** … **-}** - блок кода, который перехватывает прерывания, созданные операторами **--**. 

Подобная концепция (в явном виде не разделять возвраты из функций и обработку исключений), и оставить конкретную реализацю 
на усмотрение компилятора, хоть и выглядит немного необычной, но позволяет реализовывать несколько очень полезных финтов, 
которые сложно реализуемые в обычных языках программирования.

Например, возврат из нескольких вложенных функций без необходимости обрабатывать результат возврата каждой из них. 
В этом примере функция *Test* перехватывает "положительные" прерывания из вложенных функций:
```bash
    Test0(arg) := { if($arg==0) return("DONE - 0"); «FAIL» };
    Test1(arg) := { if($arg==1) return("DONE - 1"); Test0($arg); };
    Test(arg) := {+ if($arg >= 0) Test1($arg); $arg; +};

    Test(0); # Вернет «DONE — 0» возврат из вложенной функции Test0
    Test(1); # Вернет «DONE — 1» возврат из вложенной функции Test1
    Test(2); # Вернет «FAIL» возврат из вложенной функции Test0
    Test(-2); # Вернет -2 — возврат из функции Test
```
Есть еще блок `{* ... *}`, который перехватывает оба типа прерываний. 
Такой блок кода поддерживает типизацию возвращаемого значения, что позволяет в явном виде указывать типы данных, которые нужно перехватывать. 
Например, `{* ... *} :Type1` — будет перехвачено прерывание вида `++ :Type1 ++` или `--:Type1--`, 
что позволяет очень гибко формировать логику работы программы.

Блоки кода с перехватом исключений также поддерживают оператор иначе (*else*) который, 
по аналогии с оператором *else* в циклах, выполняется только тогда, если прерывания не произошло.

Можно указать сразу несколько типов, которые нужно перехватывать:
```bash
    {* 
        ....
    *} <:Type1, :Type2, :Type3>;
```








### Специальные идентификаторы
- **$0** — текущий объект для класса или None в остальных случаях.
- **$\*** — Все аргументы текущей функции или модуля
- **@\*** — Все аргументы запущенной программы

- **$$** — родительский объект (в том числе и при переопределении функций).
- **@@** — Системный контекст
- **@$** — Текущий модуль

Проверить, является ли текущий модуль основным, можно протестировав его нулевой аргумент. У основного модуля программы, нулевой аргумент всегда будет содержать имя исполняемого файла, а остальные аргументы соответствовать параметрам командной строки (если они есть). Если файл загружен как модуль,
то нулевой аргумент у модуля будет пустым.
```
# Аналог проверки в Python
# if __name__ == "__main__": 

[@$.$0] --> { # или \ifmain при использовании макросов из модуля @dsl
    ...
};
```

### Зарезервированные имена компилятора

При работе парсера *NewLang* автоматически генерируются несколько зарезервированных имен, которые можно использовать как обычные константы.
Большинство из них соответствуют макросам препроцессора у С/С++:

- \_\_FILE\_\_ - расширяется до полного пути к текущему файлу
- \_\_LINE\_\_ - содержит номер текущей строки
- \_\_TIMESTAMP\_\_ - дату и время последней модификации текущего файла
- \_\_MD5\_\_ - md5 хеш текущего файла
- \_\_VERSION\_\_ - версия текущего модуля/файла

- \_\_DATE\_\_ - дата и время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)
- \_\_COUNTER\_\_ - целочисленный счетчик, который увеличивает свое значение при каждом обращении
- \_\_NLC_VER\_\_ - версия NewLang

- \_\_SOURCE_GIT\_\_ - текстовая строка с идентификатором исходных файлов NewLang git репозитория, использованных при сборке компилятора
- \_\_DATE_BUILD\_\_ - текстовая строка с датой сборки компилятора NewLang
- \_\_SOURCE_BUILD\_\_ - дата сборки и git идентификатор исходных файлов NewLang одной текстовой строкой




func name() {+
+}

var name := value; 
var name:type := value; 
var name:type[] := value; 
@@ var $name := $value @@ := @@  @$name @__PRAGMA_UNEXPECTED__( @\( )  @__PRAGMA_EXPECTED__(::=, :=)  @$value  @@

var name;
@@ var $name @@ := @@  @$name @__PRAGMA_UNEXPECTED__( @\( )  @__PRAGMA_EXPECTED__(::=, :=)  @$value  @@
















### Системные свойства

Несмотря на то, что не все объекты *NewLang* являются классами с точки зрения [реализованной концепции ООП](https://newlang.net/type_oop.html), 
тем не менее, каждый объект имеет системные свойства, которые можно считать во время выполнения как обычные свойства объекта:

#### У всех переменных (объектов) есть системные свойства
- \_\_name\_\_ - краткое имя переменной (объекта)
- \_\_full_name\_\_ - полное имя переменной, включая имя модуля и пространство имен
- \_\_type\_\_ - текущий тип переменной. Может изменится при некоторых операциях
- \_\_type_fixed\_\_ - тип переменной (объекта) который не может измениться (ограничитель)
- \_\_module\_\_ - имя модуля в котором определена переменная (объект)
- \_\_class\_\_ - имя класса переменной или пусто, если объект не является классом
- \_\_base\_\_ - словарь со списком базовых классов или пусто, если объект не является классом
- \_\_size\_\_ - количество элементов у объекта, если применимо или :None 

- \_\_doc\_\_ - документация по текущему объекту (если есть, иначе пустая строка)
- \_\_str\_\_ - строковое представление объекта для дампа
- \_\_source\_\_ - исходный текст модуля или функции

#### Системные свойства у модулей
- \_\_file\_\_ - полный путь к файлу модуля (соответствует С/С++ макросу \_\_FILE\_\_)
- \_\_timestamp\_\_ - дата и время последней модификации файла модуля (соответствует макросу С/С++  \_\_TIMESTAMP\_\_)
- \_\_md5\_\_ - хеш исходных данных модуля (соответствует макросу \_\_MD5\_\_)




## DSL

### Особенности ассоциативной памяти
Синтаксис языка *NewLang* основан на строгих правилах без использования ключевых слов, 
и как бы он не выглядел логичным, ассоциация по ключевым словам вспоминается гораздо легче, например **if**,
чем комбинация *минус минус правая угловая скобка* **-->**. 
Из-за этого имеет смысл использовать не "чистый" базовый синтаксис, а более привычный диалект с использованием ключевых слов. 

### Синтаксис на ключевых словах
В файле dsl.nlp находится набор макросов, которые расширяют базовый синтаксис *NewLang*, основанный на правилах,
набором предопределенных ключевых слов как в классических языках программирования. 
А при необходимости, их можно адаптировать или дополнить под собственную предметную область.


## Константы
### Логические
- **true** - 1
- **yes**  - 1
- **false** - 0
- **no** - 0

### Системные имена
- **this** - Текущий объект (**$0**)
- **parent** - Родительский объект (**$$**)
- **last** - Результат выполнения последнего оператора (**$^**)

!!!!!!!!- **args** - Все аргументы функции (**$\***)

!!!!!!!!- **sys** - Системный контекст запущенной программы (**@@**)
!!!!!!!!- **current** - Текущий модуль (**@$**)
!!!!!!!!- **cmd** - Все аргументы выполняющегося приложения из командной строки (**@\***)

!!!!!!!!!!1### Типовые функции и проверки 
!!!!!!!!!!- **run('filename')** - Выполнить указанный файл (**@@('filename')**)
!!!!!!!!!!- **ifmain** - Проверка, если текущий модуль основной (**[@$.$0] -->** { ... })
!!!!!!!!!!- **ifload** - Проверка, если текущий модуль загружается впервые (**[@$.__load__] -->** { ... })

### Операторы
- **match(cond)** - Оператор [оценки выражения](https://newlang.net/ops.html#оценка-выражения)
- **if(...)** - Первый условный оператор (**[\$*]-->** { ... })
- **elif(...)** - Второй и все последующие (**,[\$*]-->** { ... })
- **else** - Оператор *иначе* (**,[_]-->** { ... })

- **while(cond)** - Оператор цикла с предусловием (**[@$cond] <->** { ... } )
- **dowhile(cond)** - Оператор цикла с постусловием ({ ... } **<->[@$cond]**)

- **iter(obj, ... )** - Создание итератора ( **@$obj** ? (@$*) )
- **next(obj, ... )** - Следующий элемент итератора ( **@$obj** ! (\$*) )
- **curr(obj, ... )** - Текущий элемент итератора ( **@$obj** !? (\$*) )
- **first(obj)** - Перейти на первый элемент итератора ( **@$obj** !! )
- **all(obj)** - Получить сразу все элементы итератора ( **@$obj** ??)


### Прерывания
- **return** - Положительное прерывание (**++**)
- **return(...)**- Положительное прерывание с возвратом значения (**++** @$value **++**) 

- **error** - Отрицательное прерывание (**-\-**)
- **error(...)** - Отрицательное прерывание с возвратом значения (**-\-** @$value **-\-**)

- **break+** и **break-** - Выход из цикла:
```
    while(...) {+
        ++ :Break ++   
    +}
    while(...) {-
        -- :Break --
    -}
```
- **continue+** и **continue-** - В начало цикла:
```
    while(...) {+
        ++ :Continue ++   
    +}
    while(...) {-
        -- :Continue --
    -}
```





obj {
    .field = 1; 
    .prop();
};

#Python
# 1) without using with statement
file = open('file_path', 'w')
file.write('hello world !')
file.close()


 
# 2) without using with statement
file = open('file_path', 'w')
try:
    file.write('hello world')
finally:
    file.close()

open('file_path', 'w') {
    .write('hello world !');
    .close();
}

  
Python3

# using with statement
with open('file_path', 'w') as file:
    file.write('hello world !')


# a simple file writer object
 
class MessageWriter(object):
    def __init__(self, file_name):
        self.file_name = file_name
     
    def __enter__(self):
        self.file = open(self.file_name, 'w')
        return self.file
 
    def __exit__(self, *args):
        self.file.close()
 
# using with statement with MessageWriter
 
with MessageWriter('my_file.txt') as xfile:
    xfile.write('hello world')





# a simple file writer object
:MessageWriter {
    def __init__(self, file_name):
        self.file_name = file_name
     
    def __enter__(self):
        self.file = open(self.file_name, 'w')
        return self.file
 
    def __exit__(self, *args):
        self.file.close()
}

# using with statement with MessageWriter
 
MessageWriter('my_file.txt') {
    .write('hello world');
};







from contextlib import contextmanager
 
 
class MessageWriter(object):
    def __init__(self, filename):
        self.file_name = filename
 
    @contextmanager
    def open_file(self):
        try:
            file = open(self.file_name, 'w')
            yield file
        finally:
            file.close()
 
 
# usage
message_writer = MessageWriter('hello.txt')
with message_writer.open_file() as my_file:
    my_file.write('hello world')




:MessageWriter(object) {
    def __init__(self, filename):
        self.file_name = filename
 
    @contextmanager
    def open_file(self):
        try:
            file = open(self.file_name, 'w')
            yield file
        finally:
            file.close()
 
}

# usage
message_writer = MessageWriter('hello.txt')
with message_writer.open_file() as my_file:
    my_file.write('hello world')





# Приложения


## Предопределенные макросы

При работе парсера *NewLang* автоматически формируются несколько зарезервированных макросов, часть из которых соответствуют макросам препроцессора у С/С++.
Данные предопределенные макросы можно использовать как обычные константы. 

- \_\_FILE\_\_ или \_\_FILE_NAME\_\_ - имя и полный путь текущего файла
- \_\_LINE\_\_ или \_\_FILE_LINE\_\_ - содержит номер текущей строки в файле 
- \_\_FILE_TIMESTAMP\_\_ - дату и время последней модификации текущего файла в строковом представлении
- \_\_FILE_MD5\_\_ - md5 хеш текущего файла в строковом виде
- \_\_COUNTER\_\_ - целочисленный счетчик, который увеличивает свое значение при каждом обращении


- \_\_DATE\_\_ - дата начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)
- \_\_TIME\_\_ - время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)
- \_\_TIMESTAMP\_\_ - дату и время начала запуска компилятора (например: "Fri 19 Aug 13:32:58 2016") 
- \_\_TIMESTAMP_ISO\_\_ - дату и время начала запуска компилятора в формате ISO (например: "2013-07-06T00:50:06Z")


- \_\_NLC_VER\_\_ - Страшая и младшая версия компилятора NewLang (8 битное число, по 4 бита на цифру)
- \_\_NLC_DATE_BUILD\_\_ - текстовая строка с датой сборки компилятора NewLang (например, "23.06.04 20:51:39")
- \_\_NLC_SOURCE_GIT\_\_ - текстовая строка с идентификатором исходных файлов NewLang git репозитория, использованных при сборке компилятора (например, "v0.3.0-fef8c371")
- \_\_NLC_SOURCE_BUILD\_\_ - дата сборки и git идентификатор исходных файлов NewLang одной текстовой строкой (например, "v0.3.0-fef8c371 23.06.04 20:51:39")

