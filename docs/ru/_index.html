---
title: NewLang
---

{{< blocks/cover title="Добро пожаловать на сайт проекта NewLang!" image_anchor="top" height="auto" >}}

<a class="btn btn-lg btn-primary me-3 mb-4" href="/ru/docs/">
    Документация <i class="fas fa-arrow-alt-circle-right ms-2"></i>
</a>

<a class="btn btn-lg btn-secondary me-3 mb-4" href="/ru/blog/">
    Статьи <i class="fas fa-arrow-alt-circle-right ms-2 "></i>
</a>

<a class="btn btn-lg btn-secondary me-3 mb-4" href="/ru/playground/">
    Playground<i class="fas fa-arrow-alt-circle-right ms-2"></i>
</a>

<a class="btn btn-lg btn-secondary me-3 mb-4" href="https://github.com/rsashka/newlang/">
    GitHub <i class="fab fa-github ms-2 "></i>
</a>

{{< blocks/link-down color="info" >}}
{{< /blocks/cover >}}


{{% blocks/lead %}}

<p class="lead"><em>NewLang</em> — это язык программирования высокого уровня общего назначения c базовым синтаксисом на основе грамматических правил.
    С помощью макросов препроцесора, базовый синтаксис легко преобразуется в DSL на основе ключевых слов.</p>

<p class="lead">Тензорные вычисления и рациональные числа не ограниченной точности поддерживаются 
    на уровне синтаксиса языка и базовых типов данных без использования дополнительных библиотек.</p>

<p class="lead">Модель управления памятью на основе владения не трубет использования сборщика мусора 
    и исключет основные ошибки еще на этапе компиляции исходного текста программы.</p>

{{% /blocks/lead %}}


{{% blocks/section %}}

<h3>
    Основные свойства и особенности языка:
</h3>

<ul>
    <li>возможность работы как в режиме интерпретатора, так и компилятора<b>*</b>
    </li>

    <li>динамическая и статическая типизация с возможностью указания типов в явном виде
    </li>

    <li>статическая типизация является условно-строгой 
        <em>(автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных. 
            Например, целое число может быть автоматически преобразовано в вещественное или рациональное, но не наоборот)</em>
    </li>

    <li>автоматическое управление памятью без сборщика мусора на основе владения<b>*</b>
    </li>

    <li>ООП* в виде явного наследования классов и «утиная типизация»
    </li>

    <li>на уровне синтаксиса поддерживается несколько типов функций (обычные и чистые функции без побочных эффектов)
    </li>

    <li>необязательные и именованные параметры функций
    </li>

    <li>простая интеграция с уже существующими программными библиотеками 
        (в том числе импорт нативных переменных, функций и классов* из С/С++.)
    </li>

    <li>имеется <a href="https://ru.wikipedia.org/wiki/REPL">REPL (read-eval-print loop — «цикл: чтение — вычисление — вывод»)</a>
    </li>
    
    <li>символьные вычисления<b>**</b>
    </li>
</ul>

<hr>
<b>*</b>) Данные возможности запланированы к реализации
<br>
<b>**</b>) Символьные вычисления поддерживаются на уровне синтаксиса, но не реализованы


{{% /blocks/section %}}

{{% blocks/section %}}

<h2>Зачем нужен <em>NewLang</em>?
</h2>

<p>
    У всех современных языков программирования происходит постоянное <a href="/ru/blog/complex-prog/">развитие (усложнение) синтаксиса</a> по мере выхода новых версий.<br> 
    Это является своего рода платой за появление новых возможностей языка и воспринимается пользователями как естественное явление.
<p>

<p>
    Но одновременно является и серьезной проблемой, так как с выходом новых версий языка в него добавляются новые ключевые слова и синтаксические конструкции, 
    что неизбежно повышает порог входа для всех новых пользователей.
<p>    
<p>
    Еще одним следствием этого процесса становится постоянное увеличение сложности разработки и поддержки уже созданных программных продуктов, 
    когда старый программный код дорабатывается с применением уже новых стандартов и постоянным увеличением старого легаси кода.
</p>

<p>
    У <em>NewLang</em> сложность языковых конструкций ограничена естественным образом 
    за счет разделения синтаксиса языка на несколько частей, что упрощает его изучение и использование.
</p>

<p>
    <em>Основной (базовый) синтаксис</em> — на системе строгих <a href="/ru/docs/syntax/">грамматических правил</a>.
</p>
<p>
    <em>Синтаксис DSL (domain-specific language)</em> — хотя базовый синтаксис самодостаточен и полснотью покрывает все возможные сценарии использования, 
    но его применение разработчиками напрямую не всегда эффекстивно с точки зрения последующего чтения исходноиков.
    <br>
    Поэтому более правильным вариантом написания исходного кода программы будет применение <a href="/ru/docs/syntax/dsl/">предметно-ориентированного языка</a>, 
    который реализуется с помощью макросов препроцессора и превращает базовый синтаксис на основе <a href="/ru/docs/syntax/">грамматических правил</a>
    в синтаксис на основе <a href="/ru/docs/syntax/dsl/">ключевых слов</a>.

</p>
<p>
    <em>Расширенный синтаксис</em> — программные вставки на языке реализации (С/С++), когда основного или DSL синтаксиса становится недостаточно.
</p>

<br> 
<p>
    Еще одно неудобство современных языков в том, что большинство из них были созданы еще до начала эпохи машинного обучения, 
    поэтому тензорные вычисления у них выполнены в виде отдельных библиотек. 
    Это же касается и вычислений с неограниченной точностью, которые также требуют использования дополнительных библиотечных функций.
</p>

<p>
    У <em>NewLang</em> тензорные вычисления и рациональные числа неограниченной точности доступны «из коробки».
    Они поддерживаются на уровне синтаксиса для удобной записи литералов, 
    а простые арифметические типы данных являются скалярами (тензорами нулевой размерности).
    <br> 
    <br> 
    Реализация тензорных вычислений сделана на базе библиотеки <a href="https://pytorch.org/">libtorch</a>, 
    а рациональные числа с использованием <a href="https://github.com/openssl/openssl/blob/master/crypto/bn/README.pod">OpenSSL</a>.
</p>


{{% /blocks/section %}}

{{% blocks/section %}}

<h4>Пример скрипта Hello world! на NewLang</h4>

<br>
<code>
    <pre>
    #!../output/nlc --eval

    hello(str) := {
        # Импорт и вызов функции printf стандартной библиотеки
        printf(format:FmtChar, ...):Int32 := %printf...;
        printf('call: %s', $str);
        $str;
    };
    hello('Привет, мир!');
    </pre>
</code>

Вывод:   
<code><pre>
    call: Привет, мир!
    Привет, мир!
    </pre></code>


<h4>Пример вычисления факториала 40 на NewLang (базовый синтаксис)</h4>

<br>
<code>
    <pre>
    #!../output/nlc --eval

    fact := 1\1; # Рациональное число 1 (без ограничения точности)
    mult := 40..1..-1?; # Итератор из диапазона для множителей от 40 до 2
    [mult ?!] <-> { # Цикл, пока не закончатся данные итератора
        fact *= mult !; # Получить текущий множитель и перейти на следующий элемент итератора
    };

    fact # Вывести итоговый результат
    </pre>
</code>

Вывод:
<code>
    <pre>
    815915283247897734345611269596115894272000000000\1
    </pre>
</code>


<h4>Тот же код с использованием DSL синтаксиса</h4>

<br>
<code>
    <pre>
    #!../output/nlc --eval

    fact := 1\1;
    mult := iter( 40..1..-1 );
    while( curr(mult) ) {
        fact *= next(mult);
    };

    fact;
    </pre>
</code>


Вывод:
<code>
    <pre>
    815915283247897734345611269596115894272000000000\1
    </pre>
</code>



{{% blocks/section %}}

<a class="btn btn-lg btn-primary me-3 mb-4" href="/ru/docs/examples/">
    Еще примеры кода<i class="fas fa-arrow-alt-circle-right ms-2"></i>
</a>

<a class="btn btn-lg btn-primary me-3 mb-4" href="/ru/docs/syntax/">
    Описание синтаксиса<i class="fas fa-arrow-alt-circle-right ms-2"></i>
</a>

<a class="btn btn-lg btn-primary me-3 mb-4" href="/ru/docs/">
    Вся документация<i class="fas fa-arrow-alt-circle-right ms-2"></i>
</a>

<a class="btn btn-lg btn-secondary me-3 mb-4" href="/ru/blog/">
    Статьи<i class="fas fa-arrow-alt-circle-right ms-2 "></i>
</a>


{{% /blocks/section %}}

{{% /blocks/lead %}}





