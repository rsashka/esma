<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="ru" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" type="text/html" href="http://localhost:1313/ru/blog/">
<link rel="alternate" type="application/rss&#43;xml" href="http://localhost:1313/ru/blog/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/favicons/android-192x192.png" sizes="192x192">

<title>Статьи | NewLang</title>
<meta name="description" content="NewLang сайт">
<meta property="og:title" content="Статьи" />
<meta property="og:description" content="NewLang сайт" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/ru/blog/" /><meta property="og:site_name" content="NewLang" />
<meta itemprop="name" content="Статьи">
<meta itemprop="description" content="NewLang сайт"><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Статьи"/>
<meta name="twitter:description" content="NewLang сайт"/>





<link href="/scss/main.css" rel="stylesheet">

<script
  src="https://code.jquery.com/jquery-3.6.3.min.js"
  integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ=="
  crossorigin="anonymous"></script>
<script defer
  src="https://unpkg.com/lunr@2.3.9/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>

  </head>
  <body class="td-section td-blog">
    <header>
      <nav class="td-navbar navbar-dark js-navbar-scroll">
<div class="container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/ru/"><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class="navbar-brand__name">NewLang</span></a>
  <div class="td-navbar-nav-scroll ms-md-auto" id="main_navbar">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link" href="/ru/docs/"><span>Документация</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="/ru/playground/"><span>Playground</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link active" href="/ru/blog/"><span>Статьи</span></a>
      </li>
      <li class="nav-item dropdown d-none d-lg-block">
        <div class="dropdown">
  <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Русский</a>
  <ul class="dropdown-menu">
    <li><a class="dropdown-item" href="/blog/">English</a></li>
    </ul>
</div></li>
      </ul>
  </div>
  <div class="d-none d-lg-block">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="Поиск по сайту…"
    aria-label="Поиск по сайту…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/offline-search-index.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
          </div>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
          </div>
          <main class="col-12 col-md-9 col-xl-8 ps-md-5 pe-md-4" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
Это многостраничный печатный вид этого раздела.
<a href="#" onclick="print();return false;">Нажмите что бы печатать</a>.
</p><p>
<a href="/ru/blog/">Вернуться к обычному просмотру страницы</a>.
</p>
</div>



<h1 class="title">Статьи</h1>





    <ul>
    
  
  
  
  

  
    
    
	

    <li><a href="#pg-24881a51c9b3aaca484fa4a88ded08d7">Релиз языка программирования NewLang 0.4</a></li>



    
  
    
    
	

    <li><a href="#pg-5c44e7da427d42b8190cae828ce252eb">Нюансы разработки парсера для своего языка программирования</a></li>



    
  
    
    
	

    <li><a href="#pg-ad530d8b01cce04c0709230b0c5cfdd0">Вариант реализации DSL (domain-specific language) с помощью макросов</a></li>



    
  
    
    
	

    <li><a href="#pg-2ef4658740cd35c23eb19d8fbefa35dd">Релиз языка программрования NewLang 0.3</a></li>



    
  
    
    
	

    <li><a href="#pg-18c34abab4e3c18b54b60e0007679e6d">Релиз языка программрования NewLang 0.2</a></li>



    
  
    
    
	

    <li><a href="#pg-45137b7a0f14224461d02abf99b62c02">Релиз языка программрования NewLang</a></li>



    
  
    
    
	

    <li><a href="#pg-4170b8f0ec2a5e108877fa6d8749054d">Новый язык программирования</a></li>



    
  
    
    
	

    <li><a href="#pg-0264650d0efdd6e82885557e6aaf423c">Можно ли использовать декларативный и императивный стили написания программ одновременно?</a></li>



    
  
    
    
	

    <li><a href="#pg-358d8b7408f85724d92f6f2c125e0958">Необычная концепция синтаксиса языка программирования</a></li>



    
  
    
    
	

    <li><a href="#pg-8e46bcfa1e536a4f19ec0380d04dfc8a">Простое сложное программирование</a></li>



    
  
    
    
	

    <li><a href="#pg-0f103385a5e3972851e7afd1b3ae2ebe">Какая «идеальная» цель развития у языков программирования?</a></li>



    
  
    
    
	

    <li><a href="#pg-c770759fb02136df5f3e7fa94ce88af1">Проблема логических языков программирования</a></li>



    
  
    
    
	

    <li><a href="#pg-849ec5b11ef9375c495caa904b271aae">Интернациональное программирование на естественных языках</a></li>



    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    


  

<div class="td-content" style="">
    <h1 id="pg-24881a51c9b3aaca484fa4a88ded08d7">Релиз языка программирования NewLang 0.4</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2023-06-06" class="text-muted">06.06.2023</time>
        
	</div>
	<h2 id="новые-возможности-и-изменения-в-синтаксисе-newlang">Новые возможности и изменения в синтаксисе NewLang<a class="td-heading-self-link" href="#%d0%bd%d0%be%d0%b2%d1%8b%d0%b5-%d0%b2%d0%be%d0%b7%d0%bc%d0%be%d0%b6%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d0%b8-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f-%d0%b2-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81%d0%b5-newlang" aria-label="Heading self-link"></a></h2>
<ul>
<li>Переработано определение типов объектов с помощью <a href="https://newlang.net/docs/syntax/naming/">префикса имен (сигила)</a></li>
<li>Прерывание потока выполнения и возврат теперь может выполняться для <a href="https://newlang.net/docs/ops/throw/">именованных блоков кода</a>.</li>
<li>Упрощен синтаксис импорта <a href="https://newlang.net/docs/types/native/">нативных переменных и функций (С/С++)</a></li>
<li>Стабилизирован синтаксис для <a href="https://newlang.net/docs/ops/create/#comprehensions">заполнение начальными данными</a> значений тензоров, словарей и аргументов при вызове функций.</li>
<li>Появились встроенные макросы для написания кода с использованием ключевых слов в стиле <a href="https://newlang.net/docs/syntax/dsl/">DSL</a></li>
</ul>
<h2 id="новые-возможности-компилятора-nlc">Новые возможности компилятора (nlc)<a class="td-heading-self-link" href="#%d0%bd%d0%be%d0%b2%d1%8b%d0%b5-%d0%b2%d0%be%d0%b7%d0%bc%d0%be%d0%b6%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d0%ba%d0%be%d0%bc%d0%bf%d0%b8%d0%bb%d1%8f%d1%82%d0%be%d1%80%d0%b0-nlc" aria-label="Heading self-link"></a></h2>
<ul>
<li>Полностью переделан макропроцессор.</li>
<li>Переработана архитектура компилятора с разделением на парсер, макропроцессор, синтаксический анализатор, интерпретатор и генератор кода.</li>
</ul>
<h2 id="разное">Разное<a class="td-heading-self-link" href="#%d1%80%d0%b0%d0%b7%d0%bd%d0%be%d0%b5" aria-label="Heading self-link"></a></h2>
<ul>
<li><a href="http://newlang.net">Сайт</a> с документацией переведен на <a href="https://gohugo.io/">Hugo</a> и сделан двуязычным.</li>
<li>Вместо бинарных сборок на сайт добавлен раздел <a href="https://newlang.net/playground/">Playground and example code</a> для небольших экспериментов.</li>
<li>Выполнен переход на clang-16 (переход на clang-17 и старше планируется после полной реализации корутин и поддержки расширенных форматов чисел с плавающей запятой).</li>
<li>Количество контрибуторов проекта стало больше одного!</li>
</ul>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-5c44e7da427d42b8190cae828ce252eb">Нюансы разработки парсера для своего языка программирования</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2023-03-29" class="text-muted">29.03.2023</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/langs.jpeg"></p>
<p>Недавно прочитал на Хабре статью <a href="https://habr.com/ru/post/723400/">Свой язык, или как я устал от ассемблера и С</a>, и невольно взглядом зацепился за один абзац:</p>
<blockquote>
<p>Я решил не сильно париться, поэтому использовал библиотеку parglare. Она очень легкая и удобная, всем рекомендую. Для описания синтаксиса парсер принимает строку в соответствующем формате, использует регулярные выражения (не надо осуждать регулярки, они всесильны!).</p>
</blockquote>
<p>В результате решил опубликовать статью на основе своих старых записей еще с тех времен, когда идея <a href="https://newlang.net/">NewLang</a> до конца еще не выкристаллизовалась, но уже хотелось писать реальный код и тестировать разные концепции.</p>
<p>Ведь в жизни практически любого программиста может наступить момент, когда ему в голову приходит светлая идея - разработать свой собственный язык программирования. Может быть и не ради захвата мира, наравне с C/C++, Python или хотя бы PHP, а в качестве личного пет-проекта, с которым он, длинными зимними вечерами будет оттачивать собственное мастерство.</p>
<p>А так как у любого языка (не только программирования), все начинается с анализа его грамматики, то самой первой задачей создателя будет выбор инструментов для синтаксического анализа исходного текста.</p>
<p>Это история — заметки на память о муках выбора связки лексер-парсер для разбора грамматики NewLang. А так же попытка описать и систематизировать выводы об особенностях разных анализаторов с которыми пришлось поработать при выборе парсера для разбора грамматики у своего языка программирования.</p>
<h3 id="используемые-термины">Используемые термины.<a class="td-heading-self-link" href="#%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d0%b5%d0%bc%d1%8b%d0%b5-%d1%82%d0%b5%d1%80%d0%bc%d0%b8%d0%bd%d1%8b" aria-label="Heading self-link"></a></h3>
<p>Чтобы было понятно, о чем в дальнейшем пойдет речь.</p>
<blockquote>
<p>Лексер — компьютерная программа или библиотека, в задачи которой входит разделить входной поток данных на отдельные, не связанные между собой отдельные фрагменты, которые принято называть токенами или лексемами.</p>
<p>Парсер — на основе последовательности токенов выполняется синтаксический анализ, например строит абстрактное синтаксическое дерево (AST).</p>
</blockquote>
<h2 id="заход--1---flex--bison">Заход № 1 - Flex + Bison<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%85%d0%be%d0%b4--1---flex--bison" aria-label="Heading self-link"></a></h2>
<p><a href="https://github.com/westes/flex">GitHub - westes/flex: The Fast Lexical Analyzer - scanner generator for lexing in C and C++</a>
<a href="https://www.gnu.org/software/bison/">Bison - GNU Project - Free Software Foundation</a></p>
<p>После прочтения умных книжек я начал с классики Flex + Bison. Это старые и давно отработанные приложения с широчайшими возможностями по настройке с помощью которых можно описать синтаксис и получить исходные файлы лексера и парсера для языка практически с любой грамматикой.</p>
<p>К сожалению, у этих старичков очень большой порог входа и тяжелая наследственность. Чего только стоит определение собственного класса лексера через <code>#define</code>, а так же отсутствие нормальной поддержки С++. Вынужденные танцы с бубном для пасинга отдельной строки, когда не требуется анализировать файл целиком и прочие не всегда очевидные проблемы и разные не понятные условности.</p>
<p>Другими словами, через несколько недель безуспешных мучений я решил посмотреть альтернативы, а так как начальный файл лексики после экспериментов с Flex + Bison кое-как уже был сделан, то следующая связка была Flex + lemon.</p>
<h2 id="заход--2---flex--lemon">Заход № 2 - Flex + Lemon<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%85%d0%be%d0%b4--2---flex--lemon" aria-label="Heading self-link"></a></h2>
<p><a href="https://www.sqlite.org/lemon.html">The Lemon LALR(1) Parser Generator</a></p>
<p>Тут все оказалось до примитивности просто и понятно. Реально очень быстрый старт с боевыми примерами, очень наглядный и понятный способ записи правил (по сравнению с Bison). Все хорошо кроме одного, хорошее быстро заканчивается, если приходится анализировать более одной строки.</p>
<p>По сути, Lemon с Bison, это как Инь и Янь. Lemon простой и удобный для работы с одной строкой (для этого он и создавался), а Bison супер-пупер-мега комбайн для парсинга файлов любых размеров.</p>
<p>Поэтому, поиски связки лексер + парсер продолжились и после прочтения очередной статьи, что парсеры языков можно делать на регулярках, решил посмотреть, что есть в этом направлении:</p>
<h2 id="заход--3-парсер-на-регулярках-re2c">Заход № 3 парсер на регулярках re2c<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%85%d0%be%d0%b4--3-%d0%bf%d0%b0%d1%80%d1%81%d0%b5%d1%80-%d0%bd%d0%b0-%d1%80%d0%b5%d0%b3%d1%83%d0%bb%d1%8f%d1%80%d0%ba%d0%b0%d1%85-re2c" aria-label="Heading self-link"></a></h2>
<p>Из описания <a href="https://re2c.org/">re2c</a>:</p>
<blockquote>
<p>По сути, на этой штуке можно писать лексические анализаторы прямо на коленке за несколько минут.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">/*!re2c
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYPEEK       = &#34;*cursor&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYSKIP       = &#34;++cursor;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYBACKUP     = &#34;marker = cursor;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYRESTORE    = &#34;cursor = marker;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYBACKUPCTX  = &#34;ctxmarker = cursor;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYRESTORECTX = &#34;cursor = ctxmarker;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYRESTORETAG = &#34;cursor = ${tag};&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYLESSTHAN   = &#34;limit - cursor &lt; @@{len}&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYSTAGP      = &#34;@@{tag} = cursor;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYSTAGN      = &#34;@@{tag} = NULL;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYSHIFT      = &#34;cursor += @@{shift};&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">        re2c:define:YYSHIFTSTAG  = &#34;@@{tag} += @@{shift};&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">    */</span>
</span></span></code></pre></div><p>Показалось, что это самый удобный способ указания шаблонов для парсера! Достаточно описать в комментариях нужные шаблоны, напустить на исходный файл компилятор регулярок и все готово! Но нет, действительно, это только показалось.</p>
<p>Ведь для простеньких парсеров или регулярных выражений <strong>re2c</strong> может быть и действительно хорош, но отлаживать синтаксис большого языка на регулярках слишком хлопотное занятие.</p>
<p>После этого решил с ним не заморачиваться и посмотреть альтернативы классическим лексерам и парсерам.</p>
<h2 id="заход--4---flex-flexcpp--bisoncpp">Заход № 4 - flex (flexcpp) + bisoncpp<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%85%d0%be%d0%b4--4---flex-flexcpp--bisoncpp" aria-label="Heading self-link"></a></h2>
<p>Тогда как у традиционных flex + bison поддержка С++ реализована <del>через одно место</del> на уровне - работает и не трогай, то решил посмотреть их альтернативную реализация <a href="https://gitlab.com/fbb-git/flexcpp">flexcpp</a> + <a href="https://gitlab.com/fbb-git/bisoncpp">bisoncpp</a> с нативной поддержкой С++.</p>
<p>Первое впечатление было, то что доктор прописал!</p>
<p>Синтаксис записи лексики хоть немного и отличается от классической, но это не принципиально. Зато есть нативная и логичная поддержка С++ без оберток и выкрутасов, и как дополнительный плюс - более удобный синтаксис указания правил в парсере. Но и тут не обошлось без шероховатостей.</p>
<p>В шаблонах правил bisoncpp не поддерживает юникод (хотя сам лексер-парсер с ним справляется на ура), и совсем не понятная ситуация с поддержкой. Как я понял, разработчиком является вроде бы один человек, но пообщаться с ним насчет ошибок при обработке русских символов так и не получилось.*</p>
<p>Потом еще одно непонятное поведение вылезло в другом месте. В результате решил отказаться от недружелюбной поддержки и посмотреть, какие есть еще варианты парсеров.</p>
<hr>
<p>*) Через два года мой тикет был закрыт с комментарием, что поддерживаются только ascii символы.</p>
<h2 id="заход--5---неродной-парсер-antlr">Заход № 5 - неродной парсер ANTLR<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%85%d0%be%d0%b4--5---%d0%bd%d0%b5%d1%80%d0%be%d0%b4%d0%bd%d0%be%d0%b9-%d0%bf%d0%b0%d1%80%d1%81%d0%b5%d1%80-antlr" aria-label="Heading self-link"></a></h2>
<p>От использования <a href="https://www.antlr.org/">ANTLR</a> (от англ. ANother Tool for Language Recognition — «ещё одно средство распознавания языков») — генератора нисходящих анализаторов для формальных языков, я решил сразу отказать из-за того, что он написан на Java,.</p>
<p>В этом нет никаких религиозных предпочтений, так как я искал генератор парсеров, который можно было бы сделать встроенным прямо в среду выполнения, а в случае с ANTLR и JRE это было бы затруднительно.</p>
<p>Таким образом я опять вернулся к старичкам Flex и Bison, с которых все и начиналось.</p>
<h2 id="заход--6-последний---возвращение-к-flex--bison">Заход № 6, последний - возвращение к Flex + Bison<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%85%d0%be%d0%b4--6-%d0%bf%d0%be%d1%81%d0%bb%d0%b5%d0%b4%d0%bd%d0%b8%d0%b9---%d0%b2%d0%be%d0%b7%d0%b2%d1%80%d0%b0%d1%89%d0%b5%d0%bd%d0%b8%d0%b5-%d0%ba-flex--bison" aria-label="Heading self-link"></a></h2>
<p>Все описанные выше эксперименты заняли в общем итоге несколько месяцев, в результате которых были написаны килобайты исходного кода и тестовых примеров, прочитано десятки статей и как результат - возврат к изначальной связке Flex + Bison, но уже с солидным багажом опыта в применении различных вариантов лексеров-парсеров.</p>
<p>Но самое главное, с  пониманием того, что же в результате хочется получить, и очень большой базой тестовых примеров синтаксиса.</p>
<h2 id="выводы-на-память">Выводы на память<a class="td-heading-self-link" href="#%d0%b2%d1%8b%d0%b2%d0%be%d0%b4%d1%8b-%d0%bd%d0%b0-%d0%bf%d0%b0%d0%bc%d1%8f%d1%82%d1%8c" aria-label="Heading self-link"></a></h2>
<p>В итоге для себя решил следующее: если нужен простенький шаблонизатор, то идеальный вариант <strong>re2c</strong> (если почему-то не подходит <strong>regexp</strong>). Если требуется анализировать синтаксис сложнее обычных регулярок, но в одну строку, то идеальной будет связка flex+lemon, а если нужна серьезная артиллерия, то тут однозначно flex + bison.</p>
<p>От связки flexcpp + bisoncpp отказался совсем. Что с поддержкой — не понятно, синтаксис от классики отличается не очень сильно (хотя тоже нужно ломать голову), а обход выявленных косяков не стоят того синтаксического сахара.</p>
<p>И по итогам множества экспериментов с разными вариантами синтаксиса удалось сформулировать пару важных архитектурных моментов, которые могут очень сильно упростить жизнь создателям языком программирования:</p>
<h2 id="стратегия-обработки-ошибок-синтаксиса">Стратегия обработки ошибок синтаксиса<a class="td-heading-self-link" href="#%d1%81%d1%82%d1%80%d0%b0%d1%82%d0%b5%d0%b3%d0%b8%d1%8f-%d0%be%d0%b1%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b8-%d0%be%d1%88%d0%b8%d0%b1%d0%be%d0%ba-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81%d0%b0" aria-label="Heading self-link"></a></h2>
<p>Обычно принято обрабатывать синтаксические ошибки непосредственно в парсере и для этого есть определенный резон — в этом случае нет необходимости в каких либо дальнейших действиях, нужна только полностью описанная корректная грамматика.</p>
<p>Но если грамматика языка очень сложная (привет C++), и её описание становится сложной задачей, то можно отказался и от анализа ошибок синтаксиса непосредственно в парсере! То есть, лучше сделать максимально широкую лексику (даже с теми вариантами, которые являются для языка ошибочными), но ловить эти ошибки уже при анализе AST!</p>
<p>В этом случае, поддерживать описание грамматики языка становится значительно проще (меньше синтаксических правил, проще их формальное описание и т.д.), а самое главное, при описании грамматики не нужно думать про lval или rval, где можно указывать ссылку, а где нет — т. е. можно указывать все и везде, а вот анализ допустимости использования конкретных терминов будет выполняться позднее при анализе AST.</p>
<p><em>Отказа от полного анализа грамматики языка на уровне лексера — парсера и перенос проверки корректности синтаксических конструкций на этап разбора синтаксического дерева позволяет в разы, если не на порядки сократить и значительно упростить описание грамматических правил!</em></p>
<p>Подобное допущение очень полезно на начальном этапе создания языка (можно сосредоточиться на общей концепции, вместо постоянных правок в грамматике), а так же значительно упростить в будущем поддержку и/или расширение синтаксиса.</p>
<h2 id="макросы-и-модификация-грамматики-в-runtime">Макросы и модификация грамматики в Runtime<a class="td-heading-self-link" href="#%d0%bc%d0%b0%d0%ba%d1%80%d0%be%d1%81%d1%8b-%d0%b8-%d0%bc%d0%be%d0%b4%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%86%d0%b8%d1%8f-%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b8-%d0%b2-runtime" aria-label="Heading self-link"></a></h2>
<p>Какими бы мощными не были flex+bison, но у этой связки есть одна архитектурная проблема. Логика flex и bison построена на конечных автоматах и изменить грамматику языка во время выполнения приложения невозможно, тем более Bison сам вызывает лексер для получения очередной порции данных и ему очень непросто подсунуть измененные данные прямо во время работы. А так хотелось сделать возможность раскрытия макросов и модификации синтаксиса за один проход анализатора!</p>
<p>Для этого пришлось переделать логику работы flex+bison, чтобы парсер получал данные из лексера не напрямую из yylex, а через функцию — прокси. Эта промежуточная функция, складывает считанные лексемы во внутренний буфер. Данные в буфере анализируется на предмет наличия макросов и только после их раскрытия, лексемы отдаются в парсер из вершины буфера по одной за раз. Подробнее о макросах NewLang можно почитать <a href="/ru/blog/2023/03/01/%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-dsl-domain-specific-language-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D1%81%D0%BE%D0%B2/">тут</a>.</p>
<h2 id="самое-главное-при-разработке-грамматики">Самое главное при разработке грамматики!<a class="td-heading-self-link" href="#%d1%81%d0%b0%d0%bc%d0%be%d0%b5-%d0%b3%d0%bb%d0%b0%d0%b2%d0%bd%d0%be%d0%b5-%d0%bf%d1%80%d0%b8-%d1%80%d0%b0%d0%b7%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b5-%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b8" aria-label="Heading self-link"></a></h2>
<p>Но самый важный совет мне подсказал друг, который некогда участвовал в проекте по разработке парсера для языка программирования. И в правильности его совета - <strong>пиши тесты для грамматики</strong> - я убеждался уже множество раз. Даже так, <strong>ПИШИ ТЕСТЫ ДЛЯ ГРАММАТИКИ</strong>.</p>
<p>Тесты для грамматики языка гораздо более важная вещь, чем любой из используемых инструментов. Только тесты позволяют убедиться в том, что новая фича в языке не сломала старые наработки. А если все же сломала, то в первую очередь нужно добавить новый тест, который бы фиксировал сломавшийся сценарий и только после этого можно будет со спокойной душой продолжать эксперименты с новыми грамматическими конструкциями.</p>
<p>И удачи всем языкописателям!</p>
<p><a href="https://habr.com/ru/companies/timeweb/articles/724146/">Ссылка на первую публикаци</a></p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-ad530d8b01cce04c0709230b0c5cfdd0">Вариант реализации DSL (domain-specific language) с помощью макросов</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2023-03-01" class="text-muted">01.03.2023</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/dsl.jpeg"></p>


<div class="pageinfo pageinfo-primary">
<p>Внимание!!!</p>
<p>Данная статья содержит описание синтаксиса NewLnag предыдущей версии.</p>
<p>Актуальную версию синтаксиса языка можно посмотреть <a href="/ru/docs/">тут</a>.</p>

</div>

<p>Близится релиз языка <strong><a href="https://newlang.net/">NewLang</a></strong> с принципиальной новой «фишкой», переделанным вариантом препроцессора, который позволяет расширять синтаксиса языка для создания различных диалектов DSL за счет макросов.</p>
<p>И, как всегда, используя ранее найденный лайфхак <a href="https://habr.com/ru/post/539674/">Хабр — ума палата</a>, хотелось бы получить от читателей обратную связь насчет предлагаемого ниже подхода, который планируется к реализации в новом препроцессоре <strong>NewLang</strong>.</p>
<h3 id="о-чем-идет-речь">О чем идет речь?<a class="td-heading-self-link" href="#%d0%be-%d1%87%d0%b5%d0%bc-%d0%b8%d0%b4%d0%b5%d1%82-%d1%80%d0%b5%d1%87%d1%8c" aria-label="Heading self-link"></a></h3>
<blockquote>
<p><a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">DSL</a> (Предметно-ориентированный язык) - язык программирования, специализированный для конкретной области применения. Считается, что использование DSL существенно повышает уровень абстрактности кода, а это позволяет вести разработку более быстро и эффективно и существенно упрощает решение многих задач.</p>
</blockquote>
<h4 id="условно-можно-выделить-два-подхода-к-реализации-dsl">Условно, можно выделить два подхода к реализации DSL:<a class="td-heading-self-link" href="#%d1%83%d1%81%d0%bb%d0%be%d0%b2%d0%bd%d0%be-%d0%bc%d0%be%d0%b6%d0%bd%d0%be-%d0%b2%d1%8b%d0%b4%d0%b5%d0%bb%d0%b8%d1%82%d1%8c-%d0%b4%d0%b2%d0%b0-%d0%bf%d0%be%d0%b4%d1%85%d0%be%d0%b4%d0%b0-%d0%ba-%d1%80%d0%b5%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d0%b8-dsl" aria-label="Heading self-link"></a></h4>
<ul>
<li>Разработка независимых трансляторов синтаксиса с помощью генераторов лексеров и парсеров для определения грамматики целевого языка посредством БНФ и регулярных выражений (Lex, Yacc, ANTLR и т. д.) и последующей компиляцией полученной грамматики в машинный код.</li>
<li>Разработка или встраивание диалекта DSL на языке (метаязыке) общего назначения, в том числе за счет применения различных библиотек или специальных парсеров / препроцессоров.</li>
</ul>
<p>Далее речь пойдет о втором варианте, а именно, о реализации DSL на базе языков (метаязыков) общего назначения и новом варианте реализации макросов в <strong>NewLang</strong> как основы для разработки DSL.</p>
<h2 id="две-крайности">Две крайности<a class="td-heading-self-link" href="#%d0%b4%d0%b2%d0%b5-%d0%ba%d1%80%d0%b0%d0%b9%d0%bd%d0%be%d1%81%d1%82%d0%b8" aria-label="Heading self-link"></a></h2>
<p>Наверно имеет смысл начать с описания о двух крайностях при реализации DSL на базе языка (метаязыка) общего назначения:</p>
<h3 id="ограниченная-грамматика">Ограниченная грамматика<a class="td-heading-self-link" href="#%d0%be%d0%b3%d1%80%d0%b0%d0%bd%d0%b8%d1%87%d0%b5%d0%bd%d0%bd%d0%b0%d1%8f-%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b0" aria-label="Heading self-link"></a></h3>
<p>Если язык программирования ограничен собственной фиксированной грамматикой и не допускает её расширения,
то при реализации DSL разработчик будет вынужден использовать уже существующую грамматику, правила записи операций и вообще весь синтаксис будет оставаться такими же, как в языке реализации. Например, при использовании в качестве базового языка С/С++ или применении различных библиотек и фреймворков в других языках программирования общего назначения.</p>
<p><em>В этом случае под термином &ldquo;DSL&rdquo; будет скрываться просто набор специфических терминов предметной области, переопределенных макросов и/или операторов, но использование которых будет ограничено грамматикой языка реализации.</em></p>
<h3 id="неограниченная-грамматика">Неограниченная грамматика<a class="td-heading-self-link" href="#%d0%bd%d0%b5%d0%be%d0%b3%d1%80%d0%b0%d0%bd%d0%b8%d1%87%d0%b5%d0%bd%d0%bd%d0%b0%d1%8f-%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b0" aria-label="Heading self-link"></a></h3>
<p>Если же язык (метаязык) позволяет модифицировать собственную грамматику (например на уровне <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">AST</a>), то DSL уже не будет жестко огранен синтаксисом базового языка программирования, и в результате его грамматика может быть какой угодно. Вплоть до того, что «для каждого нового проекта придется изучать новый язык… ».
Это можно сделать с помощью использования специализированных метаязыков (Lisp, ML, Haskell, Nemerle, Forth, Tcl, Rebol и пр.)</p>
<p>Очень рекомендую прочитать о метапрограммровании великолепную статью @NeoCode <a href="https://habr.com/ru/post/258667/">Метапрограммирование: какое оно есть и каким должно быть</a>.</p>
<h2 id="для-обсуждения-предлагается-следующая-реализация-макросов">Для обсуждения предлагается следующая реализация макросов<a class="td-heading-self-link" href="#%d0%b4%d0%bb%d1%8f-%d0%be%d0%b1%d1%81%d1%83%d0%b6%d0%b4%d0%b5%d0%bd%d0%b8%d1%8f-%d0%bf%d1%80%d0%b5%d0%b4%d0%bb%d0%b0%d0%b3%d0%b0%d0%b5%d1%82%d1%81%d1%8f-%d1%81%d0%bb%d0%b5%d0%b4%d1%83%d1%8e%d1%89%d0%b0%d1%8f-%d1%80%d0%b5%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f-%d0%bc%d0%b0%d0%ba%d1%80%d0%be%d1%81%d0%be%d0%b2" aria-label="Heading self-link"></a></h2>
<p>«Нет в мире совершенства», и после выпуска релиза <strong>NewLang 0.2</strong> я получил много отзывов (по большей части негативных),
по поводу первого варианта <a href="https://github.com/rsashka/newlang/blob/v0.3.0/docs/syntax.md#%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D1%81%D1%8B">реализации макросов</a> и <a href="https://github.com/rsashka/newlang/blob/v0.3.0/docs/syntax_dsl.md">DSL на их основе</a>. И если положить руку на сердце, эта критика часто была обоснованной.
Поэтому я решил попробовать немного переделать макросы, в надежде получить «золотую середину» между двумя описанными выше крайностями при описании DSL.</p>
<h3 id="используемая-терминология">Используемая терминология<a class="td-heading-self-link" href="#%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d0%b5%d0%bc%d0%b0%d1%8f-%d1%82%d0%b5%d1%80%d0%bc%d0%b8%d0%bd%d0%be%d0%bb%d0%be%d0%b3%d0%b8%d1%8f" aria-label="Heading self-link"></a></h3>
<p>Макросы в <em>NewLang</em>, это один или несколько терминов, которые заменяются на другой термин или на целую синтаксическую конструкцию (последовательность лексем).
Макросы являются одновременно и расширением базового синтаксиса языка, при реализации собственных диалектов DSL, и синтаксическим сахаром.</p>
<p>Главная особенность макросов в том, что они позволяют изменять выражения еще до их вычисления во время выполнения.
Раскрытие макросов происходит во время работы <strong>лексера</strong>, что позволяет подменять ими любые другие термины и даже модифицировать сам синтаксис языка.</p>
<p>Поэтому, если перед именем объекта <strong>NewLang</strong> модификатор не указывать (**\**макрос, **$**локальная_переменная или **@**модуль),
то сперва будет производиться поиск объекта среди макросов, потом среди локальных переменных и в последнюю очередь среди модулей (объектов модуля).
За счет этого можно использовать термины без обязательных модификаторов для указания конкретных типов объектов.</p>
<h4 id="определение-макросов">Определение макросов<a class="td-heading-self-link" href="#%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bc%d0%b0%d0%ba%d1%80%d0%be%d1%81%d0%be%d0%b2" aria-label="Heading self-link"></a></h4>
<p>Для определения макросов используется точно такой <a href="https://newlang.net/ops.html">синтаксис</a>, как и для других объектов языка
(применяются операторы «<strong>::=</strong>», «<strong>=</strong>» или «<strong>:=</strong>», соответственно для создания нового объекта, присвоение нового значения уже существующему или для создания объекта / присвоения нового значения объекту не зависимо от его наличия или отсутствия).</p>
<p>В общем виде, определение макроса состоит из трех частей <strong>&lt;<strong>имя макроса</strong>&gt;</strong> <strong>&lt;<strong>оператор создания/присвоения</strong>&gt;</strong> <strong>&lt;<strong>тело макроса</strong>&gt;</strong>  и завершающая точка с запятой &ldquo;<strong>;</strong>&rdquo;.</p>
<h4 id="тело-макроса">Тело макроса<a class="td-heading-self-link" href="#%d1%82%d0%b5%d0%bb%d0%be-%d0%bc%d0%b0%d0%ba%d1%80%d0%be%d1%81%d0%b0" aria-label="Heading self-link"></a></h4>
<p>Телом макроса могут быть корректное выражение языка, последовательность лексем (которые заключается в двойные обратные слеши, т.е. <strong>\\<strong>лексема1 лексема1</strong>\\</strong>) или обычная текстовая строка (обрамленная в тройные обратные слеши, т.е. <strong>\\\</strong> текстовая строка <strong>\\\</strong>).</p>
<p>Для соединения двух лексем в одну (аналог операции ## в препроцессоре С/С++), используется по аналогии синтаксис <strong>##</strong>. Похожий оператор применяется и для обрамления лексемы в кавычки <strong>#</strong>, например, <code>\macro($arg)  := \\ func_ \## \#arg(\#arg) \\;</code>? тогда вызов macro(arg) будет преобразован в <code>func_arg (&quot;arg&quot;)</code>;</p>
<h4 id="имя-макроса">Имя макроса<a class="td-heading-self-link" href="#%d0%b8%d0%bc%d1%8f-%d0%bc%d0%b0%d0%ba%d1%80%d0%be%d1%81%d0%b0" aria-label="Heading self-link"></a></h4>
<p>Именем макроса может быть одиночный идентификатор с префиксом макроса &ldquo;<strong>\</strong>&rdquo; или последовательность из нескольких лексем. Если в качестве имени макроса используется  последовательность лексем, то среди них должен быть как минимум один идентификатор и может присутствовать один или несколько шаблонов.</p>
<p>Шаблон — это специальный идентификатор который при сопоставлении может заменяться любым одиночным термином. С помощью шаблонов производится поиск по образцу и замена заданных последовательностей лексем на тело макроса.</p>
<p>Для указания шаблона в начале идентификатора нужно поставить знак доллара (что соответствует записи имени локальной переменой), т. е. <strong>\\<strong>одна_лексема</strong>\\</strong>, <strong>\\<strong>целых три лексемы</strong>\\</strong> **\\**лексема <em>$шаблон1</em> <em>$шаблон2</em> <strong>\\</strong>.</p>
<p>Макросы считаются одинаковыми, если их идентификаторы равны, количество элементов в их именах совпадает, а идентификаторы и шаблоны располагаются на тех же самых местах.</p>
<h4 id="аргументы-макросов">Аргументы макросов<a class="td-heading-self-link" href="#%d0%b0%d1%80%d0%b3%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b-%d0%bc%d0%b0%d0%ba%d1%80%d0%be%d1%81%d0%be%d0%b2" aria-label="Heading self-link"></a></h4>
<p>Термины или шаблоны в имени макроса могут иметь аргументы, которые указываются в круглых скобках. Переданные аргументы в теле макроса записываются в месте для раскрытия как имя локальной переменой, но перед именем нужно добавить обратный слеш, т.е. <code>\$name</code>.</p>
<p>Произвольное количество параметров у макроса отмечается троеточием &ldquo;&hellip;&rdquo;, а место для вставки этих аргументов отмечается лексемой <strong>$&hellip;</strong>. Если у макроса есть несколько идентификаторов с аргументами, то для вставки аргументов из конкретного идентификатора используется лексема с указанием нужного идентификатора, например, <strong>$name&hellip;</strong>.</p>
<p>Чтобы вставить количество реально переданных аргументов используется лексема <strong>$#</strong>, или с указанием нужного идентификатора, например, <strong>$#name</strong>.</p>
<p><em>Макросы работают с лексемами, которые содержат различную информацию, в том числе и о типе данных, если она указана. Но на текущий момент типы данных в аргументах макросов никак не обрабатываются и это одна из обязательных фич, которая будет реализована в будущем.</em></p>
<h3 id="примеры">Примеры:<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80%d1%8b" aria-label="Heading self-link"></a></h3>
<pre tabindex="0"><code>   \макрос1 := 123;
   \макрос2(arg) := {func( \$arg ); func2(123);};
   \\макрос из(...) лексем\\ := \\ call1(); call2( \$... ); call3() \\;
   \текстовый_макрос := \\\ строка для для лексера \\\;

    # Обычные макросы (тело макроса корректное выражение)
    \macro      := replace();
    \macro2($arg)   := { call( \$arg ); call()};
    # В функцию передается кол-во аргументов и сами аргументы
    \\func name1(...)\\  := name2( \$#, \$name1... ); 

    # Тело макросов из последовательности лексем
    \if(...)    := \\ [ \$... ] --&gt; \\; # Выражение может быть не полным
    \else       := \\ ,[ _ ] --&gt; \\; # Выражение может быть не полным
 
    # Тело макроса из текстовой строки (как в препроцессоре С/С++)
    \macro_str  := \\\ строка - тело макроса \\\; # Строка для лексера
    \macro($arg)  := \\\ func_ \## \#arg(\#arg)\\\; # macro(arg) -&gt; func_arg (&#34;arg&#34;)
</code></pre><h2 id="какие-возможности-это-дает">Какие возможности это дает?<a class="td-heading-self-link" href="#%d0%ba%d0%b0%d0%ba%d0%b8%d0%b5-%d0%b2%d0%be%d0%b7%d0%bc%d0%be%d0%b6%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d1%8d%d1%82%d0%be-%d0%b4%d0%b0%d0%b5%d1%82" aria-label="Heading self-link"></a></h2>
<p>Таким образом можно определить макросы в следующих комбинациях:</p>
<pre tabindex="0"><code>№ п/п        Имя макроса                     Тело макроса
----------------------------------------------------------------
   1.       \идентификатор                     выражение
   2.       \идентификатор             \\лексема1 лексема2\\
   3.       \идентификатор             \\\строка для лексера\\\
   4.   \\лексема1 лексема2\\                выражение
   5.   \\лексема1 лексема2\\        \\лексема1 лексема2\\
   6.   \\лексема1 лексема2\\        \\\строка для лексера\\\
</code></pre><p>Каждая из перечисленных выше комбинации имеет свои свойства и ограничения:</p>
<ol>
<li>
<p>Классическая замена одного термина на другой термин или целое выражение. Однократно обрабатывается лексером и парсером при определении. Выражение в теле макроса должно быть корректным с точки зрения синтаксиса и при наличии в нем ошибок, сообщение об этом формируется сразу, еще при определении макроса.</p>
</li>
<li>
<p>Классическая замена одного термина на последовательности лексем, в том числе и не полные синтаксические конструкции. Однократно обрабатывается лексером при определении макроса. Тело макроса анализируется парсером при его использовании, поэтому возможные синтаксические ошибки будут замечены только при раскрытии макроса.</p>
</li>
<li>
<p>Классическая замена одного термина на текстовую строку, которая подается на вход лексера. Однократно обрабатывается лексером только имя макроса при его определении, что позволяет модифицировать тело макроса и изменять/комбинировать/модифицировать лексемы до их подачи в анализатор. Синтаксические ошибки будут замечены только при раскрытии макроса.</p>
</li>
</ol>
<p>4, 5 и 6. Замена последовательности из нескольких лексем (шаблонов) на выражение, последовательность лексем или текстовую строку соответственно.</p>
<h2 id="назначение-и-примеры-использования">Назначение и примеры использования<a class="td-heading-self-link" href="#%d0%bd%d0%b0%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b8-%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80%d1%8b-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f" aria-label="Heading self-link"></a></h2>
<p>Макросы используются и для преобразования базового синтаксиса <em>NewLang</em> в более привычный синтаксис на основе ключевых слов, так как такой текст гораздо легче воспринимается при последующем чтении исходного кода.</p>
<p>Если перед именем объекта NewLang модификатор не указан (**\**макрос, **$**локальная_переменная или **@**модуль), то сперва ищется имя макроса, потом имя локальной переменной и в последнюю очередь имя модуля (объекта модуля). За счет этого получается определять синтаксис DSL  в привычной записи без обязательных префиксов у разных типов объектов.</p>
<p>Например, запись условного оператора на основном синтаксисе <strong>NewLang</strong>:</p>
<pre tabindex="0"><code>    [condition] --&gt; {
        ...
    } [ condition2 ] --&gt; {
        ...
    } [ _ ] {
        ...
    };

# С помощью макросов
    \if(...)    := \\ [ \$... ]--&gt; \\;
    \elif(...)  := \\ ,[ \$... ]--&gt; \\;
    \else       := \\ ,[ _ ]--&gt; \\;

# Превращается в классическую запись
    if( condition ){
        ...
    } elif( condition2 ) {
        ...
    } else {
        ...
    };
</code></pre><p>Или  цикл до 5:</p>
<pre tabindex="0"><code>count:=1;
[ 1 ] &lt;-&gt; {
    [count&gt;5] --&gt; {
        ++ 42 ++;
    };
    count+=1;
};
</code></pre><p>будет выглядеть более привычно с использованием соответствующих макросов:</p>
<pre tabindex="0"><code>\while(...) := \\ [ \$... ] &lt;-&gt; \\;
\return(...) := ++ \$... ++;
\true := 1;

count := 1;
while( true ) {
    if( count &gt; 5 ) {
        return 42;
    };
    count += 1;
};
</code></pre><h3 id="удаление-макросов">Удаление макросов<a class="td-heading-self-link" href="#%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bc%d0%b0%d0%ba%d1%80%d0%be%d1%81%d0%be%d0%b2" aria-label="Heading self-link"></a></h3>
<p>Для удаления макроса нужно присвоить ему пустую последовательность лексем <code>\macro_str  := \\\\;</code>. Так же для удаления можно использовать специальный синтаксис: <code>\\\\ name \\\\;</code> или <code>\\\\ \\два термина\\ \\\\;</code>, т.е. указать имя макроса между четырьмя обратными слешами.</p>
<p>Необходимость использования отдельной синтаксической конструкции для удаления макросов вызвана тем, что имена макросов обрабатываются лексером еще до этапа анализа в парсере.</p>
<h2 id="в-чем-профит">В чем профит?<a class="td-heading-self-link" href="#%d0%b2-%d1%87%d0%b5%d0%bc-%d0%bf%d1%80%d0%be%d1%84%d0%b8%d1%82" aria-label="Heading self-link"></a></h2>
<ol>
<li>Базовый синтаксис языка можно разбавлять дополнительными ключевыми словами и превратить его в привычный «keyword-based».</li>
<li>Определение макросов соответствует лексике языка, а сами макросы обрабатываются как обычные объекты.</li>
<li>Простота анализа исходного кода и его отладки.</li>
<li>Использование терминов DSL и приемов метапрограммирование можно сделать явным, например, всегда перед именем макроса указывать префикс. В этом случае компилятор будет однозначно знать, что требуется выполнить раскрытие макроса.</li>
<li>Несмотря на то, что синтаксис языка на свой страх и риск можно значительно модифицировать, но это можно сделать только в рамках определенные ограничений (AST нельзя модифицировать напрямую), что не позволяется очень сильно разгуляться и, например, обрушить или подвесить компилятор.</li>
<li>Несмотря на очень большие возможности по модификации синтаксиса, получается очень простая, быстрая и однозначная реализация. А это положительно сказывается на скорости анализа исходников, детектирования и обработки возможных ошибок и одновременно является разумным компромиссом между сложностью реализации данного функционала и  возможностями определения собственных диалектов DSL.</li>
<li>При желании есть куда развивать возможности метапрограммирования. В будущем можно добавить сопоставление шаблона с образцом (например, на основе регулярных выражений), сделать параметризацию строки для генерации синтаксиса в теле макроса, в том числе и в рантайме, и много других разных способов изящно выстрелить себе в ногу или ногу своего товарища.</li>
</ol>
<h2 id="заключение">Заключение<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d0%b5" aria-label="Heading self-link"></a></h2>
<p>Буду благодарен за любую обратную связь по данной реализации макросов. И дважды благодарен, если кроме критики будут высказаны еще и предложения по её улучшению и доработкам, если какой-то момент был упущен.</p>
<p><a href="https://habr.com/ru/companies/timeweb/articles/719332/">Ссылка на первую публикаци</a></p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-2ef4658740cd35c23eb19d8fbefa35dd">Релиз языка программрования NewLang 0.3</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-11-07" class="text-muted">07.11.2022</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/langs.jpeg"></p>


<div class="pageinfo pageinfo-primary">
<p>Внимание!!!</p>
<p>Данная статья содержит описание синтаксиса NewLnag предыдущей версии.</p>
<p>Актуальную версию синтаксиса языка можно посмотреть <a href="/ru/docs/">тут</a>.</p>

</div>

<p>NewLang — это язык программирования высокого уровня общего назначения. Основной особенностью языка является простой, логичный и не противоречивый синтаксис, который основан на строгой системе грамматических правил. За счет использования макросов, синтаксис языка легко расширяется до более привычного вида на основе ключевых слов.</p>
<p>NewLang находится в процессе активного развития. Это третий публичный <a href="https://github.com/rsashka/newlang/releases/tag/v0.3.0">релиз</a> в который добавлены новые существенные возможности по сравнению с предыдущей версией.</p>
<h2 id="зачем-нужен-newlang">Зачем нужен <em>NewLang</em>?<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%87%d0%b5%d0%bc-%d0%bd%d1%83%d0%b6%d0%b5%d0%bd-newlang" aria-label="Heading self-link"></a></h2>
<p>У всех современных языков программирования происходит постоянное развитие (усложнение) синтаксиса по мере выхода новых версий. Это является своего рода платой за появление новых возможностей и воспринимается пользователями как естественное явление.</p>
<p>Но одновременно является и серьезной проблемой, так как с выходом версий добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки и поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.</p>
<p>У <em>NewLang</em> сложность языковых конструкций ограничена естественным образом за счет разделения синтаксиса языка на две части - это упрощает его изучение и использование.</p>
<p><em>Основной синтаксис</em> — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, который основан не на зарезервированных ключевых словах, а на системе строгих <a href="/ru/docs/syntax/">грамматических правил</a>. Имеется возможность расширения основного синтаксиса за счет использования макросов. <em>Расширенный синтаксис</em> — программные вставки на языке реализации (С/С++), когда основного синтаксиса становится недостаточно.</p>
<p>Еще одно неудобство современных языков в том, что большинство из них были созданы до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек. Это же касается и вычислений с неограниченной точностью, которые так же требуют применения дополнительных библиотечных функций.</p>
<p>У <em>NewLang</em> тензорные вычисления и рациональные числа неограниченной точности доступны «из коробки». Они поддерживаются на уровне синтаксиса для записи литералов соответствующих типов, а простые арифметические типы данных являются скалярами (тензорами нулевой размерности). Реализация тензорных вычислений сделана на базе библиотеки <a href="https://pytorch.org/">libtorch</a>, а рациональные числа с использованием <a href="https://github.com/openssl/openssl/blob/master/crypto/bn/README.pod">OpenSSL</a>.</p>
<h2 id="новые-глобальные-фичи-и-изменения-в-синтаксисе">Новые глобальные фичи и изменения в синтаксисе:<a class="td-heading-self-link" href="#%d0%bd%d0%be%d0%b2%d1%8b%d0%b5-%d0%b3%d0%bb%d0%be%d0%b1%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d1%84%d0%b8%d1%87%d0%b8-%d0%b8-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f-%d0%b2-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81%d0%b5" aria-label="Heading self-link"></a></h2>
<h3 id="простые-чистые-функции-удалены">Простые чистые функции удалены<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d1%81%d1%82%d1%8b%d0%b5-%d1%87%d0%b8%d1%81%d1%82%d1%8b%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8-%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d1%8b" aria-label="Heading self-link"></a></h3>
<p>Раньше я пытался использовать синтаксис предикатов из Пролога, в котором проверки условий записываются через запятую. Но эта идея оказалась провальной, а сами операторы просто ужасными (тестировал разные варианты, но каждый раз получал много отрицательных отзывов), поэтому сейчас решил полностью от них отказаться.</p>
<p>Они получались не только сложными для восприятия, но и по факту не нужными, так как легко заменялись обычной функцией с комбинации обычных логических операций.</p>
<h3 id="зафиксирован-синтаксис-операторов-проверки-условияrudocsopsif-и-цикловrudocsopswhile">Зафиксирован синтаксис операторов проверки <a href="/ru/docs/ops/if/">условия</a> и <a href="/ru/docs/ops/while/">циклов</a>.<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%84%d0%b8%d0%ba%d1%81%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81-%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d0%be%d0%b2-%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b8-%d1%83%d1%81%d0%bb%d0%be%d0%b2%d0%b8%d1%8frudocsopsif-%d0%b8-%d1%86%d0%b8%d0%ba%d0%bb%d0%be%d0%b2rudocsopswhile" aria-label="Heading self-link"></a></h3>
<p>Изменен и упрощен синтаксис операторов проверки условия (импликации) и цикла, для которых оставлено только по одному варианту. Проверка условия записывается в виде оператора математического следования  <strong>&ndash;&gt;</strong>, а цикл с помощью оператора <strong>&lt;-&gt;</strong>.</p>
<p>Но для упрощения записи можно пользоваться макросами, тогда в этом случае операции проверки условий и циклы превращаются в классические</p>
<pre tabindex="0"><code>\if(...){
    ...
} \elif(...) {
   ...
} \else {
   ...
};
</code></pre><p>или</p>
<pre tabindex="0"><code> \while( ... ){ 
     ...
}; 
</code></pre><h3 id="конструкция-else-у-операторов-цикла">Конструкция else у операторов цикла<a class="td-heading-self-link" href="#%d0%ba%d0%be%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%86%d0%b8%d1%8f-else-%d1%83-%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d0%be%d0%b2-%d1%86%d0%b8%d0%ba%d0%bb%d0%b0" aria-label="Heading self-link"></a></h3>
<p>Теперь оператор цикла <strong>while</strong> поддерживает конструкцию <a href="/ru/docs/ops/while/"><strong>else</strong></a>, которая выполняется если условие входа в цикл не было выполнено. <em>Это поведение отличается от аналогичных конструкций  в языке Python, у которого секция <strong>else</strong> выполняется всегда, кроме прерывания цикла по break.</em></p>
<p>Ветка <strong>else</strong> у оператора цикла записывается так же как и ветка иначе в условном операторе, т. е.</p>
<pre tabindex="0"><code>[ cond ] &lt;-&gt; {
   ...
}, [_] --&gt; {
   ...
};
</code></pre><p>Или тоже самое, но с использованием макросов:</p>
<pre tabindex="0"><code>\while(cond) {
   ...
} \else {
   ...
};
</code></pre><h3 id="пространства-имен">Пространства имен<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d1%81%d1%82%d1%80%d0%b0%d0%bd%d1%81%d1%82%d0%b2%d0%b0-%d0%b8%d0%bc%d0%b5%d0%bd" aria-label="Heading self-link"></a></h3>
<p>В синтаксис NewLang добавлены <a href="/ru/docs/syntax/namespace/">пространства имен</a>, в стиле очень похожим на С++. Имена разделяются двойным двоеточием, а для определение пространства имен, его нужно указать перед открывающейся фигурной скобкой.</p>
<pre tabindex="0"><code>ns {
    name {
        var := 0; # Имя переменной будет ns::name::var
        ::var := 1; # Переменная из глобального пространства имен
    }
}
</code></pre><h3 id="программные-модули">Программные модули<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%bd%d1%8b%d0%b5-%d0%bc%d0%be%d0%b4%d1%83%d0%bb%d0%b8" aria-label="Heading self-link"></a></h3>
<p>Реализована концепция программных модулей - которая повторяет концепцию иерархического расположения файлов в структуре каталогов файловой системы, как в языках Python и Java.</p>
<p>Имя модуля начинается на префикс <strong>@</strong>, а структура каталогов указывается через точку. Причем концепции программных модулей и пространства имен объединены, и полное имя переменой из предыдущего абзаца будет <code>@root.dir.module::ns::name::var</code>, где <strong>root</strong> и <strong>dir</strong> это каталоги в файловой системе, а <strong>module</strong> — имя файла.</p>
<h3 id="объектно-ориентированное-программирование">Объектно ориентированное программирование<a class="td-heading-self-link" href="#%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%bd%d0%be-%d0%be%d1%80%d0%b8%d0%b5%d0%bd%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d0%be%d0%b5-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5" aria-label="Heading self-link"></a></h3>
<p>Реализована часть концепции ООП и добавлена поддержка <a href="/ru/docs/types/class/">определения классов</a> и их наследование, которая сейчас выглядит следующим образом:</p>
<pre tabindex="0"><code>:NewClass := :Class() { #  Новый тип (класс)
    field := 1;
    method() := {};
};
obj := :NewClass(); # Экземпляр класса
</code></pre><p>Неожиданно для самого себя понял, что имея полный набор вариантов проверок при создании объектов (<strong>::=</strong> - создать новый объект, <strong>:=</strong> - создать новый или присвоить значение существующему, <strong>=</strong> - только присвоить значение, а если объект не существует будет ошибка), концепция переопределения наследуемых функций не требует вообще никаких ключевых слов:</p>
<pre tabindex="0"><code>:NewClass2 := :NewClass() { # Новый класс на базе существующего
    field ::= 2; # Будет ошибка, т. к. поле field уже есть в базовом классе
    method() = {}; # Аналог override, т.к. method должен существовать в базовом классе
};
</code></pre><h3 id="прерывания-возврат-и-обработка-ошибок">Прерывания, возврат и обработка ошибок<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%b5%d1%80%d1%8b%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%b2%d0%be%d0%b7%d0%b2%d1%80%d0%b0%d1%82-%d0%b8-%d0%be%d0%b1%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b0-%d0%be%d1%88%d0%b8%d0%b1%d0%be%d0%ba" aria-label="Heading self-link"></a></h3>
<p>Изменена, а точнее полностью переделана идеология возвратов из функций и обработки ошибок.
Теперь она чем-то похожа на подход, примененный в Ruby. Любая последовательность команд заключенные в фигурные скобки (в том числе тело функции), рассматривается как блок кода у которого нет специального оператора аналога <strong>return</strong>, который возвращает какое либо значение.
Просто любой блок кода всегда возвращает последнее вычисленное значение (это чем то похоже на оператор «запятая» в языках C/C++).</p>
<p>Для того, чтобы прервать выполнение кода используются две разные команды - прерывания, которые условно можно назвать <em>положительным</em> и <em>отрицательным</em> результатом. Что примерно соответствует семантике их записи.
&ldquo;Отрицательное&rdquo; прерывание записывается в виде двух минусов, а &ldquo;положительное&rdquo; прерывание в виде двух плюсов, т.е. <strong>--</strong> или <strong>++</strong>.</p>
<p>По умолчанию данные операции возвращают пустое значение. Чтобы прерывание вернуло результат, возвращаемые данные нужно записывать между парой соответствующих символов,
т.е. <strong>--</strong> 100 <strong>--</strong>, что является близким аналогом оператора <code>return 100;</code> в других языках программирования, а <strong>++</strong>«Строка»<strong>++</strong> - аналогом <code>return «Строка»;</code>.</p>
<p>Хотя более точным аналогом этих операторов будет все таки не <strong>return</strong>, а <strong>throw</strong>,
т.к. эти команды не только прерывают выполнение последовательности команд в блоке, но их еще можно «ловить».
Для этого используется блок кода с соответствующей семантикой, <strong>{+</strong> … <strong>+}</strong> - блок кода,
который перехватывает положительные прерывания и <strong>{-</strong> … <strong>-}</strong> - блок кода, который перехватывает прерывания, созданные операторами <strong>&ndash;</strong>.</p>
<p>Подобная концепция (в явном виде не разделять возвраты из функций и обработку исключений),
хоть и выглядит немного необычной, но позволяет реализовывать несколько очень полезных финтов,
которые сложно реализуемые в обычных языках программирования.</p>
<p>Например, возврат из нескольких вложенных функций без необходимости обрабатывать результат возврата каждой из них.
В этом примере функция <em>Test</em> перехватывает &ldquo;положительные&rdquo; прерывания из вложенных функций:</p>
<pre tabindex="0"><code>    Test0(arg) := { \if($arg==0) \return(&#34;DONE - 0&#34;); «FAIL» };
    Test1(arg) := { \if($arg==1) \return(&#34;DONE - 1&#34;); Test0($arg); };
    Test(arg) := {+ \if($arg &gt;= 0) Test1($arg); $arg; +};

    Test(0); # Вернет «DONE — 0» возврат из вложенной функции Test0
    Test(1); # Вернет «DONE — 1» возврат из вложенной функции Test1
    Test(2); # Вернет «FAIL» возврат из вложенной функции Test0
    Test(-2); # Вернет -2 — возврат из функции Test
</code></pre><p>Есть еще блок <code>{* … *}</code>, который перехватывает оба типа прерываний. Такой блок кода поддерживает типизацию возвращаемого значения, что позволяет в явном виде указывать типы данных, которые нужно перехватывать.
Например, <code>{* ... *} :Type1</code> — будет перехвачено прерывание вида <code>++ :Type1 ++</code> или <code>--:Type1--</code>, что позволяет очень гибко формировать логику работы программы.</p>
<p>Блоки кода с перехватом исключений также поддерживают оператор иначе (<em>\else</em>) который, по аналогии с оператором <em>\else</em> в циклах, выполняется только тогда, если прерывания не произошло.</p>
<p>Можно указать сразу несколько типов, которые нужно перехватывать:</p>
<pre tabindex="0"><code>    {* 
        ....
    *} &lt;:Type1, :Type2, :Type3&gt;;
</code></pre><h2 id="бинарная-сборка-под-windws">Бинарная сборка под Windws:<a class="td-heading-self-link" href="#%d0%b1%d0%b8%d0%bd%d0%b0%d1%80%d0%bd%d0%b0%d1%8f-%d1%81%d0%b1%d0%be%d1%80%d0%ba%d0%b0-%d0%bf%d0%be%d0%b4-windws" aria-label="Heading self-link"></a></h2>
<p>В текущем релизе версия clang повышена 15, а вызовы нативных функций опять реализованы с помощью libffi, что в итоге позволило собрать бинарную сборку не только под Linux, но и под Windows. И теперь чтобы поиграться с REPL read-eval-print loop можно скачать уже готовый бинарник.</p>
<h2 id="подробная-информация-о-языке">Подробная информация о языке:<a class="td-heading-self-link" href="#%d0%bf%d0%be%d0%b4%d1%80%d0%be%d0%b1%d0%bd%d0%b0%d1%8f-%d0%b8%d0%bd%d1%84%d0%be%d1%80%d0%bc%d0%b0%d1%86%d0%b8%d1%8f-%d0%be-%d1%8f%d0%b7%d1%8b%d0%ba%d0%b5" aria-label="Heading self-link"></a></h2>
<ul>
<li><a href="/ru/docs/syntax/">Синтаксис <em>NewLang</em></a></li>
<li><a href="/ru/docs/types/">Подробное описание типов данных</a></li>
<li><a href="/ru/docs/ops/">Операторы и управляющие конструкции</a></li>
<li><a href="/ru/docs/_print/">Вся документация по <em>NewLang</em> на одной странице</a></li>
</ul>
<h2 id="обратная-связь">Обратная связь<a class="td-heading-self-link" href="#%d0%be%d0%b1%d1%80%d0%b0%d1%82%d0%bd%d0%b0%d1%8f-%d1%81%d0%b2%d1%8f%d0%b7%d1%8c" aria-label="Heading self-link"></a></h2>
<p>Если у вас появятся предложения по развитию нового или улучшению уже существующего функционала <em>NewLang</em>, <a href="https://github.com/rsashka/newlang/discussions">пишите</a>.</p>
<h2 id="примеры-кода">Примеры кода<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80%d1%8b-%d0%ba%d0%be%d0%b4%d0%b0" aria-label="Heading self-link"></a></h2>
<pre tabindex="0"><code>#!../output/nlc --eval
# Определение функции hello
hello(str) := { 
    # Импорт стандартной C функции
    printf := :Pointer(&#39;printf(format:FmtChar, ...):Int32&#39;);
    # Вызов C функции с проверкой типов аргументов по строке формата
    printf(&#39;%s&#39;, $str);  
    # Возврат значения из функции hello
     $str;
};

hello(&#39;Привет, мир!&#39;); # Вызвать функцию&lt;/code&gt;
</code></pre><p>Вывод (первая строка выводится с помощью printf, а вторая — возвращаемое значение функции hello):</p>
<pre tabindex="0"><code>    Привет, мир!
    Привет, мир!
</code></pre><p>Пример скрипта для вычисления факториала 1000</p>
<pre tabindex="0"><code>#!../output/nlc --eval

fact := 1\1;  # Рациональное число без ограничения точности
mult := 1000..1..-1?; # Сделать из диапазона итератор для множителей от 1000 до 2
[mult ?!] &lt;-&gt; {      # Цикл, пока не закончатся данные итератора
    # Получить текущий множитель и перейти на следующий элемент итератора
    fact *= mult !; 
};
fact # Вывести итоговый результат
</code></pre><p>Вывод:</p>
<spoiler title="Много цифр">
402387260077093773543702433923003985719374864210714632543799910429938512398629
020592044208486969404800479988610197196058631666872994808558901323829669944590
997424504087073759918823627727188732519779505950995276120874975462497043601418
278094646496291056393887437886487337119181045825783647849977012476632889835955
735432513185323958463075557409114262417474349347553428646576611667797396668820
291207379143853719588249808126867838374559731746136085379534524221586593201928
090878297308431392844403281231558611036976801357304216168747609675871348312025
478589320767169132448426236131412508780208000261683151027341827977704784635868
170164365024153691398281264810213092761244896359928705114964975419909342221566
832572080821333186116811553615836546984046708975602900950537616475847728421889
679646244945160765353408198901385442487984959953319101723355556602139450399736
280750137837615307127761926849034352625200015888535147331611702103968175921510
907788019393178114194545257223865541461062892187960223838971476088506276862967
146674697562911234082439208160153780889893964518263243671616762179168909779911
903754031274622289988005195444414282012187361745992642956581746628302955570299
024324153181617210465832036786906117260158783520751516284225540265170483304226
143974286933061690897968482590125458327168226458066526769958652682272807075781
391858178889652208164348344825993266043367660176999612831860788386150279465955
131156552036093988180612138558600301435694527224206344631797460594682573103790
084024432438465657245014402821885252470935190620929023136493273497565513958720
559654228749774011413346962715422845862377387538230483865688976461927383814900
140767310446640259899490222221765904339901886018566526485061799702356193897017
860040811889729918311021171229845901641921068884387121855646124960798722908519
296819372388642614839657382291123125024186649353143970137428531926649875337218
940694281434118520158014123344828015051399694290153483077644569099073152433278
288269864602789864321139083506217095002597389863554277196742822248757586765752
344220207573630569498825087968928162753848863396909959826280956121450994871701
244516461260379029309120889086942028510640182154399457156805941872748998094254
742173582401063677404595741785160829230135358081840096996372524230560855903700
624271243416909004153690105933983835777939410970027753472000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000\1
</spoiler>
<h2 id="как-посмотреть">Как посмотреть?<a class="td-heading-self-link" href="#%d0%ba%d0%b0%d0%ba-%d0%bf%d0%be%d1%81%d0%bc%d0%be%d1%82%d1%80%d0%b5%d1%82%d1%8c" aria-label="Heading self-link"></a></h2>
<ul>
<li><a href="https://github.com/rsashka/newlang/releases/download/v0.3.0/nlc_win_64.zip">Бинарная сборка и тесты под Windows</a></li>
<li><a href="https://github.com/rsashka/newlang/releases/download/v0.3.0/nlc_lin_64.tar.xz">Бинарная сборка и тесты под Ubuntu</a></li>
<li>Для запуска бинарных сборок потребуются разделяемые библиотеки libLLVM-15 и libtorch (<a href="https://github.com/rsashka/newlang/releases/download/v0.3.0/nlc_dll.zip">архив с библиотеками для Windows</a>), (<a href="https://github.com/rsashka/newlang/releases/download/v0.3.0/nlc_so.tar.xz">архив с библиотеками для Ubuntu</a>).</li>
<li>Так же все можно собрать напрямую из исходников по инструкции в <a href="https://github.com/rsashka/newlang">репозитории</a></li>
</ul>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-18c34abab4e3c18b54b60e0007679e6d">Релиз языка программрования NewLang 0.2</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-08-12" class="text-muted">12.08.2022</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/langs.jpeg"></p>


<div class="pageinfo pageinfo-primary">
<p>Внимание!!!</p>
<p>Данная статья содержит описание синтаксиса NewLnag предыдущей версии.</p>
<p>Актуальную версию синтаксиса языка можно посмотреть <a href="/ru/docs/">тут</a>.</p>

</div>

<p><em>NewLang</em> - это язык программирования высокого уровня в котором можно сочетать стандартные алгоритмические конструкции с декларативным программированием и тензорными вычислениями для задач машинного обучения.</p>
<p>Основной особенностью языка является простой, логичный и не противоречивый синтаксис, который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил с использованием знаков препинания (в список которых входят и операторы языка).</p>
<p><em>NewLang</em> находится в процессе активного развития и это второй публичный релиз в котором добавлены существенные новые возможности и произошли некоторые изменения по сравнению с <a href="https://habr.com/ru/company/timeweb/blog/673176/">предыдущей версией</a>.</p>
<h2 id="особенности-языка">Особенности языка:<a class="td-heading-self-link" href="#%d0%be%d1%81%d0%be%d0%b1%d0%b5%d0%bd%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d1%8f%d0%b7%d1%8b%d0%ba%d0%b0" aria-label="Heading self-link"></a></h2>
<ul>
<li>Возможность работы как в режиме интерпретатора, так и компилятора*.</li>
<li>Динамическая и статическая типизация с возможностью указания типов в явном виде.</li>
<li>Статическая типизация является условно строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных, например, целое число может быть автоматически преобразовано в вещественное или рациональное, но не наоборот).</li>
<li>Автоматическое управление памятью.</li>
<li>ООП в виде явного наследования классов и «утиная» типизация.</li>
<li>На уровне синтаксиса поддержка нескольких типов функций (обычные и чистые функции без побочных эффектов).</li>
<li>Необязательные и именованные параметры функций.</li>
<li>Возможны вставки кода на языке реализации (С/С++)*.</li>
<li>Простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++).</li>
<li>Имеется REPL read-eval-print loop — «цикл: чтение — вычисление — вывод».</li>
</ul>
<h2 id="новые-глобальные-фичи">Новые глобальные фичи:<a class="td-heading-self-link" href="#%d0%bd%d0%be%d0%b2%d1%8b%d0%b5-%d0%b3%d0%bb%d0%be%d0%b1%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d1%84%d0%b8%d1%87%d0%b8" aria-label="Heading self-link"></a></h2>
<ul>
<li>Добавлены макросы. Теперь можно делать собственные языковые диалекты и использовать более привычную запись алгоритмических конструкций с использование ключевых слов.
Например, цикл</li>
</ul>
<pre tabindex="0"><code>[ cond ] &lt;-&gt; {
      тело цикла
}; 
</code></pre><p>можно записать в более привычный нотации</p>
<pre tabindex="0"><code>\while (cond) {
      тело цикла
};
</code></pre><ul>
<li>Добавлены итераторы для перебора элементов словарей или для запросов к другим контейнерам (например, к базам данных). На уровне базового синтаксиса поддерживается фильтрация данный, включая функциональный аналог LINQ за счет применения функций обратного вызова в качестве условия фильтра.</li>
<li>Добавлен новый тип данных — рациональные числа с неограниченной точностью. Они записываются в виде обыкновенной дроби, у которой разделитель бекслеш, например единицу  можно записать <code>1\1</code>, а число 0.5 как <code>1\2</code>.</li>
<li>Реализован оператор распаковки словаря <strong>…</strong> (многоточие), который можно использовать чтобы передать несколько аргументов при вызове функции или для присвоения значения сразу нескольким переменным.</li>
<li>Теперь оператор присвоения поддерживает установку значений сразу нескольким переменным. С правой стороны от оператора присвоения может находится одно или несколько значений или оператор распаковки словаря. Причем словарь может быть указан и с левой стороны от оператора присвоения и таким образом можно записать самый простой способ перебора всех его элементов, когда в цикле первый элемент словаря сохраняется в переменную <em>item</em>, а из самого словаря удаляется:</li>
</ul>
<pre tabindex="0"><code>[ dict ] &lt;-&gt; {  
      item, dict := ... dict; 
};
</code></pre><h2 id="изменения-в-синтаксисе">Изменения в синтаксисе:<a class="td-heading-self-link" href="#%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f-%d0%b2-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81%d0%b5" aria-label="Heading self-link"></a></h2>
<ul>
<li>Изменена запись циклов. Вместо двух разных типов с предусловием и постусловие, теперь используется единая форма записи, а тип цикла определяется взаимным расположением условия и его тела.</li>
<li>Изменены названия арифметических и некоторых других типов данных на более логичные. В именах арифметических типов теперь указан их размер (Int8, Int16 … Float32, Float64 и т.д.).</li>
<li>Многострочные комментарии стали вложенными</li>
</ul>
<h2 id="подробная-информация-о-языке">Подробная информация о языке:<a class="td-heading-self-link" href="#%d0%bf%d0%be%d0%b4%d1%80%d0%be%d0%b1%d0%bd%d0%b0%d1%8f-%d0%b8%d0%bd%d1%84%d0%be%d1%80%d0%bc%d0%b0%d1%86%d0%b8%d1%8f-%d0%be-%d1%8f%d0%b7%d1%8b%d0%ba%d0%b5" aria-label="Heading self-link"></a></h2>
<ul>
<li><a href="/ru/docs/syntax/">Основные правила синтаксиса:</a></li>
<li><a href="/ru/docs/types/">Встроенные типы данных:</a></li>
<li><a href="/ru/docs/ops/">Операторы и управляющие конструкции:</a></li>
</ul>
<h2 id="примеры-кода">Примеры кода<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80%d1%8b-%d0%ba%d0%be%d0%b4%d0%b0" aria-label="Heading self-link"></a></h2>
<spoiler title="Привет, мир!">
```
#!../output/nlc --eval
<h1 id="определение-функции-hello">Определение функции hello<a class="td-heading-self-link" href="#%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8-hello" aria-label="Heading self-link"></a></h1>
<p>hello(str) := {</p>
<pre><code># Импорт стандартной C функции
printf := :Pointer('printf(format:FmtChar, ...):Int32');

# Вызов C функции с проверкой типов аргументов по строке формата
printf('%s', $str);  

# Возврат значения из функции hello
 $str;
</code></pre>
<p>};</p>
<p>hello(&lsquo;Привет, мир!&rsquo;); # Вызвать функцию</p>
<pre tabindex="0"><code>Вывод (первая строка выводится с помощью printf, а вторая - возвращаемое значение функции hello):
</code></pre><pre><code>Привет, мир!
Привет, мир!
</code></pre>
<pre tabindex="0"><code class="language-</spoiler>" data-lang="</spoiler>">
&lt;spoiler title=&#34;Пример скрипта для вычисления факториала 1000&#34;&gt;
</code></pre><p>#!../output/nlc &ndash;eval</p>
<p>@fact := 1\1;  # Рациональное число без ограничения точности
@mult := 1000..1..-1?; # Сделать из диапазона итератор для множителей от 1000 до 2
[mult ?!] &lt;-&gt; {      # Цикл, пока не закончатся данные итератора
# Получить текущий множитель и перейти на следующий элемент итератора
fact *= mult !;
};
fact # Вывести итоговый результат</p>
<pre tabindex="0"><code>Вывод:
</code></pre><p>402387260077093773543702433923003985719374864210714632543799910429938512398629
020592044208486969404800479988610197196058631666872994808558901323829669944590
997424504087073759918823627727188732519779505950995276120874975462497043601418
278094646496291056393887437886487337119181045825783647849977012476632889835955
735432513185323958463075557409114262417474349347553428646576611667797396668820
291207379143853719588249808126867838374559731746136085379534524221586593201928
090878297308431392844403281231558611036976801357304216168747609675871348312025
478589320767169132448426236131412508780208000261683151027341827977704784635868
170164365024153691398281264810213092761244896359928705114964975419909342221566
832572080821333186116811553615836546984046708975602900950537616475847728421889
679646244945160765353408198901385442487984959953319101723355556602139450399736
280750137837615307127761926849034352625200015888535147331611702103968175921510
907788019393178114194545257223865541461062892187960223838971476088506276862967
146674697562911234082439208160153780889893964518263243671616762179168909779911
903754031274622289988005195444414282012187361745992642956581746628302955570299
024324153181617210465832036786906117260158783520751516284225540265170483304226
143974286933061690897968482590125458327168226458066526769958652682272807075781
391858178889652208164348344825993266043367660176999612831860788386150279465955
131156552036093988180612138558600301435694527224206344631797460594682573103790
084024432438465657245014402821885252470935190620929023136493273497565513958720
559654228749774011413346962715422845862377387538230483865688976461927383814900
140767310446640259899490222221765904339901886018566526485061799702356193897017
860040811889729918311021171229845901641921068884387121855646124960798722908519
296819372388642614839657382291123125024186649353143970137428531926649875337218
940694281434118520158014123344828015051399694290153483077644569099073152433278
288269864602789864321139083506217095002597389863554277196742822248757586765752
344220207573630569498825087968928162753848863396909959826280956121450994871701
244516461260379029309120889086942028510640182154399457156805941872748998094254
742173582401063677404595741785160829230135358081840096996372524230560855903700
624271243416909004153690105933983835777939410970027753472000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000\1</p>
<pre tabindex="0"><code class="language-</spoiler>" data-lang="</spoiler>">
## Как посмотреть?
- [Загрузить собранный REPL и тесты (пока только под Ubuntu)](https://github.com/rsashka/newlang/releases/download/v0.2.0/nlc_bin.tar.xz)
- Для запуска бинарных файлов потребуются разделяемые библиотеки libLLVM-13 и libtorch: [архив только с нужными библиотеками](https://github.com/rsashka/newlang/releases/download/v0.2.0/nlc_so.tar.xz).
- Так же все можно собрать напрямую из исходников по инструкции в [репозитории](https://github.com/rsashka/newlang)
</code></pre>
</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-45137b7a0f14224461d02abf99b62c02">Релиз языка программрования NewLang</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-06-24" class="text-muted">24.06.2022</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/langs.jpeg"></p>


<div class="pageinfo pageinfo-primary">
<p>Внимание!!!</p>
<p>Данная статья содержит описание синтаксиса NewLnag предыдущей версии.</p>
<p>Актуальную версию синтаксиса языка можно посмотреть <a href="/ru/docs/">тут</a>.</p>

</div>

<p><strong>NewLang</strong> - это язык программирования высокого уровня, в котором можно сочетать стандартные алгоритмические конструкции с декларативным программированием и тензорными вычислениями для задач машинного обучения.</p>
<p>Основной особенностью языка является простой, логичный и не противоречивый синтаксис, который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил с использованием знаков препинания (в список которых входят и операторы языка).</p>
<p>Новое по сравнению с <a href="https://habr.com/ru/company/timeweb/blog/651999/">прошлым выпуском</a>:</p>
<ul>
<li>Реализованы все основные алгоритмические конструкции: проверка условий, различные варианты циклов, сравнение по образцу, прерывание последовательности команд и возврат данных, обработка ошибок и т.д.</li>
<li>Переработан основной синтаксис для отдельных языковых конструкций.</li>
<li>Реализованы большинство операций с переменными, включая операторы раскрытие списков и тензоров.</li>
<li>Серьезно переработана система встроенных типов, реализованы функции для их преобразования и для определения данных (последнее можно назвать data comprehensions).</li>
<li>Добавлены новые тесты и пр.</li>
</ul>
<cut />
<h1 id="зачем-нужен-newlang">Зачем нужен <em>NewLang</em>?<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%87%d0%b5%d0%bc-%d0%bd%d1%83%d0%b6%d0%b5%d0%bd-newlang" aria-label="Heading self-link"></a></h1>
<p>У всех современных языков программирования происходит постоянное развитие (читай усложнение) синтаксиса по мере выхода новых версий. Это является своего рода, платой за появление новых возможностей и воспринимается пользователями как естественное явление.</p>
<p>Но одновременно является и серьезной проблемой, т.к. с выходом новых версий добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки и трудоемкости поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.</p>
<p>У <em>NewLang</em> сложность языковых конструкций естественно ограничена за счет разделения синтаксиса языка на две части, что упрощает его изучение и использование.</p>
<p><em>Основной синтаксис</em> — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, который основан не на зарезервированных ключевых словах, а на строгих грамматических правилах и <em>Расширенный синтаксис</em> — когда основного синтаксиса становится недостаточно, или требуется использовать языковую конструкцию языка реализации.</p>
<p>Еще одно неудобство современных мейнстримовых языков, большинство из них были созданы до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов.</p>
<p>У <em>NewLang</em> тензорные вычисления доступны «из коробки» (используется библиотека <a href="https://pytorch.org/">libtorch</a>), а обычные числа являются скалярами (тензорами нулевой размерности).</p>
<h1 id="синтаксис-newlang">Синтаксис NewLang<a class="td-heading-self-link" href="#%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81-newlang" aria-label="Heading self-link"></a></h1>
<p>При разработке синтаксиса я старался придерживаться уже сложившихся в IT индустрии правил, чтобы не генерировать множественных смыслов, которые будут зависеть от контекста.</p>
<p><strong>Основы</strong></p>
<ul>
<li>Операторы разделяются точкой с запятой «;».</li>
<li>Отступы и переводы строк игнорируются (очень хотелось иметь возможность автоматического форматирование кода).</li>
<li>Многострочные комментарии в исходном коде соответствуют стилю С/С++ и должны располагаться между символами /* и */. Вложенность многострочных комментариев не поддерживается.</li>
<li>Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash.</li>
<li>Последовательность команд, которая должна выполняться как единое целое, заключается в фигурные скобки «{}».</li>
<li>Программные вставки расширенного синтаксиса на языке реализации заключается в фигурные скобки со знаком процента %{ /* тут может быть любой код на C/C++*/ %}, как в лексерах lex и flex.</li>
</ul>
<h1 id="создания-объектов-и-присвоения-новых-значений">Создания объектов и присвоения новых значений<a class="td-heading-self-link" href="#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d1%8f-%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%be%d0%b2-%d0%b8-%d0%bf%d1%80%d0%b8%d1%81%d0%b2%d0%be%d0%b5%d0%bd%d0%b8%d1%8f-%d0%bd%d0%be%d0%b2%d1%8b%d1%85-%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d0%b9" aria-label="Heading self-link"></a></h1>
<p>Для создания объектов и присвоения им новых значений в NewLang используется сразу три разных оператора:</p>
<ul>
<li><strong>::=</strong> используется только для создания новых объектов, а если объект с таким именем уже существует, то генерируется ошибка.</li>
<li><strong>:=</strong> используется для тех же целей, но если объект с таким именем уже существует, то ошибки не происходит, а новое значение присваивается уже существующему объекту.</li>
<li><strong>=</strong> применяется только для присвоения значения уже существующим объектам, и если объект с указанным именем отсутствует, то тоже происходит ошибка выполнения.</li>
</ul>
<p>Использование трех разных операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе.</p>
<pre tabindex="0"><code>var ::= 1.0; # Создать новую переменную var без указания типа
var = 100; # Присвоить новое значение уже существующей переменной
printf := @import(&#39;printf(format:Format, ...):Int&#39;); /* Создать новый или переопределить объект printf, который будет результатом выполнения глобальной функции @import */
</code></pre><h1 id="идентификаторы-объектов-и-модификаторы">Идентификаторы объектов и модификаторы<a class="td-heading-self-link" href="#%d0%b8%d0%b4%d0%b5%d0%bd%d1%82%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%be%d0%b2-%d0%b8-%d0%bc%d0%be%d0%b4%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82%d0%be%d1%80%d1%8b" aria-label="Heading self-link"></a></h1>
<p>В качестве идентификаторов можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой.</p>
<p>В NewLang существует возможность указания области видимости и времени жизни объекта с помощью модификатора — специального символа перед именем переменной. Это может показаться немного похожим на венгерскую нотацию, но в отличие от нее, модификатор не имеет отношения к типу объекта и не является частью имени идентификатора. К тому же в качестве модификаторов используется строго определённые символы, назначение которых определено заранее.</p>
<ul>
<li><strong>$</strong> - в начале имени обозначает локальную переменную, время жизни которой ограничено текущей областью видимости и при её завершении локальная переменная уничтожается.</li>
<li><strong>@</strong> - обозначает глобальную переменную, а сам объект сохраняет свое состояние даже после выхода из текущей области видимости.</li>
<li><strong>:</strong> - двоеточие вначале имени используется в качестве модификатора для указания типа.</li>
</ul>
<p>Семантика обращения к аргументам функций очень похоже на работу с аргументами в bash скриптах, где $1 или $arg — порядковый номер или имя аргумента (происходит обращение к локальным переменным в текущей области видимости).</p>
<h3 id="использование-модификаторов-является-обязательным-только-в-двух-случаях">Использование модификаторов является обязательным только в двух случаях:<a class="td-heading-self-link" href="#%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bc%d0%be%d0%b4%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82%d0%be%d1%80%d0%be%d0%b2-%d1%8f%d0%b2%d0%bb%d1%8f%d0%b5%d1%82%d1%81%d1%8f-%d0%be%d0%b1%d1%8f%d0%b7%d0%b0%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d1%8b%d0%bc-%d1%82%d0%be%d0%bb%d1%8c%d0%ba%d0%be-%d0%b2-%d0%b4%d0%b2%d1%83%d1%85-%d1%81%d0%bb%d1%83%d1%87%d0%b0%d1%8f%d1%85" aria-label="Heading self-link"></a></h3>
<ul>
<li>При создании нового типа данных, так как типы всегда создаются в глобальной области видимости, а их символьные имена должны быть уникальными.</li>
<li>При обращении к объектам NewLang внутри программных вставок кода на языке реализации, так как они используется как маркеры при поиске идентификаторов NewLang в коде С/С++.</li>
</ul>
<p>В остальных случаях, для обращения к переменным указывать их модификаторы необязательно. И если при обращении к объекту модификатор не указан, то сперва ищется локальная переменная, а потом глобальная с таким же именем. Причем, локальная переменная будет перекрывать глобальную.</p>
<p>Так же следует иметь в виду, что компилятор может генерировать код для прямого обращения к локальным объектам уже на этапе компиляции, тогда как для обращения к глобальным объектам, или если модификатор области видимости отсутствует, компилятор вынужден каждый раз встраивать runtime вызов функции поиска объекта в глобальной таблице символов.</p>
<h1 id="система-типов">Система типов<a class="td-heading-self-link" href="#%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%b0-%d1%82%d0%b8%d0%bf%d0%be%d0%b2" aria-label="Heading self-link"></a></h1>
<p>Так как система типов языка динамическая, то явное указание типа не влияет на размер переменной и является только своего рода логическим ограничением на возможность присвоения переменной значения другого типа.</p>
<p>Информация о типах используется при проверке их совместимости, когда существующему объекту присваивается значение другого типа. Такая операция возможна только когда типы совместимы между собой и допускают автоматическое приведение. Это справедливо как во время парсинга/компиляции исходного теста, так и во время выполнения в режимах интерпретатора и/или скомпилированного файла.</p>
<h2 id="простые-типы">Простые типы<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d1%81%d1%82%d1%8b%d0%b5-%d1%82%d0%b8%d0%bf%d1%8b" aria-label="Heading self-link"></a></h2>
<h3 id="арифметические-значения">Арифметические значения<a class="td-heading-self-link" href="#%d0%b0%d1%80%d0%b8%d1%84%d0%bc%d0%b5%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b8%d0%b5-%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d1%8f" aria-label="Heading self-link"></a></h3>
<p>Арифметические типы данных являются тензорами — массивами чисел одного типа с произвольным количеством измерений и одинаковым размером столбцов в каждом. Единичное число тоже тензор нулевого размера.</p>
<p>Поддерживаются только знаковые целые числа, т.к. в беззнаковых числах особая нужда отсутствует, а проблем с ними можно найти очень много на ровном месте.</p>
<p>Проблемы беззнаковых чисел (из интернета):</p>
<blockquote>
<p>Во-первых, вычитание двух беззнаковых чисел, например 3 и 5. 3 минус 5 равно 4294967294, т.к. -2 не может быть представлено как беззнаковое число. Во-вторых, непредвиденное поведение может возникнуть при смешивании целочисленных значений со знаком и без знака. С++ может свободно преобразовывать числа со знаком и без знака, но не проверяет диапазон, чтобы убедиться, что вы не переполняете свой тип данных.
В C++ всё же есть несколько случаев, когда можно (или необходимо) использовать беззнаковые числа. Во-первых, числа без знака предпочтительнее при работе с битами. Во-вторых, использование беззнаковых чисел связанных с индексацией массивов.</p>
</blockquote>
<p>Но это не мой случай, так как индекс может быть отрицательным и даже не числом, а диапазоном или многоточием.</p>
<p>З.Ы. И даже зная об этом, все равно умудрился недавно словить баг с отрицательными индексами у словарей!</p>
<p>Имена встроенных арифметических типов говорят сами за себя: Char, Short, Int, Long, Float, Double, ComplexFloat, ComplexDouble. Отдельным типом идет логический тип Bool, который может принимать значения только 0 или 1 (false/true соответственно), и в зависимости от выполняемой операции может быть отнесен к целочисленным типам, так и не входить в их состав (данный подход интерпретации логического типа данных был взят из библиотеки Torch).</p>
<pre tabindex="0"><code>// Treat bool as a distinct &#34;category,&#34; to be consistent with type promotion
// rules (e.g. `bool_tensor + 5 -&gt; int64_tensor`). If `5` was in the same
// category as `bool_tensor`, we would not promote. Differing categories
// implies `bool_tensor += 5` is disallowed.
//
// NB: numpy distinguishes &#34;unsigned&#34; as a category to get the desired
// `bool_tensor + 5 -&gt; int64_tensor` behavior. We don&#39;t, because:
// * We don&#39;t want the performance hit of checking the runtime sign of Scalars.
// * `uint8_tensor + 5 -&gt; int64_tensor` would be undesirable.
</code></pre><p>В будущем планируется добавить классы чисел для длинной арифметики и дробей, для чего зарезервированы названия типов BigNum, Currency и Fraction.</p>
<p>Доступ к элементам тензора происходит по целочисленному индексу, который начинается с 0. Для многомерного тензора, индексы элемента перечисляются в квадратных скобках через запятую. Поддерживается доступ к элементам через отрицательный индекс, который обрабатывается точно так же, как в Python (-1 последний элемент, -2 предпоследний и т.д.).</p>
<p>Литерал тензор в тексте программы записывается в квадратных скобках с обязательной завершающей запятой, т.е. [1, 2,] — это литерал одномерный тензор из двух чисел. После закрывающей скобки тип тензора может быть указан в явном виде. Если тип не указан, то он выводится автоматически на основании указанных данных и выбирается минимально возможный байтовый размер, который позволяет сохранить все значения без потери точности.</p>
<p><em>Примеры:</em></p>
<pre tabindex="0"><code>$var_char := 123; # Тип Char выводится автоматически
$var_short := 1000; # Тип Short выводится автоматически
$var_bool := [0, 1, 0, 1,]; # Тензор из 4 элементов. Тип Bool выводится автоматически
$tensor[10,10]:Int := 1; # Тензор Int размером 2x2 инициализированный 1
$scalar := $tensor[5,5]; # Присвоить скаляру значение указанного элемента тензора
</code></pre><h2 id="строки">Строки<a class="td-heading-self-link" href="#%d1%81%d1%82%d1%80%d0%be%d0%ba%d0%b8" aria-label="Heading self-link"></a></h2>
<p>Поддерживаются два типа строк, StrWide — символьные (широкие) и StrChar — байтовые. Различия между ними заключается в типе единичного элемента. У символьных строк единичным элементом является широкий символ <em>wchar_t</em>, а у байтовой строки единичным элементом является один байт (точнее <em>char</em>, т.е. байт со знаком). Символьные строки литералы в исходном тексте записывается в «двойных кавычках», а байтовые строки в &lsquo;одинарных кавычках&rsquo;.</p>
<p>Количество элементов символьной строки возвращается в широких символах, а размер байтовой строки в байтах, поэтому и обращение к элементу строки по индексу происходит соответственно либо к символу, либо к байту.</p>
<p>Важный момент. К любой переменной можно обратиться так же, как к функции (записав после её имени круглые скобки). Результатом этой операции будет создание копии/клона объекта. Причем некоторые типы (словари, классы и символьные строки) можно использовать в качестве шаблона при создании копии объекта с модифицированными свойствами, если новые и/или изменяемые значения указать в скобках, как аргументы при вызовах функций. Так, если при создании копии в скобках указать набор новых данных, то результирующая копия будет содержать уже измененные данные.</p>
<p><em>Например:</em></p>
<pre tabindex="0"><code>$template := &#34;${name} $1&#34;; # Обычная строка
$result := $template(&#34;шаблон&#34;, name = &#34;Строка&#34;); # result = &#34;Строка шаблон&#34;
</code></pre><h2 id="системные">Системные<a class="td-heading-self-link" href="#%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%bd%d1%8b%d0%b5" aria-label="Heading self-link"></a></h2>
<h3 id="pointer---указатель-на-системную-область-памяти">:Pointer - указатель на системную область памяти<a class="td-heading-self-link" href="#pointer---%d1%83%d0%ba%d0%b0%d0%b7%d0%b0%d1%82%d0%b5%d0%bb%d1%8c-%d0%bd%d0%b0-%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%bd%d1%83%d1%8e-%d0%be%d0%b1%d0%bb%d0%b0%d1%81%d1%82%d1%8c-%d0%bf%d0%b0%d0%bc%d1%8f%d1%82%d0%b8" aria-label="Heading self-link"></a></h3>
<p>Так как любой программе приходится взаимодействовать с внешним миром, то по неволе приходится закладывать возможность использования других библиотек и системы типов данных, и для этих целей служит тип <em>Pointer</em>. Он создается при импорте функций из внешних библиотек и вручную его создать нельзя. Но можно вывести его значение, например для отладки.</p>
<h3 id="plain---указатель-на-представление-данных-в-бинарном-виде">:Plain - указатель на представление данных в бинарном виде<a class="td-heading-self-link" href="#plain---%d1%83%d0%ba%d0%b0%d0%b7%d0%b0%d1%82%d0%b5%d0%bb%d1%8c-%d0%bd%d0%b0-%d0%bf%d1%80%d0%b5%d0%b4%d1%81%d1%82%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85-%d0%b2-%d0%b1%d0%b8%d0%bd%d0%b0%d1%80%d0%bd%d0%be%d0%bc-%d0%b2%d0%b8%d0%b4%d0%b5" aria-label="Heading self-link"></a></h3>
<p>Для взаимодействия с внешними библиотеками требуется еще и обмен данными. И для этих целей служит тип данных <em>Plain</em> - который также является указателем, но на двоичное представление данных в единой области памяти. Конечно, если их можно представить в виде единого фрагмента.</p>
<h2 id="составные-типы-данных">Составные типы данных:<a class="td-heading-self-link" href="#%d1%81%d0%be%d1%81%d1%82%d0%b0%d0%b2%d0%bd%d1%8b%d0%b5-%d1%82%d0%b8%d0%bf%d1%8b-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85" aria-label="Heading self-link"></a></h2>
<h3 id="словарь">Словарь<a class="td-heading-self-link" href="#%d1%81%d0%bb%d0%be%d0%b2%d0%b0%d1%80%d1%8c" aria-label="Heading self-link"></a></h3>
<p>Словарь (:Dictionary) — набор данных произвольного типа с доступом к отдельным элементам по целочисленному индексу или по имени элемента при его наличии (он похож и на tuple и на структуру одновременно). Словари от тензоров отличаются тем, что являются только одномерными массивами, но каждый элемент может содержать произвольное количество элементов любого типа, в том числе и другие словари.</p>
<p>Доступ к элементам словарей происходит по имени элемента, которое записывается через точку от имени переменной, либо по целочисленному индексу. Индекс также начинается с 0 и как у тензоров и тоже может быть отрицательным.</p>
<p>Литерал с типом «словарь» в тексте программы записывается в круглых скобках с обязательной завершающей запятой, т. е. (,) — пустой словарь, (1, 2= «2», name=3,).</p>
<h3 id="перечисление-структура-и-объединение">Перечисление, структура и объединение<a class="td-heading-self-link" href="#%d0%bf%d0%b5%d1%80%d0%b5%d1%87%d0%b8%d1%81%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d0%b0-%d0%b8-%d0%be%d0%b1%d1%8a%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5" aria-label="Heading self-link"></a></h3>
<p><em>:Enum</em>, <em>:Struct</em> и <em>:Union</em> — это такие же словари, только на их элементы накладываются определённые ограничения. Каждый элемент должен иметь уникальное имя, а его тип данных должен быть простым, т.е. числом или строкой фиксированного размера.</p>
<h3 id="классы">Классы<a class="td-heading-self-link" href="#%d0%ba%d0%bb%d0%b0%d1%81%d1%81%d1%8b" aria-label="Heading self-link"></a></h3>
<p>Класс (реализован частично) — тип данных, с помощью которого реализуется один из принципов ООП — наследование. При создании экземпляра класса создается новая переменная, у которой сохраняется информацию о своем родителе и которая наследует от него свойства и методы. Тип данных <em>:Class</em> аналогичен словарю, но все свойства обязаны иметь имена (хотя доступ к свойствам класса по индексу так же возможен).</p>
<h2 id="функции">Функции<a class="td-heading-self-link" href="#%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h2>
<p>Синтаксис NewLang поддерживать несколько типов функций (а в будущем и методов классов): обычные функции, чистые функции и простые чистые функции.</p>
<p>Для всех типов функций поддерживаются аргументы по умолчанию. При создании функции, её аргументы указываются как в  Python, т.е. вначале идут обязательные аргументы, потом аргументы со значениями по умолчанию, где имя аргумента отделяется от его значения по умолчанию знаком равно <strong>=</strong>. Если функция допускает обработку произвольного количества аргументов, то последним в списке параметров указывается многоточие <strong>&hellip;</strong> (три точки подряд) .</p>
<h3 id="обычная-функция">Обычная функция<a class="td-heading-self-link" href="#%d0%be%d0%b1%d1%8b%d1%87%d0%bd%d0%b0%d1%8f-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d1%8f" aria-label="Heading self-link"></a></h3>
<p>Обычная функция — такие функции являются именно обычными функциями в понимании С/С++. Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д.</p>
<p>Внутри обычной функции можно обращаться к локальным и глобальным объектам, и они могут содержаться вставки на языке реализации*, например, для вызова функций из внешних библиотек.</p>
<p>Вставки на языке реализации оформляются в виде %{ %} и могут содержать любой текст на С/С++, а прямо из него можно обращаться к локальным и глобальным объектам NewLang так же, как и в обычном синтаксисе, указывая первым символом имени соответствующий модификатор (<em>$</em> для локальных объектов и <em>@</em> для глобальных).</p>
<p>Технически, такая программная вставка просто переносится трансплайтером непосредственно в исходный текст генерируемого файла, а все идентификаторы NewLang специальным образом декорируются (добавляются специальные маркеры для их идентификации), после этого исходный текст подается на вход обычному компилятору С++. Для локальных объектов трансплайтер может генерировать код для прямого доступа к объекту на этапе компиляции, а для работы с глобальными объектами вынужден использовать runtime вызовы функции поиска в таблице символов.</p>
<hr>
<p>*) - Программные вставки на языке реализации обрабатываются только во время компиляции</p>
<p><em>Например:</em></p>
<pre tabindex="0"><code>print(str) := { 
    %{ 
        printf(&#34;%s&#34;, static_cast&lt;const char *&gt;($str)); /* Прямой вызов С функции */ 
    %} 
};
</code></pre><h3 id="чистые-функции">Чистые функции<a class="td-heading-self-link" href="#%d1%87%d0%b8%d1%81%d1%82%d1%8b%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h3>
<p>Чистая функция — это тоже обычная функция, только в том смысле, какой в него вкладывает функциональное программирование. Создания чистой функции происходит с помощью оператора <strong>:-</strong>, а сам оператор заимствован из языка Пролог. У чистой функции отсутствует доступ к контексту и глобальным переменным, поэтому она может обрабатывать только те данные, которые были ей переданы в качестве аргументов.</p>
<p>Программные вставки на языке реализации внутри чистых функций не запрещены и могут использоваться, например, для отладки. Но делается это на страх и риск разработчика. Именно он отвечает за их «чистоту», например при вызове функций из внешних библиотек.</p>
<pre tabindex="0"><code>Sum(arg1, arg2) :- {$arg1+$arg2;}; # Вернуть сумму аргументов
</code></pre><h3 id="простые-чистые-функции">Простые чистые функции<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d1%81%d1%82%d1%8b%d0%b5-%d1%87%d0%b8%d1%81%d1%82%d1%8b%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h3>
<p>Простые чистые функции — отдельный класс чистых функций, которые предназначены только для вычисления логического результата (т.е. они являются предикатами) и их отличает упрощенная формой записи. Тело простой чистой функции состоит из последовательности операторов, которые разделяются запятыми и заканчиваются, как и любое выражение, точкой с запятой. Все операторы простой чистой функции всегда приводятся к булевому значению, а итоговый результат функции вычисляется по одной из возможных логических операций: И, ИЛИ и исключающее ИЛИ.</p>
<p><em>Например:</em></p>
<pre tabindex="0"><code>func_and(arg1, arg2) :&amp;&amp;= arg1==3, arg2 &gt; 0;  # Простая чистая функция Логическое И
func_or(arg1, arg2) :||= arg1==3, arg2 &gt; 0; # Простая чистая функция Логическое ИЛИ
func_xor(arg1, arg2) :^^= arg1==3, arg2 &gt; 0;  # Простая чистая функция Исключающее ИЛИ
</code></pre><h2 id="специальные-типы-данных">Специальные типы данных:<a class="td-heading-self-link" href="#%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d1%82%d0%b8%d0%bf%d1%8b-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85" aria-label="Heading self-link"></a></h2>
<h3 id="пусто-none">Пусто (:None)<a class="td-heading-self-link" href="#%d0%bf%d1%83%d1%81%d1%82%d0%be-none" aria-label="Heading self-link"></a></h3>
<p><strong>:None</strong> (пусто) — не содержит значения (точнее имеет одно значение None) и совместим с любым другим типом данных. Указывается в тексте программы как один подчерк «_». None имеют не инициализированные переменные и при попытке чтения из такой переменной возникает ошибка.</p>
<p>Тип переменной может быть явно указан или выведен автоматически из присваиваемого значения. Присвоить новое значение уже инициализированной переменной можно только для совместимого типа, так как неявное преобразование типов не допускаются.</p>
<pre tabindex="0"><code>$var := _; # Создать не инициализированную переменную
$var2 := var; # Ошибка!!! Нельзя прочитать неинициализированную переменную var
$var = 1000; # У переменной будет тип Short (минимальный размер для хранения значения)
$var = 0,5; # Ошибка!!! Short ← Float не совместимы
$var = _; # Очистить значение переменной
$var = 0,5; # Теперь можно, т. к. None совместим с любым типом
</code></pre><h3 id="диапазон-range">Диапазон (:Range)<a class="td-heading-self-link" href="#%d0%b4%d0%b8%d0%b0%d0%bf%d0%b0%d0%b7%d0%be%d0%bd-range" aria-label="Heading self-link"></a></h3>
<p>Диапазон — специальный тип данных, являющейся приблизительным аналогом типа «генератор» в Python. К диапазону можно обращаться как к итератору и он будет поочередно выдавать элементы в указанном интервале с заданным шагом. Диапазон в тексте программы указывается как два или три элемента через две точки, например 1..5 — диапазон от единицы до пяти с шагом по умолчанию 1. В качестве параметров диапазона можно указывать не только литералы, но и имена переменных. Например, <em>0,1..$stop..0,1</em> — диапазон от 0,1 до значения, указанного в переменной $stop с шагом 0,1.</p>
<p>Диапазон для целых чисел можно использовать в качестве индекса у тензоров (точнее, у любых объектов, которые допускают доступ к своим элементам по индексу, т.е. тензоры, словари и текстовые строки). Фактический, это поведение аналогично <em>slice</em> в языке Python и <em>array[1:5]</em> в Python означает тоже самое, что и <em>array[1..5]</em> в NewLang.</p>
<p>В качестве индекса у тензоров еще можно указать произвольное количество измерений с помощью многоточия, т.е.</p>
<pre tabindex="0"><code>$tensor[…, 0] = 0; # Обнулить все первые элементы в каждом измерении.
</code></pre><h2 id="преобразование-типов">Преобразование типов<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%b5%d0%be%d0%b1%d1%80%d0%b0%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d1%82%d0%b8%d0%bf%d0%be%d0%b2" aria-label="Heading self-link"></a></h2>
<h3 id="явное-приведение-типов">Явное приведение типов<a class="td-heading-self-link" href="#%d1%8f%d0%b2%d0%bd%d0%be%d0%b5-%d0%bf%d1%80%d0%b8%d0%b2%d0%b5%d0%b4%d0%b5%d0%bd%d0%b8%d0%b5-%d1%82%d0%b8%d0%bf%d0%be%d0%b2" aria-label="Heading self-link"></a></h3>
<p>Несмотря на динамическую типизацию языка, если тип переменной указан явно, то автоматическое приведение типов не выполняется, и чтобы присвоить переменой значение не совместимого типа, требуется явное преобразование.</p>
<p>Так как символьные названия типов относятся к деталям реализации, то явное преобразование в конкретный тип данных производится с помощью вызова функции с именем типа, т.е. :Bool(), :StrWide(), :Long() и т.д.</p>
<p>Для преобразования любого типа данных в строку ещё можно использовать оператор конкатенации строк, которой преобразует любой тип данных в строковое представление. Но, так как строковых типов два (байтовые и широкие строки), то тип строки определяется первым аргументом в операторе конкатенации/сцепления <strong>++</strong>. Также преобразовать любое значение в строковое можно с помощью строки-шаблона.</p>
<pre tabindex="0"><code>&#34;&#34; ++ 123;   # &#34;123&#34; - Строка широких символов
&#39;&#39; ++ 123;   # &#39;123&#39; - Байтовая строка

val := 12345;   # Число
&#34;$1&#34;(val);      # Будет строка &#34;12345&#34;
</code></pre><p>Так как тензоры могут иметь больше одного значения, то и в качестве аргументов могут принимать их произвольное количество, а итоговым результатом будет тензор, в котором все переданные данные преобразованы к требуемому типу автоматически.</p>
<p><em>Примеры:</em></p>
<pre tabindex="0"><code>&gt; tstr := :Tensor(&#34;Тест&#34;);   # Создать тензор из строки широких символов
[1058, 1077, 1089, 1090,]:Int

&gt; t2 := :Tensor[2,2](&#34;Тест&#34;); # Тоже самое, но тензор указанной размерности
[
  [1058, 1077,], [1089, 1090,],
]:Int

&gt; :StrWide(tstr) # Создать символьную строку из тензора
Тест

&gt; :Double(t2)    # Изменить тип данных тезора без изменения размерности
[
  [1058, 1077,], [1089, 1090,],
]:Double

&gt; t3 := :Char[4]( t2 ) # Изменить размерность тензора и его тип (в данном случае с частичной потерей данных)
[34, 53, 65, 66,]:Char


&gt;:Tensor( (1,2,3,) );  # Тензор из словаря
[1, 2, 3,]:Char

&gt;:Tensor( &#39;first second&#39; )  # Байтовая строка в тензор
[102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Char

&gt;:Tensor( (first=&#39;first&#39;, space=32, second=&#39;second&#39;,) )  # Получаем тензор из словаря с такими же данными
[102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Char

&gt;:Double[10,2]( 0, ...)   # Тензор заданного формата с нулями, где многоточие повторяет последние указанные данные до получения тензора требуемого размера
[
  [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,],
]:Double

&gt;:Int[3,2]( ... rand() ...)  # Тензор со случайными данными, где между многоточиями указана функция, которую следует вызывать каждый раз при получении нового элемента тензора
# Пришлось придумывать новую конструкцию, т.к. многоточие перед именем, это оператор раскрытия словаря, а многоточие после имени, это повторение последнего значения до конца заданной размерности.
[
  [1804289383, 846930886,], [1681692777, 1714636915,], [1957747793, 424238335,],
]:Int

&gt;:Int[5,2]( 0..10 );  # Создание тензора из диапазона
[
  [0, 1,], [2, 3,], [4, 5,], [6, 7,], [8, 9,],
]:Int

&gt;:Tensor( 0..0.99..0.1 );  # Или даже так
[0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9,]:Double
</code></pre><h1 id="операторы-и-управляющие-конструкции">Операторы и управляющие конструкции<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d0%b8-%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d1%8f%d1%8e%d1%89%d0%b8%d0%b5-%d0%ba%d0%be%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h1>
<h2 id="операторы">Операторы:<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b" aria-label="Heading self-link"></a></h2>
<p>Все операторы имеют парный аналог с присвоением значения:</p>
<ul>
<li><strong>+</strong> и <strong>+=</strong> - сложение арифметических типов данных;</li>
<li><strong>-</strong> и <strong>-=</strong> - вычитание арифметических типов данных;</li>
<li><strong>/</strong> и <strong>/=</strong> - деление (результат число с плавающей точкой);</li>
<li><strong>//</strong> и <strong>//=</strong> - целочисленное деление с округлением к меньшему числу (как в Python);</li>
<li><em>*</em> и <em>*=</em> - умножение;</li>
<li><em>**</em> и <strong>**=</strong> - возведение в степень (он же используется и для повторения текстовых строк);</li>
<li><strong>++</strong> и <strong>++=</strong> - конкатенация строк с автоматическим приведением аргументов к стоковому типу (символ инкремента специально используется вместо одиночного плюса для того, чтобы в явном виде разделить конкатенацию строк и операторы арифметического сложения).</li>
</ul>
<h2 id="операторы-сравнения">Операторы сравнения:<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d1%81%d1%80%d0%b0%d0%b2%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f" aria-label="Heading self-link"></a></h2>
<ul>
<li><strong>&lt;</strong>, <strong>&gt;</strong>, <strong>&lt;=</strong>, <strong>&gt;=</strong> - классические для сравнения скаляров</li>
<li><strong>==</strong> и <strong>!=</strong> - операторы сравнения с автоматическим приведением совместимых типов для любых объектов</li>
<li><strong>===</strong> и <strong>!==</strong> - оператор точного сравнения для любых объектов (автоматического приведения типов не выполняется)</li>
</ul>
<h2 id="проверки-типа-имени-класса-объекта">Проверки типа (имени класса объекта):<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b8-%d1%82%d0%b8%d0%bf%d0%b0-%d0%b8%d0%bc%d0%b5%d0%bd%d0%b8-%d0%ba%d0%bb%d0%b0%d1%81%d1%81%d0%b0-%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%b0" aria-label="Heading self-link"></a></h2>
<p>Для оператора проверки имени класса объекта используется символ тильда <strong>~</strong>. Он немного похож на оператор <em>instanceof</em> в Java. Левым операндом должен быть проверяемый объект, а правым — проверяемый тип, который можно указать строкой литералом, переменной строкового типа или именем проверяемого класса непосредственно. Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта или он присутствует в иерархии наследования.</p>
<pre tabindex="0"><code>name := &#34;class&#34;;    # Строковая переменная с именем класса
var ~ name;         
var ~ :class;       # Имя типа
var ~ &#34;class&#34;;      # Строка литерал с именем типа
</code></pre><h2 id="утиная-типизация">Утиная типизация<a class="td-heading-self-link" href="#%d1%83%d1%82%d0%b8%d0%bd%d0%b0%d1%8f-%d1%82%d0%b8%d0%bf%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f" aria-label="Heading self-link"></a></h2>
<p>Оператор утиной типизации, два символа тильны <strong>~~</strong> — приблизительный аналог функции isinstance() в Python, который для простых типов сравнивает непосредственную совместимость типа левого операнда по отношению к правому. А для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда, т.е.:</p>
<pre tabindex="0"><code>(field1=«value», field2=2,) ~~ (); # Истина (т. е. левый операнд словарь)
(field1=«value», field2=2,) ~~ (field1=_); # Тоже истина (т. к. поле field1 присутствует у левого операнда)
(field1=«value», field2=2,) ~~ (not_found=_); # Ложь, т.к. поле not_found у левого операнда отсутствует
</code></pre><p>Строгая утиная типизация <strong>~~~</strong> — для простых типов сравнивается идентичности типов без учета совместимости, а для составных типов происходит сравнение всех свойств с помощью оператора строгого равенства. Для данной операции, пустой тип совместим только с другим пустим типом.</p>
<h1 id="управляющие-конструкции">Управляющие конструкции<a class="td-heading-self-link" href="#%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d1%8f%d1%8e%d1%89%d0%b8%d0%b5-%d0%ba%d0%be%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h1>
<p>К управляющим конструкциям языка NewLang относятся условный оператор, два вида циклов, оператор оценки выражения, оператор прерывания последовательности выполнения команд и перехват прерывания. Операторы проверки условий всегда указываются в квадратных скобках, а последовательность команд для выполнения - в фигурных.</p>
<h2 id="условный-оператор">Условный оператор<a class="td-heading-self-link" href="#%d1%83%d1%81%d0%bb%d0%be%d0%b2%d0%bd%d1%8b%d0%b9-%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80" aria-label="Heading self-link"></a></h2>
<p>В качестве оператора проверки условия используется синтаксическая конструкция, соответствующая по смыслу термину «следует», т.е. тире и угловая скобка <strong>-&gt;</strong> или с двумя тире для большей наглядности <strong>&ndash;&gt;</strong>. Такая запись условного оператора очень похожа на математическую и легко объединяется в последовательности для проверки множественных условий вида «else if».</p>
<p>В общем случае условный оператор имеет вид: <code>[ условие ] -&gt; действие;</code> или  <code>[ условие ] -&gt; {действие};</code> или  <code>[ условие1 || условие2 ] --&gt; {действие}, [_] --&gt; {действие иначе};</code></p>
<p>Для наглядности записанный с отступами:</p>
<pre tabindex="0"><code>[ условие1 ] -&gt; { действие1 },
    [ условие2 ] -&gt; действие2,
    [ условие3 ] -&gt; действие3,
    [_] -&gt; {действие_иначе};
</code></pre><h2 id="оценка-выражения">Оценка выражения<a class="td-heading-self-link" href="#%d0%be%d1%86%d0%b5%d0%bd%d0%ba%d0%b0-%d0%b2%d1%8b%d1%80%d0%b0%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f" aria-label="Heading self-link"></a></h2>
<p>Синтаксическая конструкция с помощью которой реализуется аналог оператора switch выглядит следующим образом:</p>
<pre tabindex="0"><code>[ $var ] ==&gt; {
    [1] -&gt; { code };     # Выполнится проверка условия $var == 1
    [1, 2] -&gt; { code };  # Выполнится проверка условия ($var == 1 || $var == 2)
    [_] -&gt; { code default };  # Ветка условия иначе
};
</code></pre><p>Причем в качестве оператора для оценки могут быть использован любые имеющиеся операторы сравнения на равенство:</p>
<ul>
<li><strong>==&gt;</strong> - проверка на равенство с приведением типов;</li>
<li><strong>===&gt;</strong> - проверка на точное равенство;</li>
<li><strong>~&gt;</strong> - проверка типа (имени класса);</li>
<li><strong>~~&gt;</strong> - утиная типизация;</li>
<li><strong>~~~&gt;</strong> - строгая утиная типизация.</li>
</ul>
<p>И если в качестве оператора сравнения использовать оператор утиной типизации, то оценка выражения превращается в классический Pattern Matching:</p>
<pre tabindex="0"><code>$value := (f1=1, f2=&#34;2&#34;,);
[ $value ] ~~~&gt; {
    [ (f1=_, ), (f1=_, f2=0, ) ] -&gt; { code };     # Поле f2 отсутствует или число 
    [(f1=_, f2=&#34;&#34;,), (f1=_, f2=&#39;&#39;,)] -&gt; { code }; # Поле f2 строка
    [_] -&gt; { code default };                      # Код по умолчанию
};
</code></pre><h2 id="операторы-циклов">Операторы циклов<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d1%86%d0%b8%d0%ba%d0%bb%d0%be%d0%b2" aria-label="Heading self-link"></a></h2>
<p>Для указания операторов циклов используются управляющие <strong>-&raquo;</strong> или <strong>&ndash;&raquo;</strong> (с двумя стрелками по направлению от проверки условия к телу цикла). И в зависимости от расположения условия и тела цикла, он может быть с предусловием (<em>while</em>) или постусловием (<em>do while</em>). Хотя пока эти синтаксические конструкции не &ldquo;отлежались&rdquo; и их можно считать временными из-за того, что их легко перепутать с условным оператором, и, возможно, имеет смысл заменить разные операторы цикла одной единственной конструкцией вида: <strong>&lt;&ndash;&gt;</strong> или <strong>&laquo;-&raquo;</strong>, которая сильнее отличается от оператора следования.</p>
<p>Но в настоящий момент циклы реализованы вот так:</p>
<pre tabindex="0"><code>[условие while] -&gt;&gt; {
  тело цикла while
};

{
  тело цикла do while
} &lt;&lt;-- [условие do while];
</code></pre><p>Реализация цикла foreach на примере суммирования всех элементов словаря (или одномерного тензора):</p>
<pre tabindex="0"><code>summa := 0;
dict := (1,2,3,4,5,);
[ dict ] --&gt;&gt; {           # Условие цикла, пока есть данные
  item, dict := ... dict; # Результат оператора раскрытия словаря - первый его элемент перемещается в item
  summa += item;          # Вычисление суммы всех элементов словаря
};
</code></pre><h2 id="операторы-прерывания-возврата">Операторы прерывания (возврата)<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d0%bf%d1%80%d0%b5%d1%80%d1%8b%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%b2%d0%be%d0%b7%d0%b2%d1%80%d0%b0%d1%82%d0%b0" aria-label="Heading self-link"></a></h2>
<p>В качестве оператора прерывания/возврата используется два символа минус <strong>&ndash;</strong>. Оператор позволяет прервать выполнение последовательности команд и/или вернуть данные из текущей функции/блока кода и является самым близким аналогом оператора <strong>return</strong> и <strong>throw</strong> одновременно. Для того чтобы вернуть данные, их необходимо указать между двумя операторами прерывания, т.е. <code>--100--; # Вернуть указанное значение</code>. Если возвращаемое значение не указано явно, то будет возвращено значение <em>None</em>.</p>
<h2 id="следование-блок-кодалямбда-функция">Следование (блок кода/лямбда функция)<a class="td-heading-self-link" href="#%d1%81%d0%bb%d0%b5%d0%b4%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b1%d0%bb%d0%be%d0%ba-%d0%ba%d0%be%d0%b4%d0%b0%d0%bb%d1%8f%d0%bc%d0%b1%d0%b4%d0%b0-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d1%8f" aria-label="Heading self-link"></a></h2>
<p>Алгоритмическая конструкция, которая отвечает последовательное выполнение нескольких команд/операторов и возвращающая результат выполнения последнего из них. Также, результатом выполнения может быть значение, которое возвращается с помощью оператора прерывания (возврата). Это очень похоже на классическую лямбда функцию, только она выполняется сразу во время определения, а в переменную сохраняется уже результат её выполнения.</p>
<p>Следование без перехвата прерывания оформляется в виде последовательности обычных и фигурных скобок, т.е. <code>(){ run code };</code> или тоже самое, но сохраняет результата выполнения в переменной: <code>$result := (){ run(); code() };</code>. Но если внутри такой функции будет выполнен оператор прерывания, то она никогда вернет управления и не сохранит возвращаемое значение в переменой <em>$result</em>!</p>
<p>Чтобы перехватывать прерывания, в том числе и возвращаемые значения, необходимо использовать конструкция следования с перехватом прерываний, которая оформляется в виде последовательности обычных и <strong>двойных</strong> фигурных скобок, т.е. <code>$error := (){{ run(); error();code() }};</code>. Такая конструкция перехватывает все возвраты и прерывания, если они возникают во время выполнения последовательности команд. В этом случае любой результат будет сохранен в переменной <em>$error</em> как при нормальном завершении, так и в случае возникновения ошибки.</p>
<p>Для более тонкой настройки перехвата прерываний следует использовать типизированную конструкцию, когда в явном виде указывается, какие типы прерываний следует перехватывать. <code>$runtime := (){{ run(); error(); code() }}:ErrorRuntime;</code>. Такая конструкция вернет результат только в случае успешного завершения (когда с помощью оператора прерывания возвращается не типизированное значение, например, <code>--&quot;Строка&quot;--;</code>), или при создании прерывания с указанием конкретного типа <strong>&ndash;:ErrorRuntime(&ldquo;Описание ошибки&rdquo;)&ndash;;</strong>. А вот при возникновении любого другого типизированного прерывания, значение перехвачено не будет и все отработает как самый первый вариант, т.е. без перехвата прерывания и без сохранения возвращаемого значения в переменную.</p>
<h2 id="стратегия-обработки-ошибок">Стратегия обработки ошибок<a class="td-heading-self-link" href="#%d1%81%d1%82%d1%80%d0%b0%d1%82%d0%b5%d0%b3%d0%b8%d1%8f-%d0%be%d0%b1%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b8-%d0%be%d1%88%d0%b8%d0%b1%d0%be%d0%ba" aria-label="Heading self-link"></a></h2>
<p>Обработка ошибок состоит из комбинации двух элементов: оператора прерывания выполнения с указанием типа возвращаемого значения и алгоритмической конструкции следование с возможностью перехвата прерывания заданного типа.</p>
<p>Это немного отличается от классического варианта обработки исключений, который в обычных языках программирования обычно оформляется ключевыми словами try… catch… finally с различными вариациями. Ведь основная цель подобных синтаксических конструкций — выделить участок кода, где возможно возникновение ошибки, перехватить и обработать правильный тип данных (исключений), т.к. <strong>NewLang</strong> не делает различий между операторами возврата и генерации исключения.</p>
<h3 id="подход-к-обработке-исключений-следующий">Подход к обработке исключений следующий:<a class="td-heading-self-link" href="#%d0%bf%d0%be%d0%b4%d1%85%d0%be%d0%b4-%d0%ba-%d0%be%d0%b1%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b5-%d0%b8%d1%81%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d0%b9-%d1%81%d0%bb%d0%b5%d0%b4%d1%83%d1%8e%d1%89%d0%b8%d0%b9" aria-label="Heading self-link"></a></h3>
<p>Программный код, который может привести к ошибке, заключается в двойные фигурные скобки, а результат выполнения такого блока кода присваивается переменной. После этого анализируется возвращенное значение, например, оператором сравнения по образцу:</p>
<pre tabindex="0"><code>$result := (){{     # начало аналога блока try
    $value := call_or_exception1();
    [условие1] -&gt; { -- :Error -- };
    [условие2] -&gt; { -- $value -- };
    $value := call_or_exception2();   
}};                 # конец аналога блока try
              
[$result] ~&gt; {      # Для сравнения по образцу использовать оператор проверки типа (имени класса)
    [:ErrorParser] -&gt; {Код обработки ошибок парсера};
    [:ErrorRunTime] -&gt; {Код обработки ошибок времени выполнения};
    [:Error] -&gt; { Код обработки остальных ошибок };
    [_] -&gt; { Обработка нормальных данных $value без ошибок };
};
</code></pre><h2 id="сборка-repl-из-исходников-пока-только-под-linux">Сборка REPL из исходников (пока только под Linux)<a class="td-heading-self-link" href="#%d1%81%d0%b1%d0%be%d1%80%d0%ba%d0%b0-repl-%d0%b8%d0%b7-%d0%b8%d1%81%d1%85%d0%be%d0%b4%d0%bd%d0%b8%d0%ba%d0%be%d0%b2-%d0%bf%d0%be%d0%ba%d0%b0-%d1%82%d0%be%d0%bb%d1%8c%d0%ba%d0%be-%d0%bf%d0%be%d0%b4-linux" aria-label="Heading self-link"></a></h2>
<h3 id="подготовка-репозитория">Подготовка репозитория<a class="td-heading-self-link" href="#%d0%bf%d0%be%d0%b4%d0%b3%d0%be%d1%82%d0%be%d0%b2%d0%ba%d0%b0-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d1%8f" aria-label="Heading self-link"></a></h3>
<ul>
<li><a href="https://github.com/rsashka/newlang"><u>Скачать исходники</u></a></li>
<li>Скачать и развернуть архив <a href="https://pytorch.org/">libtorch</a> в каталоге <em>contrib</em> (PyTorch Build: Stable (1.10.*) -&gt; Your OS: Linux -&gt; Package: LibTorch -&gt; Language: C++ / Java -&gt; Compute Platform: CPU -&gt; Download here (cxx11 ABI):
<a href="https://download.pytorch.org/libtorch/cpu/libtorch-cxx11-abi-shared-with-deps-1.10.2%2Bcpu.zip">libtorch-cxx11-abi-shared-with-deps-1.10.2+cpu.zip</a>)</li>
<li>Активировать и скачать исходники субмодулей (<code>git submodule init &amp;&amp; git submodule update</code>)</li>
<li>В каталоге <em>contrib</em> запустить файл <code>build.sh</code> для сборки библиотеки libffi</li>
<li>В каталоге <em>core</em> запустить файл <code>compile_syntax.sh</code> для генерации файлов парсера и лексического анализатора. Также может потребоваться установка утилит <em>flex</em> и <em>bison</em>. Если что, у меня установлены flex 2.6.4 и bison (GNU Bison) 3.7.4</li>
</ul>
<h3 id="собрать">Собрать<a class="td-heading-self-link" href="#%d1%81%d0%be%d0%b1%d1%80%d0%b0%d1%82%d1%8c" aria-label="Heading self-link"></a></h3>
<ul>
<li>Юнит-тесты (newlang_test): в каталоге <em>core</em> выполнить команду <code>make CONF=UnitTest</code>*</li>
<li>Интерпретатор (nlc): в каталоге <em>core</em> выполнить команду <code>make CONF=Debug</code>*</li>
</ul>
<hr>
<p>*) - Сборка проекта выполняется обычной утилитой make, но сборочные файлы генерируются автоматически в давно устаревшей версии NetBeans 8.2, т.к. это единственная универсальная среда разработки с поддержкой Makefile &ldquo;из коробки&rdquo;, тогда как в текущей версии Apache NetBeans полноценная поддержка разработки на С/С++ вообще отсутствует. Начал постепенный переход на использование редактора VSCodium (аналога VSCode, в котором вычищена телеметрия от Microsoft) и генерацию скриптов сборки с помощью сmake, но этот процесс пока не завершен.</p>
<h1 id="планы-на-будущее">Планы на будущее<a class="td-heading-self-link" href="#%d0%bf%d0%bb%d0%b0%d0%bd%d1%8b-%d0%bd%d0%b0-%d0%b1%d1%83%d0%b4%d1%83%d1%89%d0%b5%d0%b5" aria-label="Heading self-link"></a></h1>
<p>Текущая версия языка значительно обогатилась возможностями, но все еще является тестовой платформой для проверки декларируемых концепций и основного синтаксиса. Если говорить о планах, то в настоящий момент роадмап развития NewLang следующий:</p>
<ul>
<li>Реализовать макросы для более привычного использования языка (за счет использования DSL);</li>
<li>Добавить в арифметические типы длинные числа и дроби;</li>
<li>Сделать какую-нибудь логическую игру (крестики нолики, судоку или что-то похожее) с алгоритмическим выбором следующего хода и его вычислением с помощью машинного обучения;</li>
<li>Написать еще больше разных примеров для оценки синтаксиса;</li>
<li>Зафиксировать синтаксис с учетом полученного опыта и обратной связи;</li>
<li>Восстановить работоспособность компилятора для генерации исполняемых файлов;</li>
<li>Сделать очередную большую чистку кода;</li>
<li>Переработать и задокументировать получившуюся семантику языка с учетом всех возможностей и выпустить первую полнофункциональную версию NewLang.</li>
</ul>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-4170b8f0ec2a5e108877fa6d8749054d">Новый язык программирования</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-02-18" class="text-muted">18.02.2022</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/langs.jpeg"></p>


<div class="pageinfo pageinfo-primary">
<p>Внимание!!!</p>
<p>Данная статья содержит описание синтаксиса NewLnag предыдущей версии.</p>
<p>Актуальную версию синтаксиса языка можно посмотреть <a href="/ru/docs/">тут</a>.</p>

</div>

<p>Более года назад я начал публикацию статей с описанием особенностей нового языка программирования.
С тех пор утекло много воды, было протестировано множество идей, в итоге несколько раз все поменялось кардинальным образом
и сейчас представляю на суд читателей описание предфинальной версии языка и его особенностей.</p>
<p>Данная статья предназначена в первую очередь для проверки основных концепций нового языка программирования, а также для получения обратной связи от читателей Хабра.
Ведь согласно наблюдению <a href="https://habr.com/ru/post/539674/">Хабр-ума палата</a>, не замыленный взгляд со стороны очень сильно помогает в проработке новых идей.</p>
<p>Этот проект очень долго был без собственного названия и в публикациях назывался просто и абстрактно &ldquo;новый язык&rdquo;.
Но после нескольких статей, временное название &ldquo;новый язык&rdquo; постепенно превратилось в имя собственное <em>NewLang</em>,
которое я и решил в конечном итоге оставить (что еще раз подтверждает поговорку, что нет ничего более постоянного, чем что-то временное).</p>
<p><strong>NewLang</strong> - это язык программирования высокого уровня в котором можно сочетать стандартные алгоритмические конструкции
с декларативным программированием и тензорными вычислениями для задач машинного обучения.</p>
<p>Основной особенностью языка является легкий, логичный и непротиворечивый синтаксис, который основан не на использовании зарезервированных ключевых слов,
а на строгой системе грамматических правил с использованием знаков препинания (в список которых входят и операторы языка).
Основные свойства и особенности языка:</p>
<ul>
<li>Возможность работы как в режиме интерпретатора, так и компилятора.</li>
<li>Динамическая и статическая типизация с возможностью указания типов в явном виде.</li>
<li>Статическая типизация является условно строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных, например, целое число может быть автоматически преобразовано в вещественное, но не наоборот)</li>
<li>Автоматическое управление памятью.</li>
<li>ООП в виде явного наследования классов и <a href="https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D0%BD%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">утиная</a> типизация.</li>
<li>На уровне синтаксиса поддержка нескольких типов функций (обычные и <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8">чистые функции без побочных эффектов</a>).</li>
<li>Необязательные и именованные параметры функций.</li>
<li>Возможны вставки кода на языке реализации (С/С++).</li>
<li>Простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++).</li>
<li>Имеется REPL <a href="https://ru.wikipedia.org/wiki/REPL">read-eval-print loop — «цикл: чтение — вычисление — вывод»</a>.</li>
</ul>
<h2 id="зачем-нужен-newlang">Зачем нужен NewLang?<a class="td-heading-self-link" href="#%d0%b7%d0%b0%d1%87%d0%b5%d0%bc-%d0%bd%d1%83%d0%b6%d0%b5%d0%bd-newlang" aria-label="Heading self-link"></a></h2>
<p>У всех современных языков программирования происходит постоянное развитие (читай усложнение) синтаксиса по мере выхода новых версий.
Это является своего рода, платой за появление новых возможностей и воспринимается пользователями как естественное явление.</p>
<p>Но одновременно является и серьезной проблемой, т.к. с выходом новых версий добавляются новые ключевые слова и синтаксические конструкции,
что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки
и трудоемкости поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.</p>
<p>У NewLang сложность языковых конструкций естественно ограничена за счет разделения синтаксиса языка на две части,
что упрощает его изучение и использование. <em>Основной синтаксис</em> — для написания программ в объектно-ориентированном (императивном)
и декларативном стилях, который основан не на зарезервированных ключевых словах, а на строгих грамматических правилах
и <em>Расширенный синтаксис</em> — когда основного синтаксиса становится недостаточно, или требуется использовать языковую конструкцию языка реализации.</p>
<p>Еще одно неудобство современных мейнстримовых языков, большинство из них были созданы до начала эпохи машинного обучения,
поэтому тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов.
У <em>NewLang</em> тензорные вычисления доступны «из коробки» (используется библиотека <a href="https://pytorch.org/">libtorch</a>),
а арифметические типы данных являются скалярами (тензорами нулевой размерности).</p>
<h3 id="основной-синтаксис">Основной синтаксис<a class="td-heading-self-link" href="#%d0%be%d1%81%d0%bd%d0%be%d0%b2%d0%bd%d0%be%d0%b9-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81" aria-label="Heading self-link"></a></h3>
<p>Основной синтаксис <em>NewLang</em> - простой и логичный за счет того, что он построен исключительно на грамматических правилах
и не использует каких либо зарезервированных ключевых слов, а все буквенно-символьные последовательности рассматриваются как идентификаторы
в которых можно использовать любые не-ASCII символы.</p>
<blockquote>
<p>Идеализированная цель отказа от ключевых слов, приблизить чтение исходного текста программы к чтению обычного текста за счет использования знаков препинания при описании логики работы алгоритма.</p>
</blockquote>
<blockquote>
<p>Конечно <em>запятая</em> человек может вычленять ключевые управляющие слова языка и <em>слеш</em> или учитывать форматирование программы <em>запятая</em>
чтобы на их основе понимать синтаксические конструкции <em>запятая</em> хотя при обычном чтении мы привыкли опираться именно на семантику
знаков препинания <em>точка</em> мы конечно можем писать знаки препинания и обычным текстом <em>точка</em> но согласитесь <em>запятая</em> что тогда
<em>открытая скобка</em> например <em>запятая</em> вот такой вот текст <em>закрытая скобка</em> будет очень не удобно читать <em>точка</em></p>
</blockquote>
<p>Названия встроенных типов или имена служебных функций системной библиотеки определяются конкретной реализацией языка,
поэтому не являются зарезервированными ключевыми словами и при необходимости могут быть переопределены, например,
для создания собственного, предметно-ориентированного диалекта (<a href="ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">DSL - domain-specific language</a>), если в этом возникнет необходимость.
Но сама структура программы и логика выполняемого алгоритма все равно останутся понятны всем, кто знаком с правилами основного синтаксиса NewLang.</p>
<p><strong>Пример скрипта Hello world! на NewLang</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#!./nlc --eval </span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Определение функции hello</span>
</span></span><span style="display:flex;"><span>    hello<span style="color:#ce5c00;font-weight:bold">(</span>str<span style="color:#ce5c00;font-weight:bold">)</span> :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#204a87">printf</span> :<span style="color:#ce5c00;font-weight:bold">=</span> @import<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#39;printf(format:Format, ...):Int&#39;</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>  <span style="color:#8f5902;font-style:italic"># Импорт стандартной C функции</span>
</span></span><span style="display:flex;"><span>    printf<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#39;%s\n&#39;</span>, <span style="color:#000">$str</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>  <span style="color:#8f5902;font-style:italic"># Вызов C функции с проверкой типов аргументов по строке формата</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">}</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    hello<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#39;Привет, мир!&#39;</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Вызвать функцию</span>
</span></span></code></pre></div><p>Вывод: Привет, мир!</p>
<h3 id="расширенный-синтаксис">Расширенный синтаксис<a class="td-heading-self-link" href="#%d1%80%d0%b0%d1%81%d1%88%d0%b8%d1%80%d0%b5%d0%bd%d0%bd%d1%8b%d0%b9-%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81" aria-label="Heading self-link"></a></h3>
<p>Расширенный синтаксис — это возможность вставить в текст программы NewLang исходный код на языке реализации.
Сейчас это С/С++, что позволяет использовать любые возможности этого мощного языка программирования.</p>
<p>Обработка расширенного синтаксиса происходит на этапе компиляции приложения, а взаимодействие между основным и расширенным синтаксисами происходит за счет совместного использования идентификаторов,
которое полностью прозрачно для пользователя и подчиняется единым грамматическим правилам основного синтаксиса.</p>
<h3 id="еще-немного-примеров">Еще немного примеров:<a class="td-heading-self-link" href="#%d0%b5%d1%89%d0%b5-%d0%bd%d0%b5%d0%bc%d0%bd%d0%be%d0%b3%d0%be-%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80%d0%be%d0%b2" aria-label="Heading self-link"></a></h3>
<p>Любая последовательность вычислений возвращает результат выполнения последнего оператора.
Поэтому выполнение одной команды или последовательности команд всегда возвращает какой-либо результат,
а оператор возврата из функции необязателен, так как результатом будет значение последнего вычисленного выражения.</p>
<p><strong>Создание переменных</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    scalar :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">42</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0000cf;font-weight:bold">42</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    tensor :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">[</span>1,2,3,4,5,<span style="color:#ce5c00;font-weight:bold">]</span>  <span style="color:#8f5902;font-style:italic"># Тип тензора выводится автоматически</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>1, 2, 3, 4, 5,<span style="color:#ce5c00;font-weight:bold">]</span>:Char
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    str :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#39;$1 string&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$1</span> string
</span></span></code></pre></div><p><strong>Арифметические операции</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    tensor * <span style="color:#0000cf;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>2, 4, 6, 8, 10,<span style="color:#ce5c00;font-weight:bold">]</span>:Short
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    tensor * <span style="color:#0000cf;font-weight:bold">20</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>20, 40, 60, 80, 100,<span style="color:#ce5c00;font-weight:bold">]</span>:Short
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    tensor * 0.5
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>0.5, 1, 1.5, 2, 2.5,<span style="color:#ce5c00;font-weight:bold">]</span>:Double
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    tensor / <span style="color:#0000cf;font-weight:bold">2</span> <span style="color:#8f5902;font-style:italic"># Результат деления — число с плавающей точкой</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>0.5, 1, 1.5, 2, 2.5,<span style="color:#ce5c00;font-weight:bold">]</span>:Double
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    tensor // <span style="color:#0000cf;font-weight:bold">2</span> <span style="color:#8f5902;font-style:italic"># Целочисленное деление без остатка</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>0, 1, 1, 2, 2,<span style="color:#ce5c00;font-weight:bold">]</span>:Char&lt;/source&gt;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    tensor % <span style="color:#0000cf;font-weight:bold">2</span> <span style="color:#8f5902;font-style:italic"># Целочисленный остаток от деления</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>1, 0, 1, 0, 1,<span style="color:#ce5c00;font-weight:bold">]</span>:Char&lt;/source&gt;
</span></span></code></pre></div><p><strong>Строковые операции</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#000">str</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#39;сцепеление строк &#39;</span> ++ str<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    сцепеление строк <span style="color:#000">$1</span> string
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    str<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#39;строка как шаблон&#39;</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    сцепеление строк строка как шаблон string
</span></span></code></pre></div><h3 id="преобразование-тензоров">Преобразование тензоров<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%b5%d0%be%d0%b1%d1%80%d0%b0%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d1%82%d0%b5%d0%bd%d0%b7%d0%be%d1%80%d0%be%d0%b2" aria-label="Heading self-link"></a></h3>
<p>В эпоху машинного обучения тензоры являются основными элементами вычислений,
поэтому для конвертирования <em>данных</em> в тензоры используется отдельная синтаксическая конструкция,
состоящая из двойных квадратных скобок <strong>[[</strong> <em>данные</em> <strong>]]</strong>. Подробнее про особенности преобразования типов можно прочитать далее.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    tstr :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">[[</span><span style="color:#4e9a06">&#34;Тест&#34;</span><span style="color:#ce5c00;font-weight:bold">]]</span>   <span style="color:#8f5902;font-style:italic"># Создать тензор из строки широких символов</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>1058, 1077, 1089, 1090,<span style="color:#ce5c00;font-weight:bold">]</span>:Int
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    t2 :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">[[</span> <span style="color:#4e9a06">&#34;Тест&#34;</span> <span style="color:#ce5c00;font-weight:bold">]]</span>:Int<span style="color:#ce5c00;font-weight:bold">[</span>2,2<span style="color:#ce5c00;font-weight:bold">]</span> <span style="color:#8f5902;font-style:italic"># Тоже самое, но тензор двухмерный</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ce5c00;font-weight:bold">[</span>1058, 1077,<span style="color:#ce5c00;font-weight:bold">]</span>, <span style="color:#ce5c00;font-weight:bold">[</span>1089, 1090,<span style="color:#ce5c00;font-weight:bold">]</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">]</span>:Int&lt;/source&gt;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    StrWide<span style="color:#ce5c00;font-weight:bold">(</span>tstr<span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic"># Конвертировать тензор обратно в строку</span>
</span></span><span style="display:flex;"><span>    Тест
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    Double<span style="color:#ce5c00;font-weight:bold">(</span>t2<span style="color:#ce5c00;font-weight:bold">)</span>    <span style="color:#8f5902;font-style:italic"># Изменить тип данных тезора</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ce5c00;font-weight:bold">[</span>1058, 1077,<span style="color:#ce5c00;font-weight:bold">]</span>, <span style="color:#ce5c00;font-weight:bold">[</span>1089, 1090,<span style="color:#ce5c00;font-weight:bold">]</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">]</span>:Double
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    t3 :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">[[</span> t2 <span style="color:#ce5c00;font-weight:bold">]]</span>:Char<span style="color:#ce5c00;font-weight:bold">[</span>4<span style="color:#ce5c00;font-weight:bold">]</span> <span style="color:#8f5902;font-style:italic"># Преобразовать тип данных тензора и его размерность</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">[</span>34, 53, 65, 66,<span style="color:#ce5c00;font-weight:bold">]</span>:Char
</span></span></code></pre></div><h2 id="синтаксис-newlang">Синтаксис NewLang:<a class="td-heading-self-link" href="#%d1%81%d0%b8%d0%bd%d1%82%d0%b0%d0%ba%d1%81%d0%b8%d1%81-newlang" aria-label="Heading self-link"></a></h2>
<p>При разработке синтаксиса я старался придерживаться уже сложившихся правил, чтобы не создавать множественных смыслов,
зависящих от контекста. <del>И одновременно «объять необъятное»</del></p>
<h3 id="основы">Основы<a class="td-heading-self-link" href="#%d0%be%d1%81%d0%bd%d0%be%d0%b2%d1%8b" aria-label="Heading self-link"></a></h3>
<ul>
<li>Операторы разделяются точкой с запятой «;».</li>
<li>Отступы и переводы строк игнорируются (очень хотелось иметь возможность автоматического форматирование кода).</li>
<li>Многострочные комментарии в исходном коде соответствуют стилю С/С++ и должны располагаться между символами /* и */. Вложенность многострочных комментариев не поддерживается.</li>
<li>Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash.</li>
<li>Последовательность выполняемых команд, которая должна выполняться как единое целое, заключается в фигурные скобки «{}».</li>
<li>Программные вставки расширенного синтаксиса на языке реализации заключается в фигурные скобки со знаком процента <strong>%{</strong> <em>/* тут может быть любой код на C/C++*/</em> <strong>%}</strong>.</li>
</ul>
<h3 id="создания-объектов-и-присвоения-новых-значений">Создания объектов и присвоения новых значений<a class="td-heading-self-link" href="#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d1%8f-%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%be%d0%b2-%d0%b8-%d0%bf%d1%80%d0%b8%d1%81%d0%b2%d0%be%d0%b5%d0%bd%d0%b8%d1%8f-%d0%bd%d0%be%d0%b2%d1%8b%d1%85-%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d0%b9" aria-label="Heading self-link"></a></h3>
<p>Для создания объектов и присвоения им новых значений в NewLang используется сразу три разных оператора.<br>
Оператор «<strong>::=</strong>» используется только для создания новых объектов, а если объект с таким именем уже существует, то генерируется ошибка.<br>
Оператор «<strong>:=</strong>» используется для тех же целей, но если объект с таким именем уже существует, то ошибки не происходит,
а новое значение присваивается уже существующему объекту.<br>
И последний оператор «<strong>=</strong>» применяется только для присвоения значения уже существующим объектам, и если объект с указанным именем отсутствует, то тоже происходит ошибка.</p>
<p>Использование трех разных операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#000">var</span> <span style="color:#ce5c00;font-weight:bold">::=</span> <span style="color:#0000cf;font-weight:bold">1.0</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#a40000">#</span> <span style="color:#a40000">Создать</span> <span style="color:#a40000">новую</span> <span style="color:#a40000">переменную</span> <span style="color:#000">var</span> <span style="color:#a40000">без</span> <span style="color:#a40000">указания</span> <span style="color:#a40000">типа</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">var</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">100</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#a40000">#</span> <span style="color:#a40000">Присвоить</span> <span style="color:#a40000">новое</span> <span style="color:#a40000">значение</span> <span style="color:#a40000">уже</span> <span style="color:#a40000">существующей</span> <span style="color:#a40000">переменной</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f57900">printf</span> <span style="color:#000;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#a40000">@</span><span style="color:#000">import</span><span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">&#39;</span><span style="color:#000">printf</span><span style="color:#000;font-weight:bold">(</span><span style="color:#f57900">format</span><span style="color:#000;font-weight:bold">:</span><span style="color:#000">Format</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">...)</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#000">Int</span><span style="color:#a40000">&#39;</span><span style="color:#000;font-weight:bold">);</span> <span style="color:#8f5902;font-style:italic">/* Создать новый или переопределить 
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">    объект printf, который будет результатом выполнения глобальной функции @import */</span>
</span></span></code></pre></div><h3 id="идентификаторы-объектов-и-модификаторы">Идентификаторы объектов и модификаторы<a class="td-heading-self-link" href="#%d0%b8%d0%b4%d0%b5%d0%bd%d1%82%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d0%be%d0%b1%d1%8a%d0%b5%d0%ba%d1%82%d0%be%d0%b2-%d0%b8-%d0%bc%d0%be%d0%b4%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82%d0%be%d1%80%d1%8b" aria-label="Heading self-link"></a></h3>
<p>В качестве идентификаторов можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии,
что первый символ идентификатора не является цифрой.</p>
<p>В NewLang существует возможность указания области видимости и времени жизни объекта с помощью модификатора — специального символа перед
именем переменной. Это может показаться немного похожим на венгерскую нотацию, но в отличие от нее,
модификатор не имеет отношения к типу объекта и не является частью имени идентификатора.
К тому же в качестве модификаторов используется строго определённые символы, назначение которых определено заранее.</p>
<p>Так, символ «<strong>$</strong>» в начале имени обозначает локальную переменную, время жизни которой ограничено текущей областью видимости и при её завершении локальная переменная уничтожается.
Символ «<strong>@</strong>» обозначает глобальную переменную, а сам объект сохраняет свое состояние даже после выхода из текущей области видимости.
Так же обозначаются и имена типов данных, например, при создания новых типов, а в качестве модификатора используется символа двоеточия «<strong>:</strong>»</p>
<p>Семантика обращения к аргументам функций очень похоже на работу с аргументами в bash скриптах, где <strong>$1</strong> или <strong>$arg</strong> — порядковый номер
или имя аргумента (происходит обращение к локальным переменным в текущей области видимости).</p>
<p>Использование модификаторов является обязательным только в двух случаях:
- При создании нового типа данных, так как типы всегда создаются в глобальной области видимости, а их символьные имена должны быть уникальными
- При обращении к объектам NewLang внутри программных вставок кода на языке реализации, так как они используется как маркеры при поиске идентификаторов NewLang в коде С/С++.</p>
<p>В остальных случаях, для обращения к переменным указывать их модификаторы не обязательно.
И если при обращении к объекту модификатор не указан, то сперва ищется локальная переменная, а потом глобальная с таким же именем.
Причем, локальная переменная будет перекрывать глобальную.</p>
<p>Так же следует иметь в виду, что компилятор может генерировать код для прямого обращения к локальным объектам уже на этапе компиляции,
тогда как для обращения к глобальным объектам, или если модификатор области видимости отсутствует, компилятор вынужден каждый раз встраивать runtime вызов функции поиска объекта в таблице символов.</p>
<h2 id="система-типов">Система типов<a class="td-heading-self-link" href="#%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%b0-%d1%82%d0%b8%d0%bf%d0%be%d0%b2" aria-label="Heading self-link"></a></h2>
<p>Так как система типов языка динамическая, то явное указание типа не влияет на размер переменной и является только своего рода логическим ограничением на возможность присвоения переменной значения другого типа.</p>
<p>Информация о типах используется при проверке их совместимости, когда существующему  объекту присваивается значение другого типа.
Такая операция возможна только когда типы совместимы между собой и допускают автоматическое приведение.
Это справедливо как во время парсинга/компиляции исходного теста, так и во время выполнения в режимах интерпретатора и/или скомпилированного файла.</p>
<h3 id="арифметические-типы">Арифметические типы:<a class="td-heading-self-link" href="#%d0%b0%d1%80%d0%b8%d1%84%d0%bc%d0%b5%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b8%d0%b5-%d1%82%d0%b8%d0%bf%d1%8b" aria-label="Heading self-link"></a></h3>
<p>Арифметические типы данных являются тензорами - массивами чисел одного типа с произвольным количеством измерений и одинаковым размером столбцов в каждом.
Единичное число тоже тензор нулевого размера.</p>
<p>Поддерживаются только знаковые целые числа, т.к. в беззнаковых числах особая нужда отсутствует, а проблем с ними можно найти очень много на ровном месте.</p>
<p><strong>Проблемы беззнаковых чисел (из интернета)</strong></p>
<blockquote>
<p>Во-первых, вычитание двух беззнаковых чисел, например 3 и 5. 3 минус 5 равно 4294967294,
т.к. -2 не может быть представлено как беззнаковое число. Во-вторых, непредвиденное поведение может возникнуть при смешивании целочисленных
значений со знаком и без знака. С++ может свободно преобразовывать числа со знаком и без знака,
но не проверяет диапазон, чтобы убедиться, что вы не переполняете свой тип данных.</p>
<p>В C++ всё же есть несколько случаев, когда можно (или необходимо) использовать беззнаковые числа.
Во-первых, числа без знака предпочтительнее при работе с битами. Во-вторых, использование беззнаковых чисел связаных с индексацией массивов.</p>
</blockquote>
<p>Но это мой случай, так как индекс может быть отрицательным и даже не числом, а диапазоном или многоточием.
З.Ы. И даже зная об этом, все равно умудрился недавно словить баг с отрицательными индексами у словарей!</p>
<p>Имена встроенных арифметических типов говорят сами за себя: Char, Short, Int, Long, Float, Double, ComplexFloat, ComplexDouble.
Отдельным типом идет логический тип Bool, который может принимать значения только 0 или 1 (false/true соответственно),
и в зависимости от выполняемой операции может быть отнесен к целочисленным типам, так и не входить в их состав.</p>
<p><em>(данный подход интерпретации логического типа данных был взят из библиотеки Torch)</em></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// Treat bool as a distinct &#34;category,&#34; to be consistent with type promotion
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// rules (e.g. `bool_tensor + 5 -&gt; int64_tensor`). If `5` was in the same
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// category as `bool_tensor`, we would not promote. Differing categories
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// implies `bool_tensor += 5` is disallowed.
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// NB: numpy distinguishes &#34;unsigned&#34; as a category to get the desired
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// `bool_tensor + 5 -&gt; int64_tensor` behavior. We don&#39;t, because:
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// * We don&#39;t want the performance hit of checking the runtime sign of Scalars.
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// * `uint8_tensor + 5 -&gt; int64_tensor` would be undesirable.
</span></span></span></code></pre></div><p>В будущем планируется добавить классы чисел для длинной арифметики и дробей, для чего зарезервированы названия типов BigNum, Currency и Fraction.</p>
<p>Доступ к элементам тензора происходит по целочисленному индексу, который начинается с 0.
Для многомерного тензора, индексы элемента перечисляются в квадратных скобках через запятую.
Поддерживается доступ к элементам через отрицательный индекс, который обрабатывается точно так же,
как в Python (-1 последний элемент, -2 предпоследний и т.д.).</p>
<p>Литерал тензор в тексте программы записывается в квадратных скобках с обязательной завершающей запятой, т.е. [1, 2,] - это литерал одномерный тензор из двух чисел.
После закрывающей скобки тип тензора может быть указан в явном виде. Если тип не указан, то он выводится автоматически на основании указанных данных и выбирается минимально возможный байтовый размер,
который позволяет сохранить все значения без потери точности.</p>
<p>Примеры:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#000">$var_char</span> :<span style="color:#ce5c00;font-weight:bold">=</span> 123<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Тип Char выводится автоматически</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$var_short</span> :<span style="color:#ce5c00;font-weight:bold">=</span> 1000<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Тип Short выводится автоматически</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$var_bool</span> :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">[</span>0, 1, 0, 1,<span style="color:#ce5c00;font-weight:bold">]</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Тензор из 4 элементов. Тип Bool выводится автоматически</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$tensor</span><span style="color:#ce5c00;font-weight:bold">[</span>10,10<span style="color:#ce5c00;font-weight:bold">]</span>:Int :<span style="color:#ce5c00;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Тензор Int размером 2x2 инициализированный 1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$scalar</span> :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">$tensor</span><span style="color:#ce5c00;font-weight:bold">[</span>5,5<span style="color:#ce5c00;font-weight:bold">]</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Присвоить скаляру значение указанного элемента тензора</span>
</span></span></code></pre></div><h3 id="строковые-типы-данных">Строковые типы данных:<a class="td-heading-self-link" href="#%d1%81%d1%82%d1%80%d0%be%d0%ba%d0%be%d0%b2%d1%8b%d0%b5-%d1%82%d0%b8%d0%bf%d1%8b-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85" aria-label="Heading self-link"></a></h3>
<p>Поддерживаются два типа строк, StrWide - символьные (широкие) и StrChar — байтовые. Различия между ними заключается в типе единичного элемента.
У символьных строк единичным элементом является широкий символ wchar_t, а у байтовой строки единичным элементом является один байт (точнее char, т. е. байт со знаком).
Символьные строки литералы в исходном тексте записывается в «двойных кавычках», а байтовые строки в &lsquo;одинарных кавычках&rsquo;.</p>
<p>Количество элементов символьной строки возвращается в широких символах, а размер байтовой строки в байтах, поэтому и обращение к элементу строки по индексу происходит соответственно либо к символу, либо к байту.</p>
<p>Важный момент. К любой переменной можно обратиться так же, как к функции (записав после её имени круглые скобки).
Результатом этой операции будет создание копии/клона объекта. Причем  некоторые типы (словари, классы и символьные строки) можно использовать в качестве шаблона
при создании копии объекта с модифицированными свойствами, если новые и/или изменяемые значения указать в скобках, как аргументы при вызовах функций.
Так, если при создании копии в скобках указать набор новых данных, то результирующая копия будет содержать уже измененные данные.</p>
<p>Например:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#000">$template</span> :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;</span><span style="color:#4e9a06">${</span><span style="color:#000">name</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06"> </span><span style="color:#000">$1</span><span style="color:#4e9a06">&#34;</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Обычная строка</span>
</span></span><span style="display:flex;"><span><span style="color:#000">$result</span> :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">$template</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;шаблон&#34;</span>, <span style="color:#000">name</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;Строка&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># result = &#34;Строка шаблон&#34;</span>
</span></span></code></pre></div><h3 id="составные-типы-данных">Составные типы данных:<a class="td-heading-self-link" href="#%d1%81%d0%be%d1%81%d1%82%d0%b0%d0%b2%d0%bd%d1%8b%d0%b5-%d1%82%d0%b8%d0%bf%d1%8b-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85" aria-label="Heading self-link"></a></h3>
<h4 id="словарь">Словарь<a class="td-heading-self-link" href="#%d1%81%d0%bb%d0%be%d0%b2%d0%b0%d1%80%d1%8c" aria-label="Heading self-link"></a></h4>
<p>Словарь — набор данных произвольного типа с доступом к отдельным элементам по целочисленному индексу или по имени элемента при его наличии
(он похож и на tuple и на структуру одновременно). Словари от тензоров отличаются тем, что являются только одномерными массивами,
но каждый элемент может содержать произвольное количество элементов любого типа, в том числе и другие словари.</p>
<p>Доступ к элементам словарей происходит по имени элемента, которое записывается через точку от имени переменной, либо по целочисленному индексу.
Индекс также начинается с 0 и как у тензоров, тоже может быть отрицательным.</p>
<p>Литерал с типом «словарь» в тексте программы записывается в круглых скобках с обязательной завершающей запятой,
т.е. (,) - пустой словарь,  (1, 2= «2», name=3,).</p>
<h3 id="перечисление">Перечисление<a class="td-heading-self-link" href="#%d0%bf%d0%b5%d1%80%d0%b5%d1%87%d0%b8%d1%81%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5" aria-label="Heading self-link"></a></h3>
<p>Перечисление - это не отдельный тип данных, а обычный словарь, у которого все элементы имеют уникальные имена и целочисленные значение,
которое явно указывается при определении или вычисляется автоматически (на единицу больше предыдущего элемента).
У перечислений тип значения указывается сразу после закрывающей скобки через двоеточие (ONE=1, TWO=, THREE=): Int.</p>
<h4 id="классы">Классы<a class="td-heading-self-link" href="#%d0%ba%d0%bb%d0%b0%d1%81%d1%81%d1%8b" aria-label="Heading self-link"></a></h4>
<p>Класс  (реализовано частично) - тип данных, с помощью которого реализуется один из принципов ООП - наследование.
При создании экземпляра класса создается новая переменная, у которой сохраняется информацию о своем родителе
и которая наследует от него свойства и методы. Тип данных «класс» аналогичен словарю,
но все свойства обязаны иметь имена (хотя доступ к свойствам класса по индексу так же возможен).
Литерал с типом «Класс» в тексте программы записывается в круглых скобках без завершающей запятой, т. е. () - пустой класс,  (1, 2= «2», name=3).</p>
<p>Пока остальные детали классов до конца не реализованы, поэтому описывать их не буду, т. к. в итоговом варианте синтаксис классов и определения их методов могут поменяться.</p>
<h3 id="функции">Функции<a class="td-heading-self-link" href="#%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h3>
<p>Синтаксис NewLang поддерживать несколько типов функций (а в будущем и методов классов): обычные функции, чистые функции и простые чистые функции.</p>
<p>Для всех типов функций поддерживаются аргументы по умолчанию. При создании функции, её аргументы указываются как в Питоне,
т.е. вначале идут обязательные аргументы, потом аргументы со значениями по умолчанию,
где имя аргумента отделяется от его значения по умолчанию знаком равно «=».
Если функция допускает обработку произвольного количества аргументов, то последним в списке параметров указывается многоточие.</p>
<h4 id="обычная-функция">Обычная функция<a class="td-heading-self-link" href="#%d0%be%d0%b1%d1%8b%d1%87%d0%bd%d0%b0%d1%8f-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d1%8f" aria-label="Heading self-link"></a></h4>
<p>Обычная функция — такие функции являются именно обычными функциями в понимании С/С++.
Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д.</p>
<p>Внутри обычной функции можно обращаться к локальным и глобальным объектам, и они могут содержаться вставки на языке реализации, например, для вызова функций из внешних библиотек.</p>
<p>Вставки на языке реализации оформляются в виде <strong>%{</strong>     <strong>%}</strong> и могут содержать любой текст на С/С++,
а прямо из него можно обращаться к локальным и глобальным объектам NewLang так же, как и в обычном синтаксисе,
указывая первым символом имени соответствующий модификатор (<strong>$</strong> для локальных объектов и <strong>@</strong> для глобальных).</p>
<p>Технически, такая программная вставка просто переносится трансплайтером непосредственно в исходный текст генерируемого файла,
а все идентификаторы NewLang специальным образом декорируются (добавляются специальные маркеры для их идентификации),
после этого исходный текст подается на вход обычному компилятору С++.
Для локальных объектов трансплайтер может генерировать код для прямого доступа к объекту на этапе компиляции,
а для работы с глобальными объектами вынужден использовать runtime вызовы функции поиска в таблице символов.</p>
<p>Например:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#000">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">str</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">{</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000;font-weight:bold">{</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#000">printf</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;%s&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87;font-weight:bold">static_cast</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">const</span> <span style="color:#204a87;font-weight:bold">char</span> <span style="color:#ce5c00;font-weight:bold">*&gt;</span><span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">$</span><span style="color:#000">str</span><span style="color:#000;font-weight:bold">));</span> <span style="color:#8f5902;font-style:italic">/* Прямой вызов С функции */</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000;font-weight:bold">}</span> 
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">};</span>
</span></span></code></pre></div><h4 id="чистые-функции">Чистые функции<a class="td-heading-self-link" href="#%d1%87%d0%b8%d1%81%d1%82%d1%8b%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h4>
<p>Чистая функция - это тоже обычная функция, только в том смысле, какой в него вкладывает функциональное программирование.
Создания чистой функции происходит с помощью оператора «:-». У чистой функции отсутствует доступ к контексту и глобальным объектам,
поэтому она может обрабатывать только те данные, которые были ей переданы в качестве аргументов.</p>
<p>Программные вставки на языке реализации внутри чистых функций не запрещены и могут использоваться, например, для отладки.
Но делается это на страх и риск разработчика. Именно он отвечает за их «чистоту», например при вызове функций из внешних библиотек.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    Sum<span style="color:#ce5c00;font-weight:bold">(</span>arg1, arg2<span style="color:#ce5c00;font-weight:bold">)</span> :- <span style="color:#ce5c00;font-weight:bold">{</span><span style="color:#000">$arg1</span>+<span style="color:#000">$arg2</span><span style="color:#000;font-weight:bold">;</span><span style="color:#ce5c00;font-weight:bold">}</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Вернуть сумму аргументов</span>
</span></span></code></pre></div><p>Так как в языке отсутствует оператор возврата данных из текущего блока выполнения (аналог оператора return &lt;данные&gt;),
то возвращаемым значением функции / блока кода всегда является результат выполнения последней операции.</p>
<h4 id="простые-чистые-функции">Простые чистые функции<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d1%81%d1%82%d1%8b%d0%b5-%d1%87%d0%b8%d1%81%d1%82%d1%8b%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h4>
<p>Простые чистые функции — отдельный класс чистых функций, которые предназначены только для вычисления логического результата
(т.е. они являются предикатами) и их отличает упрощенная формой записи.
Тело простой чистой функции состоит из последовательности операторов, которые разделяются запятыми и заканчиваются,
как и любое выражение, точкой с запятой. Все операторы простой чистой функции всегда приводятся к булевому значению,
а итоговый результат функции вычисляется по одной из возможных логических операций:  <em>И</em>, <em>ИЛИ</em> и <em>исключающее ИЛИ</em>.</p>
<p>Например:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    func_and<span style="color:#ce5c00;font-weight:bold">(</span>arg1, arg2<span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;=</span> <span style="color:#000">arg1</span><span style="color:#ce5c00;font-weight:bold">==</span>3, arg2 &gt; 0<span style="color:#000;font-weight:bold">;</span>  <span style="color:#8f5902;font-style:italic"># Простая чистая функция Логическое И</span>
</span></span><span style="display:flex;"><span>    func_or<span style="color:#ce5c00;font-weight:bold">(</span>arg1, arg2<span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">||=</span> <span style="color:#000">arg1</span><span style="color:#ce5c00;font-weight:bold">==</span>3, arg2 &gt; 0<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Простая чистая функция Логическое ИЛИ</span>
</span></span><span style="display:flex;"><span>    func_xor<span style="color:#ce5c00;font-weight:bold">(</span>arg1, arg2<span style="color:#ce5c00;font-weight:bold">)</span> ^^<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">arg1</span><span style="color:#ce5c00;font-weight:bold">==</span>3, arg2 &gt; 0<span style="color:#000;font-weight:bold">;</span>  <span style="color:#8f5902;font-style:italic"># Простая чистая функция Исключающее ИЛИ</span>
</span></span></code></pre></div><h3 id="специальные-типы-данных">Специальные типы данных:<a class="td-heading-self-link" href="#%d1%81%d0%bf%d0%b5%d1%86%d0%b8%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d1%82%d0%b8%d0%bf%d1%8b-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85" aria-label="Heading self-link"></a></h3>
<h4 id="none">None<a class="td-heading-self-link" href="#none" aria-label="Heading self-link"></a></h4>
<p>None (пустой тип) — не содержит значения (точнее имеет одно значение None) и совместим с любым другим типом данных.
Указывается в тексте программы как один подчерк «_». Значение None имеют не инициализированные переменные
и при попытке чтения из такой переменной возникает ошибка.</p>
<p>Тип переменной может быть явно указан или выведен автоматически из присваиваемого значения.
Присвоить новое значение уже инициализированной переменной можно только для совместимого типа, так как неявное преобразование типов не допускаются.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#000">$var</span> :<span style="color:#ce5c00;font-weight:bold">=</span> _<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Создать переменную со значением None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$var2</span> :<span style="color:#ce5c00;font-weight:bold">=</span> var<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Ошибка!!! Нельзя прочитать неинициализированную переменную var</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$var</span> <span style="color:#ce5c00;font-weight:bold">=</span> 1000<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># У переменной будет тип Short (минимальный размер для хранения значения)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$var</span> <span style="color:#ce5c00;font-weight:bold">=</span> 0,5<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Ошибка!!! Short ← Float не совместимы</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$var</span> <span style="color:#ce5c00;font-weight:bold">=</span> _<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Очистить значение переменной</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$var</span> <span style="color:#ce5c00;font-weight:bold">=</span> 0,5<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Теперь можно, т. к. None совместим с любым типом</span>
</span></span></code></pre></div><h4 id="диапазон-range">Диапазон (Range)<a class="td-heading-self-link" href="#%d0%b4%d0%b8%d0%b0%d0%bf%d0%b0%d0%b7%d0%be%d0%bd-range" aria-label="Heading self-link"></a></h4>
<p>Диапазон  (реализовано частично) — специальный тип данных, являющейся приблизительным аналогом типа «генератор» в Python.
К диапазону можно обращаться как к итератору и он будет поочередно выдавать элементы в указанном интервале с заданным шагом.
Диапазон в тексте программы указывается как два или три элемента через две точки, например 1..5 — диапазон от единицы до пяти с шагом по умолчанию 1.
В качестве параметров диапазона можно указывать не только литералы, но и имена переменных.
Например,  0,1..<em>$stop</em>..0,1 — диапазон от значения 0,1 до значения, указанного в переменной <em>$stop</em> с шагом 0,1.</p>
<p>Диапазон для целых чисел можно использовать в качестве индекса у тензоров (точнее, у любых объектов, которые допускают доступ к своим элементам по индексу,
т.е. тензоры, словари и текстовые строки). Фактический, это поведение аналогично slice в языке Python и array[1:5]
в Python означает тоже самое, что и array[1..5] в NewLang.</p>
<p>В качестве индекса у тензоров еще можно указать произвольное количество измерений с помощью многоточия, т.е.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#000">$tensor</span><span style="color:#ce5c00;font-weight:bold">[</span>…, 0<span style="color:#ce5c00;font-weight:bold">]</span> <span style="color:#ce5c00;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Обнулить все первые элементы в каждом измерении.</span>
</span></span></code></pre></div><h4 id="итераторы">Итераторы<a class="td-heading-self-link" href="#%d0%b8%d1%82%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b" aria-label="Heading self-link"></a></h4>
<p>Итераторы  (в разработке) - самый сложный и неоднозначный тип данных для работы с элементами коллекций.<br>
Для работы с итераторами зарезервированы символы &ldquo;!&rdquo; и &ldquo;?&rdquo;, но сами итераторы пока не реализованы.</p>
<h3 id="преобразование-типов">Преобразование типов<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%b5%d0%be%d0%b1%d1%80%d0%b0%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d1%82%d0%b8%d0%bf%d0%be%d0%b2" aria-label="Heading self-link"></a></h3>
<h4 id="явное-приведение-типов">Явное приведение типов<a class="td-heading-self-link" href="#%d1%8f%d0%b2%d0%bd%d0%be%d0%b5-%d0%bf%d1%80%d0%b8%d0%b2%d0%b5%d0%b4%d0%b5%d0%bd%d0%b8%d0%b5-%d1%82%d0%b8%d0%bf%d0%be%d0%b2" aria-label="Heading self-link"></a></h4>
<p>Несмотря на динамическую типизацию языка, если тип переменной указан явно, то автоматическое приведение типов не выполняется,
и чтобы присвоить переменой значение не совместимого типа, требуется явное преобразование.</p>
<p>Так как символьные названия типов относятся к деталям реализации, то явное преобразование в конкретный тип данных производится с помощью вызова функции с системным именем,
т. е. Bool(), StrWide(), Long  и т. д. Причем у тензоров при таком преобразовании изменяется только тип данных, но размерность тензора не меняется.</p>
<p>Для преобразования любого типа данных в строку ещё можно использовать оператор конкатенации строк, которой преобразует любой тип данных в строковое представление.
Но так как строковых типов два (байтовые и широкие строки), то тип строки определяется первым аргументом в операторе конкатенации, т. е.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;</span> ++ <span style="color:#0000cf;font-weight:bold">123</span> <span style="color:#8f5902;font-style:italic"># &#34;123&#34; - Строка широких символов</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#39;&#39;</span> ++ <span style="color:#0000cf;font-weight:bold">123</span> <span style="color:#8f5902;font-style:italic"># &#39;123&#39; - Байтовая строка</span>
</span></span></code></pre></div><pre><code>Или преобразовать любое значение в строковое с помощью строки-шаблона:
</code></pre>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    val :<span style="color:#ce5c00;font-weight:bold">=</span> 12345<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;</span><span style="color:#000">$1</span><span style="color:#4e9a06">&#34;</span><span style="color:#ce5c00;font-weight:bold">(</span>val<span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic"># Будет строка &#34;12345&#34;</span>
</span></span></code></pre></div><h4 id="tensor-comprehensions">Tensor comprehensions<a class="td-heading-self-link" href="#tensor-comprehensions" aria-label="Heading self-link"></a></h4>
<p>В эпоху машинного обучения тензоры являются основным элементом вычислений, поэтому для конвертирования <em>данных</em> в тензоры используется отдельная синтаксическая конструкция,
состоящая из двойных квадратных скобок <strong>[[</strong> <em>данные</em> <strong>]]</strong>. Фактически это оператор и функция времени выполнения в зависимости от указанных между двойные квадратными скобками выражения.</p>
<p>Чтобы преобразовать любую переменную в тензор (с учетом допустимости такого преобразования), её достаточно указать между двойными квадратными скобками.
Выражение <strong>[[</strong> <em>varibale</em> <strong>]]</strong> - преобразует переменную  <em>varibale</em> в одномерный тензор с автоматическим выводом типа данных.
Для преобразования в одномерный тензор конкретного типа используется выражение <strong>[[</strong> <em>varibale</em> <strong>]]</strong>:<em>Type</em>, где _Type- - любой из арифметических типов.</p>
<p>Если требуется преобразовать переменную не в одномерный тензор, а в тензор конкретного типа и заданной размерности,
то это делается выражением [[ varibale  ]]:Type[2,2], которая вернет тензор с размерностью 2х2 и типом Type у элементов.</p>
<p>Внутри двойных квадратных скобок может быть не только любое выражение, но и литерал или диапазон.
В этом случае, они также раскрываются в тензор по таким же правилам.<br>
В будущем планирую добавить возможность указания сразу нескольких значений через запятую для их объединения в один тензор.</p>
<p>Примеры:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">&gt;</span><span style="color:#000;font-weight:bold">[[(</span><span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">,</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">,</span><span style="color:#0000cf;font-weight:bold">3</span><span style="color:#000;font-weight:bold">)]]</span>  <span style="color:#8f5902;font-style:italic"># Тензор из словаря</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">3</span><span style="color:#000;font-weight:bold">,]:</span><span style="color:#000">Char</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">&gt;</span><span style="color:#000;font-weight:bold">[[</span><span style="color:#4e9a06">&#39;first second&#39;</span><span style="color:#000;font-weight:bold">]]</span>  <span style="color:#8f5902;font-style:italic"># Байтовая строка в тензор</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">102</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">105</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">114</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">115</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">116</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">32</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">115</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">101</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">99</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">111</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">110</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">100</span><span style="color:#000;font-weight:bold">,]:</span><span style="color:#000">Char</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000;font-weight:bold">[[(</span><span style="color:#000">first</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#39;first&#39;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">space</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#0000cf;font-weight:bold">32</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">second</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#39;second&#39;</span><span style="color:#000;font-weight:bold">)]]</span>  <span style="color:#8f5902;font-style:italic"># Получаем тензор из словаря с такими же данными</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">102</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">105</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">114</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">115</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">116</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">32</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">115</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">101</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">99</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">111</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">110</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">100</span><span style="color:#000;font-weight:bold">,]:</span><span style="color:#000">Char</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">&gt;</span><span style="color:#000;font-weight:bold">[[</span> <span style="color:#0000cf;font-weight:bold">0</span> <span style="color:#ce5c00;font-weight:bold">...</span> <span style="color:#000;font-weight:bold">]]:</span><span style="color:#000">Double</span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">10</span><span style="color:#000;font-weight:bold">,</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">]</span>   <span style="color:#8f5902;font-style:italic"># Тензор заданного формата с нулями</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">[</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,],</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">]:</span><span style="color:#000">Double</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">&gt;</span><span style="color:#000;font-weight:bold">[[</span> <span style="color:#000">rand</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#ce5c00;font-weight:bold">...</span> <span style="color:#000;font-weight:bold">]]:</span> <span style="color:#000">Int</span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">3</span><span style="color:#000;font-weight:bold">,</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">]</span>  <span style="color:#8f5902;font-style:italic"># Тензор со случайными данными</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">[</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">1804289383</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">846930886</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">1681692777</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">1714636915</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">1957747793</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">424238335</span><span style="color:#000;font-weight:bold">,],</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">]:</span><span style="color:#000">Int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">&gt;</span><span style="color:#000;font-weight:bold">[[</span> <span style="color:#0000cf;font-weight:bold">0..10</span> <span style="color:#000;font-weight:bold">]]:</span> <span style="color:#000">Int</span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">5</span><span style="color:#000;font-weight:bold">,</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">]</span>  <span style="color:#8f5902;font-style:italic"># Тензор из диапзона</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">[</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">3</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">4</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">5</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">6</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">7</span><span style="color:#000;font-weight:bold">,],</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">8</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">9</span><span style="color:#000;font-weight:bold">,],</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">]:</span><span style="color:#000">Int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">&gt;</span><span style="color:#000;font-weight:bold">[[</span> <span style="color:#0000cf;font-weight:bold">0..0.99</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#0000cf;font-weight:bold">.0.1</span> <span style="color:#000;font-weight:bold">]]</span>  <span style="color:#8f5902;font-style:italic"># Или даже так</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0.1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0.2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0.3</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0.4</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0.5</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0.6</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0.7</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0.8</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0.9</span><span style="color:#000;font-weight:bold">,]:</span><span style="color:#000">Double</span><span style="color:#ce5c00;font-weight:bold">&lt;/</span><span style="color:#000">source</span><span style="color:#ce5c00;font-weight:bold">&gt;</span>
</span></span></code></pre></div><h2 id="операторы-и-управляющие-конструкции">Операторы и управляющие конструкции<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d0%b8-%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d1%8f%d1%8e%d1%89%d0%b8%d0%b5-%d0%ba%d0%be%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h2>
<h4 id="операторы">Операторы:<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b" aria-label="Heading self-link"></a></h4>
<p>Все операторы имеют парный оператор с присвоением значения.</p>
<ul>
<li><strong>+</strong> и += сложение арифметических типов данных</li>
<li>
<ul>
<li>и -= вычитание арифметических типов данных</li>
</ul>
</li>
<li>/ и /= деление (результат число с плавающей точкой)</li>
<li>// и //= целочисленное деление с округлением к меньшему числу (как в Python)</li>
<li>
<ul>
<li>и *= умножение</li>
</ul>
</li>
<li>** и **=  возведение в степень (он же используется и для повторения текстовых строк)</li>
<li>++ и ++= конкатенация строк с автоматическим приведением аргументов к стоковому типу (символ инкремента специально используется вместо одиночного плюса для того, чтобы в явном виде разделить конкатенацию строк и операторы арифметического сложения)</li>
</ul>
<h4 id="операторы-сравнения">Операторы сравнения:<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d1%81%d1%80%d0%b0%d0%b2%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f" aria-label="Heading self-link"></a></h4>
<ul>
<li>&lt;, &gt;, &lt;=, &gt;=  классические для сравнения скаляров</li>
<li>==, != операторы сравнения с автоматическим приведением совместимых типов для любых объектов</li>
<li>===, !== оператор точного сравнения для любых объектов (автоматического приведения типов не выполняется)s</li>
</ul>
<h3 id="проверки-типов--в-разработке">Проверки типов  (в разработке):<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b8-%d1%82%d0%b8%d0%bf%d0%be%d0%b2--%d0%b2-%d1%80%d0%b0%d0%b7%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b5" aria-label="Heading self-link"></a></h3>
<p>Проверка имени класса «~» - немного похож на оператор instanceof в Java.
Левым оператором должен быть проверяемый объект, а правым оператором - название типа, строка литерал или объект строкового типа с именем класса.
Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта или он присутствует в иерархии наследования у проверяемого класса.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    name :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;class&#34;</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Строка с именем класса</span>
</span></span><span style="display:flex;"><span>    var ~ :class<span style="color:#000;font-weight:bold">;</span> 
</span></span><span style="display:flex;"><span>    var ~ <span style="color:#4e9a06">&#34;class&#34;</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    var ~ name<span style="color:#000;font-weight:bold">;</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">field1</span><span style="color:#ce5c00;font-weight:bold">=</span>«value», <span style="color:#000">field2</span><span style="color:#ce5c00;font-weight:bold">=</span>2, <span style="color:#000">field3</span><span style="color:#ce5c00;font-weight:bold">=</span>«33»,<span style="color:#ce5c00;font-weight:bold">)</span> ~~ <span style="color:#ce5c00;font-weight:bold">()</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Истина (т. е. левый операнд словарь)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">field1</span><span style="color:#ce5c00;font-weight:bold">=</span>«value», <span style="color:#000">field2</span><span style="color:#ce5c00;font-weight:bold">=</span>2, <span style="color:#000">field3</span><span style="color:#ce5c00;font-weight:bold">=</span>«33»,<span style="color:#ce5c00;font-weight:bold">)</span> ~~ <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">field1</span><span style="color:#ce5c00;font-weight:bold">=</span>_<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Тоже истина (т. к. поле field1 присутствует у левого операнда)</span>
</span></span></code></pre></div><p>Утиная типизация «~~» - приблизительный аналог функции isinstance() в Python, который для простых типов сравнивает совместимость типа левого операнда по отношению к правому, а для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда. т. е.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">field1</span><span style="color:#ce5c00;font-weight:bold">=</span>«value», <span style="color:#000">field2</span><span style="color:#ce5c00;font-weight:bold">=</span>2, <span style="color:#000">field3</span><span style="color:#ce5c00;font-weight:bold">=</span>«33»,<span style="color:#ce5c00;font-weight:bold">)</span> ~~ <span style="color:#ce5c00;font-weight:bold">()</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Истина (т. е. левый операнд словарь)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">field1</span><span style="color:#ce5c00;font-weight:bold">=</span>«value», <span style="color:#000">field2</span><span style="color:#ce5c00;font-weight:bold">=</span>2, <span style="color:#000">field3</span><span style="color:#ce5c00;font-weight:bold">=</span>«33»,<span style="color:#ce5c00;font-weight:bold">)</span> ~~ <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">field1</span><span style="color:#ce5c00;font-weight:bold">=</span>_<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># Тоже истина (т. к. поле field1 присутствует у левого операнда)</span>
</span></span></code></pre></div><p>Строгая утиная типизация «~~~» - для простых типов сравнивается идентичности типов без учета совместимости,
а для составных типов происходит строгое сравнение всех свойств. Для данной операции, пустой тип совместим только с другим пустим типом!</p>
<h2 id="управляющие-конструкции-в-разработке">Управляющие конструкции (в разработке)<a class="td-heading-self-link" href="#%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d1%8f%d1%8e%d1%89%d0%b8%d0%b5-%d0%ba%d0%be%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%86%d0%b8%d0%b8-%d0%b2-%d1%80%d0%b0%d0%b7%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b5" aria-label="Heading self-link"></a></h2>
<h3 id="условный-оператор">Условный оператор<a class="td-heading-self-link" href="#%d1%83%d1%81%d0%bb%d0%be%d0%b2%d0%bd%d1%8b%d0%b9-%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80" aria-label="Heading self-link"></a></h3>
<p>В качестве оператора проверки условия используется синтаксическая конструкция, соответствующая по смыслу термину «следует»,
т.е. тире и угловая скобка «-&gt;». Такая запись условного оператора очень похожа на математическую и легко объединяется в последовательности для проверки множественных условий вида «else if».</p>
<p>В общем случае условный оператор имеет вид:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    условие -&gt; действие<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    или  
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span>условие<span style="color:#ce5c00;font-weight:bold">)</span> -&gt; <span style="color:#ce5c00;font-weight:bold">{</span>действие<span style="color:#ce5c00;font-weight:bold">}</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    или  
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span>условие1 <span style="color:#ce5c00;font-weight:bold">||</span> условие2<span style="color:#ce5c00;font-weight:bold">)</span> -&gt; <span style="color:#ce5c00;font-weight:bold">{</span>действие<span style="color:#ce5c00;font-weight:bold">}</span> -&gt; <span style="color:#ce5c00;font-weight:bold">{</span>действие иначе<span style="color:#ce5c00;font-weight:bold">}</span><span style="color:#000;font-weight:bold">;</span>
</span></span></code></pre></div><p>Или расширенный вариант «else if», для наглядности записанный с отступами:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span>условие1<span style="color:#ce5c00;font-weight:bold">)</span> -&gt; <span style="color:#ce5c00;font-weight:bold">{</span>действие1<span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ce5c00;font-weight:bold">(</span>условие2<span style="color:#ce5c00;font-weight:bold">)</span> -&gt; <span style="color:#ce5c00;font-weight:bold">{</span>действие2<span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ce5c00;font-weight:bold">(</span>условие3<span style="color:#ce5c00;font-weight:bold">)</span> -&gt; <span style="color:#ce5c00;font-weight:bold">{</span>действие3<span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        -&gt; <span style="color:#ce5c00;font-weight:bold">{</span>действие_иначе<span style="color:#ce5c00;font-weight:bold">}</span><span style="color:#000;font-weight:bold">;</span>
</span></span></code></pre></div><h3 id="операторы-циклов-в-планах">Операторы циклов (в планах)<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d1%86%d0%b8%d0%ba%d0%bb%d0%be%d0%b2-%d0%b2-%d0%bf%d0%bb%d0%b0%d0%bd%d0%b0%d1%85" aria-label="Heading self-link"></a></h3>
<p><em>Операторы циклов пока в разработке , т. к. плотно связаны с итераторами.</em></p>
<p>Пока планирую для циклов использовать  конструкции: (условие) <strong>&lt;&ndash;&gt;</strong> {тело цикла};</p>
<p>Или так: (условие) <strong>-&raquo;</strong> {тело цикла};</p>
<p>И хотя синтаксис мне не очень нравится, но я решил пока не ломать над этим голову и планирую попробовать несколько вариантов оформления циклов.</p>
<h4 id="операторы-прерывания-потока-выполнения-команд-реализовано-частично">Операторы прерывания потока выполнения команд (реализовано частично)<a class="td-heading-self-link" href="#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d1%8b-%d0%bf%d1%80%d0%b5%d1%80%d1%8b%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%bf%d0%be%d1%82%d0%be%d0%ba%d0%b0-%d0%b2%d1%8b%d0%bf%d0%be%d0%bb%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f-%d0%ba%d0%be%d0%bc%d0%b0%d0%bd%d0%b4-%d1%80%d0%b5%d0%b0%d0%bb%d0%b8%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%be-%d1%87%d0%b0%d1%81%d1%82%d0%b8%d1%87%d0%bd%d0%be" aria-label="Heading self-link"></a></h4>
<p>Оператором прерывания потока выполнения команд и возврата из текущей функции, т.е. самым близким аналогом оператора return<br>
является оператор два символа минус «&ndash;». Но в отличие от классического return, оператор возврата не возвращает значения,
т.к. значение из любой функции или блока кода возвращается всегда и им является результат выполнения самой последней операции
(или None, если такая операция отсутствует).</p>
<p>Пока не придумал, как оформлять оператор прерывания потока выполнения в случае ошибки (при его выполнении будет происходить генерация исключения),
поэтому, если будут предложения, пишите в комментариях к статье (и про оформление циклов тоже).</p>
<h3 id="обработка-ошибок-в-планах">Обработка ошибок (в планах)<a class="td-heading-self-link" href="#%d0%be%d0%b1%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b0-%d0%be%d1%88%d0%b8%d0%b1%d0%be%d0%ba-%d0%b2-%d0%bf%d0%bb%d0%b0%d0%bd%d0%b0%d1%85" aria-label="Heading self-link"></a></h3>
<p>В самом начале работ я ориентировался на классический вариант обработки исключений,
который в обычных языках программирования обычно оформляется ключевыми словами  <em>try</em> .. <em>catch</em> .. <em>finally</em> с различными вариациями.
Но в условиях жестких ограничений на синтаксис языка, и невозможности использовать ключевые слова,
комбинировать символы для указания разных типов блоков при обработке исключений, было бы крайне сомнительной затеей.
Ведь основная цель разработки NewLang — простота и понятность кода, а тут с самого начала могут появиться комбинации скобочек, стрелочек,
палочек и других подобных символов.</p>
<p>И тут в голову пришла очень простая мысль. А ненужно повторять логику обработки ошибок из классических языков программирования!
Ведь основная цель подобных синтаксических конструкций - выделить участок кода где возможно возникновение ошибки,
перехватить и обработать правильный тип исключения.
Ведь классические языки программирования изначально были жестко привязаны к машинному представлению данных в оперативной памяти компьютера
и тип данных для них играл принципиально важное значение.
Но это не является ограничением для языков с динамической типизацией!</p>
<p>Поэтому, подход к обработке исключений планируется следующий: Программный код, который может привести к ошибке, заключается в двойные фигурные скобки
<strong>{{</strong> <i>любой код или вызов одиночной функции</i>  <strong>}}</strong>,
а результат выполнения такого блока кода присваивается переменной. После этого анализируется возвращенное значение и тип исключения может обрабатываться обычным условным оператором.</p>
<p>Наверно, это проще показать на примере:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#000">$error</span> :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{{</span> <span style="color:#8f5902;font-style:italic"># начало блока try</span>
</span></span><span style="display:flex;"><span>        call_or_exception1<span style="color:#ce5c00;font-weight:bold">()</span><span style="color:#000;font-weight:bold">;</span> 
</span></span><span style="display:flex;"><span>        call_or_exception2<span style="color:#ce5c00;font-weight:bold">()</span><span style="color:#000;font-weight:bold">;</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">}}</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#8f5902;font-style:italic"># конец блока try</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Обычные условные операторы вместо типизированных блоков catch</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">$error</span> ~ :type1<span style="color:#ce5c00;font-weight:bold">)</span>-&gt;<span style="color:#ce5c00;font-weight:bold">{</span> код обработки ошибки 1<span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">$error</span> ~ :type2<span style="color:#ce5c00;font-weight:bold">)</span>-&gt;<span style="color:#ce5c00;font-weight:bold">{</span> код обработки ошибки 2<span style="color:#ce5c00;font-weight:bold">}</span><span style="color:#000;font-weight:bold">;</span>
</span></span></code></pre></div><p>Самое удивительное, что при таком подходе значительно упрощается и семантика блоков <em>try</em> <strong>…</strong> <em>finally</em>, которые вообще становятся не нужны.</p>
<p>Исходный код на Java:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#204a87;font-weight:bold">try</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">{</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">        </span><span style="color:#204a87;font-weight:bold">try</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">{</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">            </span><span style="color:#204a87;font-weight:bold">throw</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#204a87;font-weight:bold">new</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000">Exception</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;a&#34;</span><span style="color:#000;font-weight:bold">);</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">        </span><span style="color:#000;font-weight:bold">}</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#204a87;font-weight:bold">finally</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">{</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">            </span><span style="color:#204a87;font-weight:bold">throw</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#204a87;font-weight:bold">new</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000">IOException</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;b&#34;</span><span style="color:#000;font-weight:bold">);</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">        </span><span style="color:#000;font-weight:bold">}</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#000;font-weight:bold">}</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#204a87;font-weight:bold">catch</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">IOException</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000">ex</span><span style="color:#000;font-weight:bold">)</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">{</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">        </span><span style="color:#000">System</span><span style="color:#000;font-weight:bold">.</span><span style="color:#c4a000">err</span><span style="color:#000;font-weight:bold">.</span><span style="color:#c4a000">println</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">ex</span><span style="color:#000;font-weight:bold">.</span><span style="color:#c4a000">getMessage</span><span style="color:#000;font-weight:bold">());</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#000;font-weight:bold">}</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#204a87;font-weight:bold">catch</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Exception</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000">ex</span><span style="color:#000;font-weight:bold">)</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">{</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">        </span><span style="color:#000">System</span><span style="color:#000;font-weight:bold">.</span><span style="color:#c4a000">err</span><span style="color:#000;font-weight:bold">.</span><span style="color:#c4a000">println</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">ex</span><span style="color:#000;font-weight:bold">.</span><span style="color:#c4a000">getMessage</span><span style="color:#000;font-weight:bold">());</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#000;font-weight:bold">}</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span></code></pre></div><p>Эквивалентный ему на NewLang:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#000">$catch</span> :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{{</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#000">$finally</span> :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{{</span>  
</span></span><span style="display:flex;"><span>	Error1<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;1&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">}}</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Error2<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;2&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span> 	<span style="color:#8f5902;font-style:italic"># Строка выполнится даже при возникновении исключении Error1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">$finally</span><span style="color:#000;font-weight:bold">;</span>		<span style="color:#8f5902;font-style:italic"># Error1 вернется, если не будет Error2</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}}</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">$catch</span> ~ :Error1<span style="color:#ce5c00;font-weight:bold">)</span> -&gt; printf<span style="color:#ce5c00;font-weight:bold">(</span>«%s», <span style="color:#000">$catch</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">$catch</span> ~ :Error2<span style="color:#ce5c00;font-weight:bold">)</span> -&gt; printf<span style="color:#ce5c00;font-weight:bold">(</span>«%s», <span style="color:#000">$catch</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span></code></pre></div><h2 id="как-все-это-попробовать">Как все это попробовать?<a class="td-heading-self-link" href="#%d0%ba%d0%b0%d0%ba-%d0%b2%d1%81%d0%b5-%d1%8d%d1%82%d0%be-%d0%bf%d0%be%d0%bf%d1%80%d0%be%d0%b1%d0%be%d0%b2%d0%b0%d1%82%d1%8c" aria-label="Heading self-link"></a></h2>
<p>Сейчас сборка проекта реализована только под Linux и если кроме текстового описания захочется в живую поэкспериментировать на своей машине, то придется собрать интерпретатор из исходников самостоятельно.</p>
<p>Так как текущий вариант предназначен первую очередь для отработки концепции, то часть из описанных возможностей пока не реализована (алгоритмические конструкции, наследование классов, итераторы, некоторые операции и т. д).</p>
<p>Но можно поиграться с созданием переменных, вызовом функций и выполнением арифметических операций над данными, чтобы оценить синтаксис, основанный на правилах, и может быть, предложить свои собственные мысли и доработки для его улучшения.</p>
<h3 id="сборка-repl-из-исходников-пока-только-под-linux">Сборка REPL из исходников (пока только под Linux)<a class="td-heading-self-link" href="#%d1%81%d0%b1%d0%be%d1%80%d0%ba%d0%b0-repl-%d0%b8%d0%b7-%d0%b8%d1%81%d1%85%d0%be%d0%b4%d0%bd%d0%b8%d0%ba%d0%be%d0%b2-%d0%bf%d0%be%d0%ba%d0%b0-%d1%82%d0%be%d0%bb%d1%8c%d0%ba%d0%be-%d0%bf%d0%be%d0%b4-linux" aria-label="Heading self-link"></a></h3>
<h4 id="подготовка-репозитория">Подготовка репозитория<a class="td-heading-self-link" href="#%d0%bf%d0%be%d0%b4%d0%b3%d0%be%d1%82%d0%be%d0%b2%d0%ba%d0%b0-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d1%8f" aria-label="Heading self-link"></a></h4>
<ul>
<li>Скачать <a href="https://github.com/rsashka/newlang">исходники</a></li>
<li>Скачать и развернуть архив libtorch в каталоге contrib (PyTorch Build: Stable (1.10.*) -&gt; Your OS: Linux -&gt; Package: LibTorch -&gt; Language: C++ / Java -&gt; Compute Platform: CPU -&gt; Download here (cxx11 ABI): libtorch-cxx11-abi-shared-with-deps-1.10.2+cpu.zip)</li>
<li>Активировать и скачать исходники субмодулей (git submodule init &amp;&amp; git submodule update)</li>
<li>В каталоге <em>contrib</em> запустить файл <em>build.sh</em> для сборки библиотеки libffi</li>
<li>В каталоге <em>core</em> запустить файл <em>compile_syntax.sh</em> для генерации файлов парсера и лексического анализатора. Может потребоваться установка утилит flex и bison. Если что, у меня установлены flex 2.6.4 и bison (GNU Bison) 3.7.4</li>
</ul>
<h4 id="собрать">Собрать<a class="td-heading-self-link" href="#%d1%81%d0%be%d0%b1%d1%80%d0%b0%d1%82%d1%8c" aria-label="Heading self-link"></a></h4>
<ul>
<li>Юнит-тесты (newlang_test): в каталоге core выполнить команду <em>make CONF=UnitTest</em></li>
<li>Интерпретатор (nlc): в каталоге core выполнить команду <em>make CONF=Debug</em></li>
</ul>
<h2 id="утилита-nlc-newlangcompiler">Утилита nlc (NewLangCompiler)<a class="td-heading-self-link" href="#%d1%83%d1%82%d0%b8%d0%bb%d0%b8%d1%82%d0%b0-nlc-newlangcompiler" aria-label="Heading self-link"></a></h2>
<p>В текущее время nlc поддерживать работу только в режиме интерпретатора (несмотря на название).
Для тестирования и простой проверки компилятор не нужен, хотя на первых порах я делал именно его.
Но трудоемкость работ по постоянной переделке под новый синтаксис оказалась очень высокой, поэтому на время первичной отладки языковых конструкций было принято волевое решение ограничиться интерпретатором,
как более простым и быстрым способом проверки различных гипотез, а разработку настоящего компилятора (в виде трансплайтера на язык С++),
отложить до окончательной проработки синтаксиса.</p>
<h2 id="планы-на-будущее">Планы на будущее<a class="td-heading-self-link" href="#%d0%bf%d0%bb%d0%b0%d0%bd%d1%8b-%d0%bd%d0%b0-%d0%b1%d1%83%d0%b4%d1%83%d1%89%d0%b5%d0%b5" aria-label="Heading self-link"></a></h2>
<p>Естественное, одна статья и несколько маленьких примеров не дают исчерпывающей информации о возможностях языка.
Да и сами возможности пока не раскрыты в полной мере.
Ведь текущая версия, это скорее тестовая платформа для проверки декларируемых концепций и основного синтаксиса.</p>
<p>Пока остаются не реализованными некоторые из заявленных возможностей и очень важных хотелок.
Но протестировать основной подход можно уже сейчас, и я буду благодарен за любую обратную связь и предложения.</p>
<p>Если говорить о планах (естественно, в будущих версиях что-то может добавиться или измениться порядок их реализации), но в настоящий момент роадмап развития NewLang мне видится следующим образом:</p>
<ul>
<li>Доделать стандартные управляющие конструкции, обработку ошибок и итераторы.</li>
<li>Доработать систему типов с учетом множественного наследования классов.</li>
<li>Реализовать длинную арифметику и дроби.</li>
<li>Сделать какую нибудь логическую игру (крестики нолики, судоку или что-то похожее) с алгоритмическим выбором следующего хода и его вычислением с помощью машинного обучения.</li>
<li>Написать много разных примеров для оценки синтаксиса.</li>
<li>Доработать синтаксис с учетом полученного опыта и обратной связи.</li>
<li>Восстановить работоспособность компилятора для генерации исполняемых файлов.</li>
<li>Сделать очередную большую чистку кода.</li>
<li>Переработать и задокументировать получившуюся семантику языка с учетом всех возможностей и выпустить первую полнофункциональную версию NewLang.</li>
</ul>
<p><a href="https://habr.com/ru/companies/timeweb/articles/651999/">Ссылка на первую публикаци</a></p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-0264650d0efdd6e82885557e6aaf423c">Можно ли использовать декларативный и императивный стили написания программ одновременно?</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2021-07-26" class="text-muted">26.07.2021</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/matrix.jpeg"></p>


<div class="pageinfo pageinfo-primary">
<p>Внимание!!!</p>
<p>Данная статья содержит описание синтаксиса NewLnag предыдущей версии.</p>
<p>Актуальную версию синтаксиса языка можно посмотреть <a href="/ru/docs/">тут</a>.</p>

</div>

<p>При разработке своего собственного языка программирования автор должен определиться, какими свойствами его язык должен обладать,
ведь в конечном итоге именно это и будет определять назначение языка и особенности его использования.
Причем некоторые свойства  настолько сильно влияют на итоговую концепцию языка и его синтаксис,
что впоследствии их изменение невозможно в принципе, либо новый синтаксис получается очень запутанным и непонятным.
Наверно из-за этого многие свойства языков программирования рассматриваются и изучаются как взаимоисключающие.</p>
<p>До недавнего времени я считал, что императивная и декларативная парадигмы написания программ являются антагонистами и взаимоисключающими понятиями.
Ведь  выбор стиля написания кода, изначально определяется автором языка еще на стадии его проектирования и оказывает влияние на все последующие аспекты.</p>
<p>Но сейчас я думаю, что это не верно. Императивный и декларативный стили программирования не являются взаимоисключающими,
а писать программы только в одной из указанных парадигм  подталкивают правила синтаксиса, реализованные в языке!</p>
<p>Другими словами, использовать только императивную или только декларативную парадигмы разработчик вынужден не потому, что он не умеет или не хочет писать код по другому, а из-за того,
что все более-менее мейнстримные языки программирования ориентированы на использование только одной парадигмы.
И выбор только одной парадигмы написания кода, это ограничение, которое навязано программистам создателями языка.
Ведь если они изначально ориентировались только на одну концепцию разработки кода, то и разрабатывали синтаксис языка в соответствии с этой парадигмой.</p>
<p>Данная статья — размышление о совместимости декларативной и императивной парадигм программирования и возможности их одновременного использования в рамках одного языка программирования одновременно.</p>
<h2 id="что-такое-декларативное-программирование">Что такое &ldquo;Декларативное программирование&rdquo;?<a class="td-heading-self-link" href="#%d1%87%d1%82%d0%be-%d1%82%d0%b0%d0%ba%d0%be%d0%b5-%d0%b4%d0%b5%d0%ba%d0%bb%d0%b0%d1%80%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d0%be%d0%b5-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5" aria-label="Heading self-link"></a></h2>
<p>Вначале мне захотелось разобраться, а существуют ли чисто декларативные языки программирования?
Такие, которые могут полностью обходятся без императивных конструкций?</p>
<p>Но чуть не споткнулся уже в самом начале, т.к. даже само определение «декларативное программировании», в вики описывается <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">следующим образом</a>:</p>
<blockquote>
<p>Декларати́вное программи́рование — парадигма программирования, в которой задаётся спецификация решения задачи, то есть описывается, что представляет собой проблема и ожидаемый результат. Противоположностью декларативного является императивное программирование, описывающее на том или ином уровне детализации, как решить задачу и представить результат.</p>
</blockquote>
<p>Уже в изначальном определении закладывается противопоставление парадигм, а дальше идут рассуждения о «направлении» программирования.
И хоть вики сама и не является авторитетным источником информации, но даже такая заготовка статьи смогла показать направление поиска ответов на первый поставленный вопрос.</p>
<p>И заставил задуматься один абзац в конце статьи следующего содержания:</p>
<blockquote>
<p>«Чисто декларативные» компьютерные языки зачастую неполны по Тьюрингу — так как теоретически не всегда возможно порождение исполняемого кода по декларативному описанию.
Это иногда приводит к спорам о корректности термина «декларативное программирование» (менее спорным является «декларативное описание решения» или, что то же самое, «декларативное описание задачи»).</p>
</blockquote>
<p>Судя по наличию такой оговорки, ставится под сомнение наличие «чисто декларативных» языков.
И как только пришлось задуматься над это мыслью, то сразу стало очевидным, что какой бы декларативный язык программирования не существовал,
то в нем должна быть как минимум одна императивная конструкция, которая будет запускать поиск решения!
Ведь любой синоним слова «выполнить» или «запустить» по определению будет императивом!</p>
<p>Например в языке Prolog, который обычно и приводят в качестве примера декларативного языка программирования, &ldquo;замаскированным&rdquo; императивным оператором является знак вопроса.
Он кажется естественным и логичным, как же без него? Но по своей сути, это императивная конструкция!</p>
<p>Тоже самое касается и языка SQL. Он тоже как бы декларативный, но неожиданно все его команды являются императивными по сути. <em>SELECT</em>, <em>CREATE</em>, <em>ALTER</em>, <em>DROP</em>, <em>INSERT</em>, <em>UPDATE</em>, <em>DELETE</em> и т. д., а декларативными являются только описания условий их выполнения!</p>
<p>В результате, у меня так и не получилось найти чисто-декларативный язык программирования без императивных операторов (может быть, Вики права и такого языка программирования и вовсе не существует?).</p>
<h2 id="а-что-отличает-декларативные-языки-программирования-от-императивных">А что отличает декларативные языки программирования от императивных?<a class="td-heading-self-link" href="#%d0%b0-%d1%87%d1%82%d0%be-%d0%be%d1%82%d0%bb%d0%b8%d1%87%d0%b0%d0%b5%d1%82-%d0%b4%d0%b5%d0%ba%d0%bb%d0%b0%d1%80%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d1%8b%d0%b5-%d1%8f%d0%b7%d1%8b%d0%ba%d0%b8-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%be%d1%82-%d0%b8%d0%bc%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d1%8b%d1%85" aria-label="Heading self-link"></a></h2>
<p>Согласно определению, декларативными языками программирования их называют из-за возможности записать некие условия в декларативном стиле.
Но кроме этого, в декларативных языках как правило присутствует и некий внутренний механизм поиска решений.
Подобный &ldquo;вычислитель&rdquo; есть и в SQL и  Prolog и во многих других декларативных языках.</p>
<p>Интересно, а является ли внутренняя система поиска решений обязательным признаком декларативного стиля программирования или это только особенность конкретного языка программирования, которая не зависит от декларативного стиля написания кода?</p>
<p>Чтобы проверить данные предположения, можно было попробовать написать классическую декларативную программу на императивном языке, у которого отсутствует внутренний механизм поиска решений.</p>
<p>А заодно, таким образом можно будет и изучить вопрос, получится ли написать программу в декларативном стиле используя обычный императивный язык программирования?</p>
<p>Для примера, решил попробовать повторить уже классическую программу в декларативном стиле на Прологе.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#000">parent</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Tom&#34;</span><span style="color:#000;font-weight:bold">,</span><span style="color:#4e9a06">&#34;Jake&#34;</span><span style="color:#000;font-weight:bold">).</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">parent</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Janna&#34;</span><span style="color:#000;font-weight:bold">,</span><span style="color:#4e9a06">&#34;Jake&#34;</span><span style="color:#000;font-weight:bold">).</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">parent</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Tom&#34;</span><span style="color:#000;font-weight:bold">,</span><span style="color:#4e9a06">&#34;Tim&#34;</span><span style="color:#000;font-weight:bold">).</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">male</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Tom&#34;</span><span style="color:#000;font-weight:bold">).</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">male</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Tim&#34;</span><span style="color:#000;font-weight:bold">).</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">male</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Jake&#34;</span><span style="color:#000;font-weight:bold">).</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">female</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Janna&#34;</span><span style="color:#000;font-weight:bold">).</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">brother</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">X</span><span style="color:#000;font-weight:bold">,</span><span style="color:#000">Y</span><span style="color:#000;font-weight:bold">)</span><span style="color:#ce5c00;font-weight:bold">:-</span><span style="color:#000">parent</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Z</span><span style="color:#000;font-weight:bold">,</span><span style="color:#000">X</span><span style="color:#000;font-weight:bold">),</span><span style="color:#000">parent</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Z</span><span style="color:#000;font-weight:bold">,</span><span style="color:#000">Y</span><span style="color:#000;font-weight:bold">),</span><span style="color:#000">male</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">X</span><span style="color:#000;font-weight:bold">),</span><span style="color:#000">male</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Y</span><span style="color:#000;font-weight:bold">),</span><span style="color:#000">X</span><span style="color:#a40000">\</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">Y</span><span style="color:#000;font-weight:bold">.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">?</span> <span style="color:#000">brother</span>
</span></span></code></pre></div><p>Получилась вот такая функционально - эквивалентная программа на С++, которая максимально приближена по стилю к декларативному прототипу:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">enum</span> <span style="color:#000">sex_</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">male</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">female</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">human</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">typedef</span> <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">vector</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">human</span> <span style="color:#ce5c00;font-weight:bold">*&gt;</span> <span style="color:#000">parent_</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">human</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">const</span> <span style="color:#204a87;font-weight:bold">char</span> <span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">name</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">sex_</span> <span style="color:#000">sex</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">parent_</span> <span style="color:#000">parent</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">human</span> <span style="color:#000">Tom</span><span style="color:#000;font-weight:bold">{</span><span style="color:#4e9a06">&#34;Tom&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">male</span><span style="color:#000;font-weight:bold">,{}};</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">human</span> <span style="color:#000">Janna</span><span style="color:#000;font-weight:bold">{</span><span style="color:#4e9a06">&#34;Janna&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">female</span><span style="color:#000;font-weight:bold">,{}};</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">human</span> <span style="color:#000">Jake</span><span style="color:#000;font-weight:bold">{</span><span style="color:#4e9a06">&#34;Jake&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">male</span><span style="color:#000;font-weight:bold">,{</span><span style="color:#ce5c00;font-weight:bold">&amp;</span><span style="color:#000">Tom</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">&amp;</span><span style="color:#000">Janna</span><span style="color:#000;font-weight:bold">}};</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">human</span> <span style="color:#000">Tim</span><span style="color:#000;font-weight:bold">{</span><span style="color:#4e9a06">&#34;Tim&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">male</span><span style="color:#000;font-weight:bold">,{</span><span style="color:#ce5c00;font-weight:bold">&amp;</span><span style="color:#000">Tom</span><span style="color:#000;font-weight:bold">}};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">vector</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">human</span> <span style="color:#ce5c00;font-weight:bold">*&gt;</span> <span style="color:#000">humans</span><span style="color:#000;font-weight:bold">{</span><span style="color:#ce5c00;font-weight:bold">&amp;</span><span style="color:#000">Tom</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">&amp;</span><span style="color:#000">Janna</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">&amp;</span><span style="color:#000">Jake</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">&amp;</span><span style="color:#000">Tim</span><span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#000">brothers</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">[](</span><span style="color:#000">human</span> <span style="color:#ce5c00;font-weight:bold">*</span> <span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">human</span> <span style="color:#ce5c00;font-weight:bold">*</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#000">intersec</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">[](</span><span style="color:#000">parent_</span> <span style="color:#ce5c00;font-weight:bold">&amp;</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">parent_</span> <span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#f57900">elem_a</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#000">a</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#f57900">elem_b</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#204a87;font-weight:bold">if</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">elem_a</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">elem_b</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">elem_a</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">elem_b</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#204a87">true</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#204a87">false</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">b</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">!=</span> <span style="color:#000">b</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">a</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">sex</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">male</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">b</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">sex</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">male</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">intersec</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">parent</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">parent</span><span style="color:#000;font-weight:bold">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#f57900">a</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#000">humans</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#f57900">b</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#000">humans</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87;font-weight:bold">if</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">brothers</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">cout</span> <span style="color:#ce5c00;font-weight:bold">&lt;&lt;</span> <span style="color:#000">a</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">name</span> <span style="color:#ce5c00;font-weight:bold">&lt;&lt;</span> <span style="color:#4e9a06">&#34; and &#34;</span> <span style="color:#ce5c00;font-weight:bold">&lt;&lt;</span> <span style="color:#000">b</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">name</span> <span style="color:#ce5c00;font-weight:bold">&lt;&lt;</span> <span style="color:#4e9a06">&#34;</span><span style="color:#4e9a06">\n</span><span style="color:#4e9a06">&#34;</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre></div><p>Конечно, текст на С++ получается значительно многословней, чем вариант на Прологе, но по сути, это почти дословное повторение декларативного стиля написания кода.
Тем более, не стоит забывать про рассуждения в начале статьи об изначальном выборе концепции при создании языка
и &ldquo;принуждении&rdquo; программистов пользоваться только одной, изначально выбранной парадигмой разработки.</p>
<p><strong>Таким образом, можно с высокой долей уверенности утверждать, что теоретически можно писать код одновременно в разных стилях.</strong></p>
<p>Но что тогда мешает в рамках одного языка программирования писать с использованием императивного и декларативного стиля?
Неужели только убежденность создателей языков в том, что императивный и декларативный стили программирования  являются взаимоисключающими?
И только из-за этого получаются языки программирования, синтаксис которых подходит для использования одной единственной парадигмы?</p>
<p><em>Но если это так, то что мешает попробовать разработать синтаксис языка программирования, в котором можно было бы использовать сразу императивный и декларативный стили программирования одновременно?</em></p>
<h2 id="что-мешает-совместить-императивный-и-декларативный-стили-написания-в-рамках-одной-программы">Что мешает совместить императивный и декларативный стили написания в рамках одной программы?<a class="td-heading-self-link" href="#%d1%87%d1%82%d0%be-%d0%bc%d0%b5%d1%88%d0%b0%d0%b5%d1%82-%d1%81%d0%be%d0%b2%d0%bc%d0%b5%d1%81%d1%82%d0%b8%d1%82%d1%8c-%d0%b8%d0%bc%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d1%8b%d0%b9-%d0%b8-%d0%b4%d0%b5%d0%ba%d0%bb%d0%b0%d1%80%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d1%8b%d0%b9-%d1%81%d1%82%d0%b8%d0%bb%d0%b8-%d0%bd%d0%b0%d0%bf%d0%b8%d1%81%d0%b0%d0%bd%d0%b8%d1%8f-%d0%b2-%d1%80%d0%b0%d0%bc%d0%ba%d0%b0%d1%85-%d0%be%d0%b4%d0%bd%d0%be%d0%b9-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d1%8b" aria-label="Heading self-link"></a></h2>
<p>В любой компьютерной программе всегда существует разделение кода на описание данных и на языковые конструкции для их обработки, т.е. фактически это разделение <strong>на данные</strong> и <strong>на функции</strong>.
Мне кажется, что основная сложность, которая не дает использовать разные стили программирования в рамках одного языка, это необходимость разделять описываемые сущности на «данные» и «управляющие конструкции».
Ведь это свойство (необходимость разделения сущностей на &ldquo;данные&rdquo; и &ldquo;функции&rdquo;), является неотъемлемой частью любого языка программирования.</p>
<p>Это не удивительно, ведь на заре становления ИТ индустрии, создатели первых языков программирования ориентировались исключительно на императивный стиль, потому что назначением любого компилятора было - преобразовать исходный текст программы в машинные инструкции. И на примерах модульного, структурного и объекто-ориентированного подходах показана и доказана необходимость оформления исполняемого кода в выделенные процедуры с последующей их группировкой в модули и классы.</p>
<p>А декларативный стиль написания программ стал появляться только после создания  высокоуровневых языков программирования.
И основная цель создания данных языков сместилась на поиск решения конечного пользователя, а не на упрощение генерации бинарных файлов с машинными инструкциями.
Если внимательно посмотреть на приведенные выше примеры кода, то можно заметить, что в них определения данных и операторы для их обработки идут вперемешку, (для примера на С++ это определение лямбд функции), что кардинально отличается от императивного подхода.</p>
<p>Так может быть, основная особенность декларативного стиля как раз и заключается в том, что в нем не разделяются «данные» и «действия над данными»?
Или как вариант, можно не указывать выполняемые действия над данными вовсе (как в некоторых SQL конструкциях)?</p>
<p>Может быть как раз именно эта особенность (возможность последовательной записи программного кода в соответствии с собственными логическими рассуждениями,
в которых могут перемежаться «данные» и «функции», как это происходит при человеческом мыслительном процессе),
не дает в полной мере реализовать возможность совмещения императивных и декларативных стилей программирования?</p>
<p><em>И если это так, тогда можно попробовать разработать такой синтаксис, который будет поддерживать определение как данных, так и декларацию функций в рамках единого потока языковых конструкций!</em></p>
<h2 id="проверка-гипотезы-в-новом-языке-программирования">Проверка гипотезы в новом языке программирования<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b0-%d0%b3%d0%b8%d0%bf%d0%be%d1%82%d0%b5%d0%b7%d1%8b-%d0%b2-%d0%bd%d0%be%d0%b2%d0%be%d0%bc-%d1%8f%d0%b7%d1%8b%d0%ba%d0%b5-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f" aria-label="Heading self-link"></a></h2>
<p>Для поверки данного предположения, я решил добавить в свой <a href="/ru/blog/2021/05/24/%D0%BD%D0%B5%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D0%B0%D1%8F-%D0%BA%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D1%8F-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81%D0%B0-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/">новый язык программирования</a>
(синтаксис которого допускает определение функций в одном потоке с описанием обрабатываемых данных), недостающие алгоритмические конструкции, которые позволяли бы реализовать императивный стиль программирования,
несмотря на изначальную ориентацию только на декларативную парадигму.</p>
<p>Правда с учетом изначальных ограничений синтаксиса нового языка (запрет на применение операторов в виде зарезервированных ключевых слов),
в качестве оператора проверки условия была выбрана синтаксическая конструкция, соответствующая по смыслу термину «следует»,
т.е. тире и угловая скобка «<strong>-&gt;</strong>».</p>
<p>В результате, условный оператор получился практически математический, который легко объединяется в последовательности для реализации проверки множественных условий вида «else if».
А для объединения сразу нескольких логического операторов между собой и для отделения их от последующего действия, операторы проверки условия можно заключать в круглые скобки.</p>
<p>В общем случае условный оператор в новом языке программирования имеет вид:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a40000">условие</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#a40000">действие</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a40000">или</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">условие</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#a40000">действие</span><span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a40000">или</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">условие</span><span style="color:#0000cf;font-weight:bold">1</span> <span style="color:#ce5c00;font-weight:bold">||</span> <span style="color:#a40000">условие</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#a40000">действие</span><span style="color:#000;font-weight:bold">}</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#a40000">действие</span> <span style="color:#a40000">иначе</span><span style="color:#000;font-weight:bold">};</span>
</span></span></code></pre></div><p>Или расширенный вариант, для наглядности записанный с отступами:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">условие</span><span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#a40000">действие</span><span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">условие</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#a40000">действие</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">условие</span><span style="color:#0000cf;font-weight:bold">3</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#a40000">действие</span><span style="color:#0000cf;font-weight:bold">3</span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#a40000">действие</span><span style="color:#000">_иначе</span><span style="color:#000;font-weight:bold">};</span>
</span></span></code></pre></div><p>Тогда и операторы циклов можно будет записать практически аналогично, только выбрав в качестве оператора, не оператор следования,
а следование с возвратом (раз уж нужно указывать циклическое действие).</p>
<p>Цикл пока:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">условие</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">&lt;-&gt;</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#a40000">тело</span> <span style="color:#a40000">цикла</span><span style="color:#000;font-weight:bold">};</span>
</span></span></code></pre></div><p>счетный цикл для работы с итератором:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">счетчик</span><span style="color:#000">_или_данные</span><span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000;font-weight:bold">)</span><span style="color:#ce5c00;font-weight:bold">?</span> <span style="color:#ce5c00;font-weight:bold">&lt;-&gt;</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#a40000">тело</span> <span style="color:#a40000">цикла</span><span style="color:#000;font-weight:bold">};</span>
</span></span></code></pre></div><p>В этом случае, решение тестового примера декларативной программы на Прологе можно будет легко оформить, как в  императивном, так и в декларативном стилях одновременно!</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    м :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;муж.&#34;</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    ж :<span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;жен.&#34;</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    human @<span style="color:#ce5c00;font-weight:bold">=</span> term<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">пол</span><span style="color:#ce5c00;font-weight:bold">=</span>, <span style="color:#000">parent</span><span style="color:#ce5c00;font-weight:bold">=[</span>,<span style="color:#ce5c00;font-weight:bold">])</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Tom @<span style="color:#ce5c00;font-weight:bold">=</span> human<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">пол</span><span style="color:#ce5c00;font-weight:bold">=</span>м<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Janna @<span style="color:#ce5c00;font-weight:bold">=</span> human<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">пол</span><span style="color:#ce5c00;font-weight:bold">=</span>ж<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Jake @<span style="color:#ce5c00;font-weight:bold">=</span> human<span style="color:#ce5c00;font-weight:bold">(</span>м, <span style="color:#ce5c00;font-weight:bold">[</span><span style="color:#000;font-weight:bold">&amp;</span>Tom, <span style="color:#000;font-weight:bold">&amp;</span>Janna,<span style="color:#ce5c00;font-weight:bold">])</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Tim @<span style="color:#ce5c00;font-weight:bold">=</span> human<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">пол</span><span style="color:#ce5c00;font-weight:bold">=</span>м, <span style="color:#000">parent</span><span style="color:#ce5c00;font-weight:bold">=[</span><span style="color:#000;font-weight:bold">&amp;</span>Tom,<span style="color:#ce5c00;font-weight:bold">])</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    brother<span style="color:#ce5c00;font-weight:bold">(</span>h1, h2<span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;=</span> <span style="color:#000">$h1</span>!<span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">$h2</span>, <span style="color:#000">$h1</span>.пол<span style="color:#ce5c00;font-weight:bold">==</span>м, <span style="color:#000">$h2</span>.пол<span style="color:#ce5c00;font-weight:bold">==</span>м, <span style="color:#000">$h1</span>.parent <span style="color:#000;font-weight:bold">&amp;</span> <span style="color:#000">$h2</span>.parent<span style="color:#000;font-weight:bold">;</span> 
</span></span><span style="display:flex;"><span>    // Оператор «<span style="color:#000;font-weight:bold">&amp;</span>» побитовое «И» для чисел или операция пересечения для множеств
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Запись алгоритма поиска решения в императивном стиле 
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">h1</span><span style="color:#ce5c00;font-weight:bold">=</span>human!, <span style="color:#000">h2</span><span style="color:#ce5c00;font-weight:bold">=</span>human!<span style="color:#ce5c00;font-weight:bold">)</span>? &lt;-&gt; <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ce5c00;font-weight:bold">(</span>brother<span style="color:#ce5c00;font-weight:bold">(</span>h1, h2<span style="color:#ce5c00;font-weight:bold">))</span> -&gt; <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            @print<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">$h1</span>, <span style="color:#000">$h2</span>, «<span style="color:#4e9a06">\n</span>»<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">}</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Краткая запись алгоритма поиска решения в императивном стиле 
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">h1</span><span style="color:#ce5c00;font-weight:bold">=</span>human!, <span style="color:#000">h2</span><span style="color:#ce5c00;font-weight:bold">=</span>human!<span style="color:#ce5c00;font-weight:bold">)</span>? &lt;-&gt; 
</span></span><span style="display:flex;"><span>        brother<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">$h1</span>, <span style="color:#000">$h2</span><span style="color:#ce5c00;font-weight:bold">)</span> -&gt; @print<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">$h1</span>, <span style="color:#000">$h2</span>, «<span style="color:#4e9a06">\n</span>»<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Запись поиска решения в декларативном стиле
</span></span><span style="display:flex;"><span>    brother<span style="color:#ce5c00;font-weight:bold">(</span>human!, human!<span style="color:#ce5c00;font-weight:bold">)</span>?<span style="color:#000;font-weight:bold">;</span>
</span></span></code></pre></div><p>Примерно это и требовалось показать!</p>
<h3 id="зы">З.Ы.<a class="td-heading-self-link" href="#%d0%b7%d1%8b" aria-label="Heading self-link"></a></h3>
<p>Я почти закончил эксперименты с синтаксисом языка.
И теперь, после добавления в него недостающих алгоритмический конструкций (ветвления и циклов), планирую,
что следующая статья о новом языке программирования будет посвящена описанию его полного синтаксиса и публикации исходников прототипа компилятора для возможности поиграться на реальных примерах.</p>
<h3 id="ззы">З.З.Ы<a class="td-heading-self-link" href="#%d0%b7%d0%b7%d1%8b" aria-label="Heading self-link"></a></h3>
<p>В <a href="https://habr.com/ru/company/timeweb/blog/569422/comments/#comment_23301086">комментариях @gbg</a> привел очень простой ответ на один из поднятых вопросов.
Причем в более элегантном виде и без написания кода!</p>
<blockquote>
<p>Ну и пять копеечек про ООП. Как ни странно:</p>
<ol>
<li>В нем таки есть декларативная часть, все эти pubic, private, virtual, etc</li>
<li>Эта декларативная часть, внезапно, элегантно позволяет реализовывать декомпозицию и управление сложностью.</li>
<li>При наличии перегрузок, можно поиграть в алгебраическое мышление, рассматривая взаимодействие двух объектов как бинарную операцию.</li>
</ol>
<p>Ух ты, ООП - это обкатанная практикой технология, которая совмещает декларатив с императивом и вроде позволяет освоившим ее вкусно кушать и мягко спать!</p>
</blockquote>
<p><a href="https://habr.com/ru/companies/timeweb/articles/569422/">Ссылка на первую публикаци</a></p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-358d8b7408f85724d92f6f2c125e0958">Необычная концепция синтаксиса языка программирования</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2021-05-24" class="text-muted">24.05.2021</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/langs.jpeg"></p>


<div class="pageinfo pageinfo-primary">
<p>Внимание!!!</p>
<p>Данная статья содержит описание синтаксиса NewLnag предыдущей версии.</p>
<p>Актуальную версию синтаксиса языка можно посмотреть <a href="/ru/docs/">тут</a>.</p>

</div>

<p>Хочу представить на обсуждение читателей немного необычный концепт языка программирования, в котором отсутствует проблема,
присущая практически всем промышленным языкам -  постоянное увеличение сложности синтаксиса языка из-за его естественного развития по мере выхода новых версий и добавления новых фич.
Эта проблема описана в статье <a href="/ru/blog/complex-prog/">&ldquo;Простое сложное программирование&rdquo;</a> и <a href="/ru/blog/lang-final/">Какая &ldquo;идеальная&rdquo; цель развития у языков программирования?</a></p>
<p>После нескольких экспериментов с синтаксисом, хочется проверить выработанную идею на широкой аудитории <a href="https://habr.com/ru/companies/timeweb/articles/558738/">Хабра</a>, которая как нельзя лучше подходит для этих целей.</p>
<p>Особенности языка:</p>
<ul>
<li>Низкий порог входа и естественное ограничение уровня сложности в течение длительного времени даже при условии постоянного развития самого языка.</li>
<li>Возможность писать код программы как в декларативной, так и в императивной парадигме с использованием процедурного, модульного и объектно-ориентированного подхода.</li>
</ul>
<p>Ну и в соответствии с собственным наблюдением <a href="https://habr.com/ru/post/539674/">Хабр — ума палата</a>, буду рад любым комментариям и предложениям, которые помогут протестировать или улучшить предлагаемое решение.</p>
<h2 id="введение">Введение<a class="td-heading-self-link" href="#%d0%b2%d0%b2%d0%b5%d0%b4%d0%b5%d0%bd%d0%b8%d0%b5" aria-label="Heading self-link"></a></h2>
<p>Первой необычной особенностью языка является полное отсутствие зарезервированных ключевых слов.
Точнее, планируется использовать только одно единственное ключевое слово (название языка), которое может быть как главной точкой входа в приложение,
так и способом  доступа к настройкам языка под конкретную предметную область, например при необходимости реализации <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">DSL парадигмы</a>.</p>
<p>В настоящий момент название языка не выбрано, поэтому для примеров используется просто слово <em>lang</em>, которое в будущем будет изменено.</p>
<p>Данная особенность (отсутствие зарезервированных ключевых слов) реализуется за счет того, грамматика языка основана на использовании общеупотребительных символов и классических знаков препинания,
а все остальные букво-символьные последовательности при парсинге программы рассматриваются как &ldquo;токены&rdquo;.</p>
<p>Компилятор языка реализуется как <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%B0%D0%B9%D0%BB%D0%B5%D1%80">JIT</a> - преобразование исходного кода программы,
написанной на одном языке программирования, в эквивалентный исходный код на другом языке.
Первые эксперименты с синтаксисом я начинал на Python, но после осознания необходимости разработки не только интерпретатора,
но и компилятора непосредственно в исполняемый код, решил остановиться на C++. Хотя в принципе, язык реализации может быть любым.</p>
<p>Использование <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%B0%D0%B9%D0%BB%D0%B5%D1%80">транспиляции</a> при реализации компилятора решает сразу множество очевидных и не очень задач.
Сразу отпадает необходимость разрабатывать низкоуровневый компилятор в исполняемый процессорный код,
а в моем случае основным бонусом такого подхода становится возможность использования императивной парадигмы программирования за счет вставок кода непосредственно в исходный код приложения на языке реализации.</p>
<p>И именно этот момент позволяет естественно разделить декларативный и императивный  способ написания программы.
В этом случае в декларативной парадигме реализуется только одна из трех базовых управляющих конструкций,
необходимых и достаточных при реализации <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">любого алгоритма</a> — <em>следование</em>.</p>
<p>Другими словами, в декларативном стиле описывается только <em>последовательность</em> операций, которые следуют одна за другой,
но отсутствует возможность запрограммировать циклы или ветвление (переходы) по условию.
Из-за этого в декларативном стиле можно записать только следующие типы языковых конструкций:</p>
<ul>
<li>комментарий</li>
<li>определение переменной и присвоение ей значения</li>
<li>создание объекта и назначение его свойствам значений по умолчанию</li>
<li>создание функции (метода для всего класса объектов)</li>
<li>вызов функции или итератора</li>
<li>непосредственная вставка кода на языке реализации</li>
</ul>
<p>Так как цель текущей публикации - протестировать общую концепцию, то начну сразу с примеров без длинного описания подробностей, а некоторые нюансы буду комментировать по ходу дела.
Тем более, самая главная цель &ldquo;низкий порог входа&rdquo; само собой подразумевает возможность самостоятельно разобраться в синтаксисе.
Тем не менее, совсем без знаний языка реализации не обойтись и начальные знания в программировании на С/С++ все равно необходимы.</p>
<h2 id="привет-мир-в-императивной-парадигме">&ldquo;Привет, мир!&rdquo; в императивной парадигме<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%b8%d0%b2%d0%b5%d1%82-%d0%bc%d0%b8%d1%80-%d0%b2-%d0%b8%d0%bc%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d0%be%d0%b9-%d0%bf%d0%b0%d1%80%d0%b0%d0%b4%d0%b8%d0%b3%d0%bc%d0%b5" aria-label="Heading self-link"></a></h2>
<p>Определение обычной функции выполняется с помощью оператора присвоения &ldquo;:=&rdquo;, а программный код на языке реализации (в данном случае на C++)
заключается в фигурные скобки. Простой пример вывода строки на экран выглядит примерно так:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#000">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">str</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#34;&#34;</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">{</span> <span style="color:#000">printf</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;%s&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87;font-weight:bold">static_cast</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">char</span> <span style="color:#ce5c00;font-weight:bold">*&gt;</span><span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">$</span><span style="color:#000">str</span><span style="color:#000;font-weight:bold">));</span> <span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre></div><p>Функция <strong>print</strong> с аргументом по умолчанию в виде пустой строки внутри себя вызывает обычный printf из стандартной библиотеки.</p>
<p>Соответственно &ldquo;Привет, мир!&rdquo; в императивной парадигме программирования будет выглядеть тривиально:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#!/bin/lang
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>    <span style="color:#000">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">str</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#34;&#34;</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">{</span> <span style="color:#000">printf</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;%s&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87;font-weight:bold">static_cast</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">char</span> <span style="color:#ce5c00;font-weight:bold">*&gt;</span><span style="color:#000;font-weight:bold">(</span><span style="color:#a40000">$</span><span style="color:#000">str</span><span style="color:#000;font-weight:bold">));</span> <span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a40000">@</span><span style="color:#000">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Привет, мир!</span><span style="color:#4e9a06">\n</span><span style="color:#4e9a06">&#34;</span><span style="color:#000;font-weight:bold">);</span>
</span></span></code></pre></div><p>Из примера видно, что обращение к аргументам внутри С++ кода происходит с использованием символа <strong>$</strong>, который указывается вначале именованного аргумента.
Кроме этого, для доступа к аргументам функции можно обращаться по их порядковым номерам начиная с первого ($1, $2, $3 и т. д.).
Зарезервированный аргумент $0 содержит сам объект, метод которого вызывается или <em>nullptr</em>, если функция не принадлежит объекту.</p>
<p><em>Обычные</em> функции являются именно обычными функциями в понимании С/С++.
Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д.
Технически, код такой функции парсится на предмет замены использованных аргументов,
специальным образом декорируется её имя и добавляются специальные маркеры для идентификации содержимого.
После этого исходный текст готов для сборки обычным С++ компилятором для превращения в динамическую библиотеку
и после её загрузки функцию можно будет вызвать в любой момент (для вызова функции перед её именем необходимо указать символ <strong>&quot;@&quot;</strong>).</p>
<p>Непосредственное выполнение файла в режиме интерпретатора происходит в два этапа. На первом этапе из текста программы генерируется временный С++ файл с исходным кодом всех функций, этот файл компилируется gcc и собирается динамическая библиотека.</p>
<p>На втором этапе, собранная динамическая библиотека загружается средой выполнения, а исходный текст программы начинает последовательно выполнятся интерпретатором (все строки, за исключением определений функций).</p>
<p>Есть еще вариант, когда вместо интерпретации кода программы, генерируется С++ файл не только для функций, но и для основной части приложения.
Тогда на выходе компилятора будет уже обычный бинарный файл, хотя в том случае оперативно поправить текст программы уже не получится.</p>
<h2 id="логическое-программирование-в-декларативной-парадигме">Логическое программирование в декларативной парадигме<a class="td-heading-self-link" href="#%d0%bb%d0%be%d0%b3%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b5-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b2-%d0%b4%d0%b5%d0%ba%d0%bb%d0%b0%d1%80%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d0%be%d0%b9-%d0%bf%d0%b0%d1%80%d0%b0%d0%b4%d0%b8%d0%b3%d0%bc%d0%b5" aria-label="Heading self-link"></a></h2>
<p>Так как самым известным языком логического программирования в декларативном стиле считается Prolog,
поэтому приведу простой пример программы Brother (поиска братьев) на Прологе и эквивалентный ему код на новом языке.</p>
<p>Prolog:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    male<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Tom&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span>.
</span></span><span style="display:flex;"><span>    male<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Tim&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span>.
</span></span><span style="display:flex;"><span>    male<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Jake&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span>.
</span></span><span style="display:flex;"><span>    female<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Janna&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span>.
</span></span><span style="display:flex;"><span>    parent<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Tom&#34;</span>,<span style="color:#4e9a06">&#34;Jake&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span>.
</span></span><span style="display:flex;"><span>    parent<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Janna&#34;</span>,<span style="color:#4e9a06">&#34;Jake&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span>.
</span></span><span style="display:flex;"><span>    parent<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Tom&#34;</span>,<span style="color:#4e9a06">&#34;Tim&#34;</span><span style="color:#ce5c00;font-weight:bold">)</span>.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    brother<span style="color:#ce5c00;font-weight:bold">(</span>X,Y<span style="color:#ce5c00;font-weight:bold">)</span>:- parent<span style="color:#ce5c00;font-weight:bold">(</span>Z,X<span style="color:#ce5c00;font-weight:bold">)</span>,parent<span style="color:#ce5c00;font-weight:bold">(</span>Z,Y<span style="color:#ce5c00;font-weight:bold">)</span>,male<span style="color:#ce5c00;font-weight:bold">(</span>X<span style="color:#ce5c00;font-weight:bold">)</span>,male<span style="color:#ce5c00;font-weight:bold">(</span>Y<span style="color:#ce5c00;font-weight:bold">)</span>,X<span style="color:#4e9a06">\=</span>Y.
</span></span></code></pre></div><p>Вывод: <strong>(Jake, Tim) (Tim, Jake)</strong></p>
<p>Тот же самый пример:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#!/bin/lang</span>
</span></span><span style="display:flex;"><span>    human:<span style="color:#ce5c00;font-weight:bold">=</span>@term<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">sex</span><span style="color:#ce5c00;font-weight:bold">=</span>,parent<span style="color:#ce5c00;font-weight:bold">=)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Tom:<span style="color:#ce5c00;font-weight:bold">=</span>@human<span style="color:#ce5c00;font-weight:bold">(</span>male<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Janna:<span style="color:#ce5c00;font-weight:bold">=</span>@human<span style="color:#ce5c00;font-weight:bold">(</span>female<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Jake:<span style="color:#ce5c00;font-weight:bold">=</span>@human<span style="color:#ce5c00;font-weight:bold">(</span>male, <span style="color:#ce5c00;font-weight:bold">(</span>Tom, Janna,<span style="color:#ce5c00;font-weight:bold">))</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Tim:<span style="color:#ce5c00;font-weight:bold">=</span>@human<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">sex</span><span style="color:#ce5c00;font-weight:bold">=</span>male, <span style="color:#000">parent</span><span style="color:#ce5c00;font-weight:bold">=(</span>Tom,<span style="color:#ce5c00;font-weight:bold">))</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    human::brother<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">test</span><span style="color:#ce5c00;font-weight:bold">=</span>human!<span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;=</span> <span style="color:#000">$0</span>!<span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">$test</span>, <span style="color:#000">$0</span>.sex<span style="color:#ce5c00;font-weight:bold">==</span>male, @intersec<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">$0</span>.parent, <span style="color:#000">$test</span>.parent<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    human.brother?
</span></span></code></pre></div><p>Вывод: <strong>[Tim.brother(Jake), Jake.brother(Tim),]</strong></p>
<p>Надеюсь, что синтаксис интуитивно понятен, особенно при наличии эквивалентного кода на Прологе, но на всякий случай поясню отдельные моменты.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    human:<span style="color:#ce5c00;font-weight:bold">=</span>@term<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">sex</span><span style="color:#ce5c00;font-weight:bold">=</span>,parent<span style="color:#ce5c00;font-weight:bold">=)</span><span style="color:#000;font-weight:bold">;</span>
</span></span></code></pre></div><p>В этой строке создается объект с именем &ldquo;human&rdquo; и двумя свойствами &ldquo;sex&rdquo; и &ldquo;parent&rdquo;,
значения которых по умолчанию не определены, а родителем является системный объект &ldquo;term&rdquo;.
Использование символа <strong>&quot;@&quot;</strong> в начале термина обозначает вызов существующей функции с параметрами, указанными в скобках.
В данном случае вызывается конструктор системного объекта &ldquo;term&rdquo;, а возвращаемым результатом является новый термин &ldquo;human&rdquo;,
который можно воспринимать как один экземпляр класса, так и как имя целого класса, если он будет выступать в качестве родителя для других объектов.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    Tom:<span style="color:#ce5c00;font-weight:bold">=</span>@human<span style="color:#ce5c00;font-weight:bold">(</span>male<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Janna:<span style="color:#ce5c00;font-weight:bold">=</span>@human<span style="color:#ce5c00;font-weight:bold">(</span>female<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Jake:<span style="color:#ce5c00;font-weight:bold">=</span>@human<span style="color:#ce5c00;font-weight:bold">(</span>male, <span style="color:#ce5c00;font-weight:bold">(</span>Tom, Janna,<span style="color:#ce5c00;font-weight:bold">))</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    Tim:<span style="color:#ce5c00;font-weight:bold">=</span>@human<span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">parent</span><span style="color:#ce5c00;font-weight:bold">=(</span>Tom,<span style="color:#ce5c00;font-weight:bold">)</span>, <span style="color:#000">sex</span><span style="color:#ce5c00;font-weight:bold">=</span>male<span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#000;font-weight:bold">;</span>
</span></span></code></pre></div><p>Первые две строки создают объекты &ldquo;Tom&rdquo; и &ldquo;Janna&rdquo;, у которых свойство &ldquo;sex&rdquo; установлено в значения &ldquo;male&rdquo; и &ldquo;female&rdquo; соответственно.
А в последней строке при создании объекта Tim значения свойств задается с указанием их имени.</p>
<p>Конструкции <em>(Tom, Janna,)</em> и <em>(Tom,)</em>, это определение константного литерала с типом словарь, которые присваиваются указанным свойствам.</p>
<p>Чтобы определение словаря не путать с указанием аргументов при вызове функции, в нем содержится обязательная финальная запятая перед закрывающей скобкой.
Это правило (финальная запятая перед закрывающей скобкой) действует и при определении литерала массива, только для записи которого используются скобки не круглые, а квадратные (например <strong>[,]</strong> - пустой массив).
Основным отличием словаря от массива, заключаются в способах доступа к их элементам.
Для доступа к элементу массива используется целочисленный индекс, а в словаре может быть использован как индекс, так и имя элемента при его наличии.
Между словарем и массивом есть еще отличия, но сейчас они не принципиальны.</p>
<p>И предпоследняя строка в примере:</p>
<p>human::brother(test=human <em>!</em>) <strong>&amp;&amp;=</strong> <em>$0</em> != <em>$test</em>, <em>$0</em>.sex==male, @intersec(<em>$0</em>.parent, <em>$test</em>.parent);</p>
<p>это определение <i>простой чистой</i> функции &ldquo;brother&rdquo; для всех объектов, производных от &ldquo;human&rdquo;.
Данная функция принимает один именованный аргумент &ldquo;test&rdquo;, значением по умолчанию которого является <em>итератор</em> объектов класса &ldquo;human&rdquo;.</p>
<p>Оператор <strong>&amp;&amp;=</strong> означает определение <em>простой чистой</em> функции, т. е. функции без внешних зависимостей,
которая не имеет доступа к глобальному контексту, а результат выполнения которой является логическое значение,
которое вычисляется по схеме <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%8A%D1%8E%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">логическое И</a> для всех условий, указанных в теле функции через запятую.</p>
<p>Выполнение и вывод результата выполнения программы происходит в строке
<code>human.brother?</code></p>
<p>Восклицательный и вопросительный знаки обозначают <a href="https://ru.wikipedia.org/wiki/%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80">итератор</a>. Итератор &ldquo;<strong>!</strong>&rdquo; возвращает один текущий элемент из коллекции и передвигает указатель на следующий,
а итератор &ldquo;<strong>?</strong>&rdquo; возвращает сразу всю коллекцию объектов целиком.</p>
<p>Другими словами при выполнении строки программы <em>human.brother <strong>?</strong></em> происходит последовательный перебор всей коллекции объектов типа &ldquo;human&rdquo;,
где у каждого объекта выполняется функция &ldquo;brother&rdquo; с аргументами по умолчанию.
А так как в качестве аргумента по умолчанию указан итератор <em>human <strong>!</strong></em>, то в качестве аргумента последовательно предается каждый из элементов указанного класса.
По сути, при выполнении этой строки происходит полный перебор всех возможных комбинаций объектов класса &ldquo;human&rdquo; каждый с каждым.</p>
<blockquote>
<p>Более подробное описание работы итератора и причина выбора такого синтаксиса  опубликовано в отдельной статье <a href="https://habr.com/ru/company/timeweb/blog/559916/">Лаконичный итератор для декларативного синтаксиса</a></p>
</blockquote>
<p>Результат выполнения будет состоять из тех пар объектов, для которых функция &ldquo;brother&rdquo; вернет истину, т.е. результат выполнения будет массив из двух пар объектов <strong>[Tim.brother(Jake), Jake.brother(Tim),]</strong>.</p>
<h2 id="формулировка-проверяемой-концепции">Формулировка проверяемой концепции<a class="td-heading-self-link" href="#%d1%84%d0%be%d1%80%d0%bc%d1%83%d0%bb%d0%b8%d1%80%d0%be%d0%b2%d0%ba%d0%b0-%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d1%8f%d0%b5%d0%bc%d0%be%d0%b9-%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%86%d0%b8%d0%b8" aria-label="Heading self-link"></a></h2>
<p>Тестируемая концепция заключается в следующем. Синтаксис языка программирования состоит как бы из двух частей,
каждая из которых является относительно независимой и в тоже время они связаны между собой.</p>
<p>Первая часть сложная  — предназначена для описания алгоритмов в <em>императивном стиле</em> на обычном языке программирования,
поэтому внутри функций разработчику доступны все возможности языка реализации.</p>
<p>Вторая часть простая (по сравнению с первой) — предназначена только для логического описания задачи в <em>декларативном стиле</em>.
Именно эта часть используется для начального уровня использования, а естественное ограничение только на последовательное выполнение операторов
(т.е. отсутствие циклов и ветвлений) не доставляет чрезмерных сложностей в понимании исходного текста программы даже в будущем по мере развития языка.</p>
<p>Связь между двумя вариантами синтаксиса прозрачна и реализуется за счет совместного использования переменных и функций,
декларация и обращение к которым происходит в едином стиле в обоих случаях за счет унификации синтаксиса на уровне использования знаков препинания.</p>
<p>Сейчас я специально не привожу полного синтаксиса и подробного описания остальных возможностей языка, т.к. компилятор пока не готов для публичной презентации.
Но буду крайне благодарен за любой отклик или дельные предложения в отношении предложенной концепции.</p>
<p>Особенно это касается возможных конфликтов по синтаксису в представленных примерах.</p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-8e46bcfa1e536a4f19ec0380d04dfc8a">Простое сложное программирование</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2021-04-15" class="text-muted">15.04.2021</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/complex-prog/complex-prog.jpeg"></p>
<p>В очередной раз увидел на Хабре статью про сложное дело под названием «программирование».
И то, что программирование действительно является делом не простым воспринимается как факт и обычно не требует какого либо подтверждения.</p>
<p>Но понятие «сложность» сродни термину «куча».
Для кого-то и пять кокосов это не куча, а кого-то съел один и «больше не хочется» - значит для него и единственного кокоса будет много.</p>
<p>Так и со сложностью ПО. Вроде бы увеличение сложности является для всех очевидным и наблюдается во всех сферах применения IT технологий,
да и сами языки программирования по мере своего развития становятся все сложнее,
а вот оценивать «сложность» с помощью численных метрик — дело заведомо неблагодарное, но и «нельзя управлять тем, что невозможно измерить &hellip;».</p>
<p>Обычно разговоры о «сложности» включают в себя только оценочные суждения без какой либо численной оценки.
А так как лично меня интересует вопрос сложности языков программирования,
то я решил  посчитать сложность реализации компилятора gcc в каких нибудь условных попугаях.
Вдруг можно будет увидеть какие нибудь закономерности?</p>
<h2 id="выбор-попугаев-для-измерения">Выбор «попугаев» для измерения<a class="td-heading-self-link" href="#%d0%b2%d1%8b%d0%b1%d0%be%d1%80-%d0%bf%d0%be%d0%bf%d1%83%d0%b3%d0%b0%d0%b5%d0%b2-%d0%b4%d0%bb%d1%8f-%d0%b8%d0%b7%d0%bc%d0%b5%d1%80%d0%b5%d0%bd%d0%b8%d1%8f" aria-label="Heading self-link"></a></h2>
<p>Я не стал придумывать свои или вычислять эмпирические метрики <a href="https://habr.com/ru/company/intel/blog/106082/">программного кода</a>,
и в качестве «попугая» решил взять самую простую метрику SLOC (англ. Source Lines of Code) — количество строк исходного текста компилятора,
которая очень легко вычисляется.</p>
<p>Правда, с её помощью можно будет оценивать сложность языка только при следующем допущении — сложность языка должна находиться в прямой зависимости от сложности его реализации,
если для простых синтаксических конструкций будет требовать меньше кода, чем для более сложных.</p>
<p>Конечно, использование метрики «количество строк исходного кода» имеет и свои недостатки,
т.к. она сильно зависит от используемого языка программирования, стиля оформления исходного кода и в общем случае не позволяет сравнивать несколько разных проектов между собой.</p>
<p>Но для численной оценки сложности кода в рамках <strong>одного проекта</strong>, метрика SLOC подходит хорошо.</p>
<h2 id="методика-подсчета-sloc">Методика подсчета SLOC<a class="td-heading-self-link" href="#%d0%bc%d0%b5%d1%82%d0%be%d0%b4%d0%b8%d0%ba%d0%b0-%d0%bf%d0%be%d0%b4%d1%81%d1%87%d0%b5%d1%82%d0%b0-sloc" aria-label="Heading self-link"></a></h2>
<p>Изначально попробовал использовать простой bash скрипт с поиском по маске и подсчетом числа строк в файлах исходника через <code>wc -l</code>.
Но через некоторое время стало понятно, что приходится изобретать очередной велосипед.</p>
<p><img alt="Ну вы поняли" src="/ru/blog/complex-prog/bag.jpeg"></p>
<p>Поэтому решил взять уже готовый. После быстрого поиска остановился на утилите <a href="https://dwheeler.com/sloccount/">SLOCCount</a>,
которая умеет анализировать почти три десятка типов исходников.</p>
<h3 id="список-типов-файлов-для-автоматического-анализа">Список типов файлов для автоматического анализа<a class="td-heading-self-link" href="#%d1%81%d0%bf%d0%b8%d1%81%d0%be%d0%ba-%d1%82%d0%b8%d0%bf%d0%be%d0%b2-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2-%d0%b4%d0%bb%d1%8f-%d0%b0%d0%b2%d1%82%d0%be%d0%bc%d0%b0%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b3%d0%be-%d0%b0%d0%bd%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0" aria-label="Heading self-link"></a></h3>
<pre tabindex="0"><code>    1. Ada (.ada, .ads, .adb) 
    2. Assembly (.s, .S, .asm) 
    3. awk (.awk) 
    4. Bourne shell and variants (.sh) 
    5. C (.c) 
    6. C++ (.C, .cpp, .cxx, .cc) 
    7. C shell (.csh) 
    8. COBOL (.cob, .cbl) as of version 2.10 
    9. C# (.cs) as of version 2.11 
    10. Expect (.exp) 
    11. Fortran (.f) 
    12. Haskell (.hs) as of version 2.11 
    13. Java (.java) 
    14. lex/flex (.l) 
    15. LISP/Scheme (.el, .scm, .lsp, .jl) 
    16. Makefile (makefile) — not normally shown. 
    17. Modula-3 (.m3, .i3) as of version 2.07 
    18. Objective-C (.m) 
    19. Pascal (.p, .pas) 
    20. Perl (.pl, .pm, .perl) 
    21. PHP (.php, .php[3456], .inc) as of version 2.05 
    22. Python (.py) 
    23. Ruby (.rb) as of version 2.09 
    24. sed (.sed) 
    25. SQL (.sql) — not normally shown. 
    26. TCL (.tcl, .tk, .itk) 
    27. Yacc/Bison (.y) &lt;/code&gt;
</code></pre><p>Причем, считает не просто количество строк исходного текста, но и умеет игнорировать комментарии,
исключает из подсчета дубли файлов (сравнивает их хеш суммы), а также выводит расчетную трудоемкость,
примерную оценку стоимости разработки анализируемого проекта и другие характеристики.</p>
<p>Меня изначально интересовал объем исходников на С/С++ и может быть еще на Ассемблере, если таких файлов окажется достаточно много.
Но после начала работы очень обрадовался, что не стал изобретать велосипед, а взял готовую тулзу,
т.к. она отдельно считала статистику исходных файлов синтаксического анализатора Yacc/Bison (.y),
который и определяет фактическую сложность парсера (читай сложность синтаксиса языка программирования).</p>
<p>Старые исходники gcc брал с <a href="https://gcc.gnu.org/mirrors.html">https://gcc.gnu.org/mirrors.html</a>, но перед запуском анализатора удалил каталоги других компиляторов (ada, fortran, java и т.д.),
чтобы они не попадали в итоговую статистику.</p>
<h2 id="результаты-в-попугаях">Результаты в попугаях<a class="td-heading-self-link" href="#%d1%80%d0%b5%d0%b7%d1%83%d0%bb%d1%8c%d1%82%d0%b0%d1%82%d1%8b-%d0%b2-%d0%bf%d0%be%d0%bf%d1%83%d0%b3%d0%b0%d1%8f%d1%85" aria-label="Heading self-link"></a></h2>
<p><img src="/ru/blog/complex-prog/graph1.jpeg"></p>
<p><strong>Итоговая статистика</strong></p>
<p><img src="/ru/blog/complex-prog/graph2.png"></p>
<p><strong>Объем кода синтаксического анализатора Yacc/Bison</strong></p>
<p><img src="/ru/blog/complex-prog/graph3.jpeg"></p>
<p><strong>Объем общей которой базы GCC (только для языков C и C++)</strong></p>
<h2 id="выводы">Выводы<a class="td-heading-self-link" href="#%d0%b2%d1%8b%d0%b2%d0%be%d0%b4%d1%8b" aria-label="Heading self-link"></a></h2>
<p>К сожалению, синтаксический анализатор Yacc/Bison использовался только до 3 версии, а после его использование свелось на нет.
Поэтому оценить сложность синтаксиса С/С++ с помощью объема кода парсера можно лишь примерно до 1996-98 года,
после чего его стали постепенно выпиливать, т.е. чуть менее, чем за десять лет.
Но даже за этот период объем кодовой базы синтаксического анализатора вырос двукратно, что примерно соответствует по времени реализации стандарта C99.</p>
<p>Но даже если не учитывать код синтаксического анализатора, то объем общей кодовой базы так же коррелирует с внедрением новых стандартов C++: C99, С11 и C14.</p>
<p>На графике не видно выраженного пика для С+17 и следующих версий, но предполагаю,
что при текущем объеме кодой базы (более 4 миллионов строк только С и С++ кода), несколько тысяч строк,
необходимых для поддержки синтаксических конструкций новых стандартов просто незаметно.</p>
<h3 id="вывод-первый---очевидный-рост-сложности-инструментов-разработки">Вывод первый - очевидный. Рост сложности инструментов разработки<a class="td-heading-self-link" href="#%d0%b2%d1%8b%d0%b2%d0%be%d0%b4-%d0%bf%d0%b5%d1%80%d0%b2%d1%8b%d0%b9---%d0%be%d1%87%d0%b5%d0%b2%d0%b8%d0%b4%d0%bd%d1%8b%d0%b9-%d1%80%d0%be%d1%81%d1%82-%d1%81%d0%bb%d0%be%d0%b6%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d0%b8%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d0%be%d0%b2-%d1%80%d0%b0%d0%b7%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b8" aria-label="Heading self-link"></a></h3>
<p>Фактически на примере проекта GCC можно видеть постоянный и неотвратимый рост сложности рабочих инструментов программистов.</p>
<p>И как бы не говорили о деградации разработки в статье <a href="https://habr.com/ru/company/itelma/blog/550620/">&ldquo;Хорошие времена рождают слабаков&rdquo;</a>,
о системном кризисе программного обеспечения, который носит поколенческом характер, но мне кажется тут дело немного в другом.</p>
<p>Обновление персонала и как следствие — необходимость обучения новых сотрудников старым наработкам,
тут дело не сколько в передаче знаний, сколько в возможности эти знания усваивать.</p>
<p>Причем возможность усвоения знаний для разных поколений будет разная, но не из-за того, что предыдущее поколение было умнее, а у нового поколения не хватает толку в этом разобрать.
Просто изменяется окружение и усложняются рабочие инструменты, по сравнению с теми, которые были в ходу у предыдущего поколения.</p>
<h3 id="вывод-второй--порог--входа">Вывод второй — порог  входа<a class="td-heading-self-link" href="#%d0%b2%d1%8b%d0%b2%d0%be%d0%b4-%d0%b2%d1%82%d0%be%d1%80%d0%be%d0%b9--%d0%bf%d0%be%d1%80%d0%be%d0%b3--%d0%b2%d1%85%d0%be%d0%b4%d0%b0" aria-label="Heading self-link"></a></h3>
<p>Представьте, что нужно «сделать свой сайт». Естественно нужно определить, какую CMS для него использовать и какой брать хостинг.
И если с хостингом вопрос решается очень просто, конечно же в TimeWeb, да еще и <a href="https://timeweb.com/ru/services/hosting?utm_source=rsashka&utm_medium=timeweb&utm_campaign=timeweb-bring-a-friend">с бонусом по ссылке</a>, то при выборе CMS приходится подумать.</p>
<p>И если для простых сайтов существуют и простые решения, то для тех,  кто не ищет легких путей существует CMS Drupal,
который примечателен тем, что имеет фантастически высокий порог входа для начала использования.</p>
<p><img alt="Сложность внедрения Drupal" src="/ru/blog/complex-prog/drupal.jpeg"></p>
<p>Это я к чему? При использовании любого инструмента, как и языка программирования, существует некий минимальный уровень комфортного использования.
Причем этот уровень прямо пропорционально связан с размером той целевой аудитории, для которой он предназначен.
Точнее, размер возможной аудитории определяется в том числе и требованиями к уровню начальных знаний и квалификации потенциального пользователя.</p>
<h3 id="итоговый-вывод--не-утешительный">Итоговый вывод — не утешительный<a class="td-heading-self-link" href="#%d0%b8%d1%82%d0%be%d0%b3%d0%be%d0%b2%d1%8b%d0%b9-%d0%b2%d1%8b%d0%b2%d0%be%d0%b4--%d0%bd%d0%b5-%d1%83%d1%82%d0%b5%d1%88%d0%b8%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9" aria-label="Heading self-link"></a></h3>
<p>Если рассматривать увеличение сложности только самого ПО, то это одно дело. Вот к примеру:</p>
<p><strong>Статистика ядра Linux с вики</strong></p>
<pre tabindex="0"><code>17 сентября 1991: Linux версии 0.01 (10 239 строк кода).
14 марта 1994: Linux версии 1.0.0 (176 250 строк кода).
Март 1995: Linux версии 1.2.0 (310 950 строк кода).
9 июня 1996: Linux версии 2.0.0 (777 956 строк кода).
25 января 1999: Linux версии 2.2.0, изначально довольно недоработанный (1 800 847 строк кода).
4 января 2001: Linux версии 2.4.0 (3 377 902 строки кода).
18 декабря 2003: Linux версии 2.6.0 (5 929 913 строк кода).
23 марта 2009: Linux версии 2.6.29, временный символ Linux — тасманский дьявол Tuz (11 010 647 строк кода).
22 июля 2011: релиз Linux 3.0 (14,6 млн строк кода).
24 октября 2011: релиз Linux 3.1.
15 января 2012: релиз Linux 3.3 преодолел отметку в 15 млн строк кода.
23 февраля 2015: первый релиз-кандидат Linux 4.0 (более 19 млн строк кода).
7 января 2019: первый релиз-кандидат Linux 5.0 (более 26 млн строк кода).
</code></pre><p>А что делать, если сложность программного обеспечения накладывается на тенденцию постоянного усложнения самих рабочих инструментов?
Ведь постоянное развитие языков программирования неизбежно повышает порог входа для всех начинающих и только усугубляет проблему сложности разработки ПО.</p>
<p>Другими словами, не зависимо от того, как хорошо документирован код и как полно он покрыт тестами,
через некоторое время устаревают используемые инструменты, завершаются жизненные циклы внешних зависимостей,
и самое главное, приходят новые люди взамен тех, кто разработал или сумел разобраться в системе.</p>
<p>И у новых людей возникает необходимость разбираться в системе с самого начала, но в других начальных условиях.
И из-за этого, сложность изучения системы для всех новых людей будет выше просто по факту того,
что изменились внешние условия и усложнились рабочие инструменты, которыми приходится использовать новым сотрудникам.</p>
<p>Понятно, что чем дальше, тем проще уже не будет. Ведь область IT , это среда с самой высокой конкуренцией.
И как уж тут не вспомнить Льюиса Кэррола, что его крылатое выражение</p>
<blockquote>
<p>Нужно бежать со всех ног, чтобы только оставаться на месте, а чтобы куда-то попасть, надо бежать как минимум вдвое быстрее!</p>
</blockquote>
<p>Ведь это относится не только к Алисе в стране чудес, но и ко всем информационным технологиям в целом!</p>
<p><a href="https://habr.com/ru/companies/timeweb/articles/551754/">Первоначальная публикация</a></p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-0f103385a5e3972851e7afd1b3ae2ebe">Какая «идеальная» цель развития у языков программирования?</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2021-04-07" class="text-muted">07.04.2021</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/lang-final/lang-final.jpeg"></p>
<p>С постоянной периодичностью появляется информация о выходе новой версии того или иного языка программирования.
И с каждой новой версией расширяются его возможности, добавляются новые синтаксические конструкции или иные улучшения.</p>
<p>И это очень сильно напоминает развитие технологий, как и в любой другой области техники.
Когда с очередным этапом совершенствуются создаваемые творения.
Быстрее, выше, сильнее … и одновременно значительно сложнее.</p>
<p>Об этой проблеме меня заставила задуматься первоапрельская статья <a href="https://habr.com/ru/post/550270/">«Доказательное программирование»</a>.</p>
<p>Понятно, что дата публикации статьи говорит сама за себя.
Тем не менее, новые стандарты С++, постоянно выходящие спецификации Java или новый синтаксис у PHP 8,
невольно заставляют задуматься, а в нужную ли сторону идет развитие языков программирования?
Ведь большинство нововведений добавляют сложность в основной рабочий инструмент и решая одни проблемы, неявно добавляя множество других.</p>
<p>А что должно быть в конце прогресса у развития такой дисциплины как программирование?
Или хотя бы у одного конкретного языка? Ради достижения какой конечной «идеальной» цели разрабатываются новые стандарты языков программирования?</p>
<p>Если фантазировать об идеальной конечной цели развития, например транспорта,
то это будет мгновенное перемещение на любое расстояние с произвольной полезной нагрузкой и нулевым потреблением энергии.</p>
<p>Или, например, какая может быть идеальная цель у медицины? <del>Бедные не болели, а богатые не выздоравливали,</del> вероятно, лечение любых болезней и биологическое бессмертие.</p>
<p>Конечно, «идеальная» цель это очень упрощенное понятие. Фактически, «идеальная» это синоним «недостижимая»,
т.к. она всегда будет упираться необходимость соблюдать компромисс между различными взаимно-исключающими граничными условиями.</p>
<p>Но сравнивать разработку средств программирования с процессом развития в других технических дисциплинах напрямую нельзя.
Ведь при создание конечного продукта в любой технической области, все сложные производственные операции,
которые требуют непосредственного участия человека, практически всегда можно разделить на отдельные, более простые части или этапы.</p>
<p>Это делается, в том числе и для того, чтобы сложность одной выполняемой операции не была запредельной для исполнителя.
Но как это можно сделать при разработке программного обеспечения?</p>
<p>В данном случае, я имею ввиду конечную ограниченность возможностей одного конкретного человека в противовес возможностям разделения технологических процессов на отдельные этапы,
каждый из которых может выполняться совершенно разными людьми (как пример, это обычный конвеер с его разделением труда на элементарные операции
или узкая специализация врачей-специалистов в одной конкретной области).</p>
<p>Ведь даже сложно себе представить фантастическую организацию труда программистов в виде конвеера:</p>
<ul>
<li>Первый разработчик пишет только интерфейсы функций и их вызовы, после чего передает код второму сотруднику.</li>
<li>Второй пишет в тексте программы только условия проверки и безусловные переходы и передает текст третьему.</li>
<li>Третий отвечает за написание циклов и общее форматирование кода и т.д.
и результате ожидаемо получится полный бред.</li>
</ul>
<p>Из-за этого индустрия разработки ПО вынуждена идти по экстенсивному пути развития (т.е. за счет увеличения используемых в производстве ресурсов).
Современные промышленные языки программирования имеют очень богатые возможности по разделению кода приложения на отдельные функции/модули/компоненты,
что позволяет вести разработку сложного программного продукта сразу множеству сотрудников одновременно.</p>
<p>Но и такое развитие имеет естественное ограничение. И этим ограничением является сам человек,
так как каждый разработчик должен знать и уметь пользоваться своим рабочим инструментом, т.е. языком программирования.</p>
<p>Если взять приведенную выше аналогию с конвеером, то в ней каждый рабочий должен был бы досконально знать б<strong>о</strong>льшую часть используемых станков
и инструментов на всем заводе, независимо от того, какую <strong>одну</strong> конкретную операцию он выполняет на своем рабочем месте.</p>
<p>Ведь парадокс развития языков программирования заключается в том, что добавляя новые возможности и синтаксические конструкции,
мы усложняем рабочий инструмент, предназначенный как для совместного, так и для индивидуального использования!</p>
<p>И получается, что одновременно с процессом постоянного наращивания возможностей средств разработки идет
и обратный процесс — увеличение сложности разработки кода отдельно взятым разработчиком.
Фактически, это и есть то самое взаимоисключающее непреодолимое противоречие.</p>
<p>Может быть именно поэтому невозможно найти «серебряную пулю», которая бы повышала производительность труда одного программиста?
Ведь внимание и возможности человека не безграничны.
И любые новшества и улучшения рабочего инструмента программиста вынужденно толкают всю IT индустрию на экстенсивный путь развития.</p>
<p>Возможно следует разрабатывать принципиально новые подходы, а не гнаться за синтаксическим сахаром в языках программирования из прошлого века?
Или и вовсе не париться, продолжать пользоваться тем, что есть, а теория дедушки Дарвина все сама расставит по своим местам?</p>
<p><a href="https://habr.com/ru/companies/timeweb/articles/551224/">Первоначальная публикация</a></p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-c770759fb02136df5f3e7fa94ce88af1">Проблема логических языков программирования</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2021-01-09" class="text-muted">09.01.2021</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/langs.jpeg"></p>
<p>Некоторое время назад я писал про <a href="/ru/blog/inter-prog/">«Интернациональное программирование на естественных языках»</a>,
в которой попытался представить достойную цель для абстрактного языка программирования,
попробовав примерить на него роль связующего звена между миром программистов с компьютерами и не программистов.</p>
<p>Но в результате оказалось, что это не нужно в принципе, т.к. «не программистам» просто не требуется учиться писать программы.
А если иногда такое желание и возникает, то вполне хватает обычных формализованных языков программирования,
которых уже сейчас насчитывается наверно более десяти тысяч.</p>
<p>А пользователи, как программисты, так и не программисты, просто хотят решать возникающие перед ними задачи.
И хотя задачи бывают совершенно разные, но если способ (алгоритм) её решения известен, то выбрать язык для её решения не составит никакого труда.</p>
<p>За исключением одного класса задач. Задач, решение которых нельзя описать в виде алгоритма.
Но можно указать некие критерии, которым должно удовлетворять искомое решение.<br>
Я имею ввиду логические языки программирования и <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BB%D0%BE%D0%B3_%28%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29">Пролог</a>, как самый яркий представитель этого класса.</p>
<p>Еще помню воспоминание из юности, когда удалось достать дискету с этим языком.
Ух, с каким задором горели мои глаза, когда мне казалось, ну вот, еще чуть-чуть и будет создана система с базой знаний,
у которой и можно будет получить заветный ответ 42 на любой вопрос.</p>
<p>Так почему этого так и не случилось? В чем проблема Пролога, да и любой системы / языка программирования,
назначение которых анализировать факты и искать ответы на вопросы?</p>
<p>Эта проблема называется <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B9_%D0%B2%D0%B7%D1%80%D1%8B%D0%B2">«Комбинаторный взрыв»</a> - экспоненциальная (или более) зависимость времени работы алгоритма от количества входных данных.
И есть как минимум два решения этой проблемы.</p>
<h2 id="подходы-к-написанию-программ">Подходы к написанию программ<a class="td-heading-self-link" href="#%d0%bf%d0%be%d0%b4%d1%85%d0%be%d0%b4%d1%8b-%d0%ba-%d0%bd%d0%b0%d0%bf%d0%b8%d1%81%d0%b0%d0%bd%d0%b8%d1%8e-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc" aria-label="Heading self-link"></a></h2>
<p>Прежде чем переходить к частностям, следует сказать пару слов про парадигмы программирования.
Обычно противопоставляют между собой два разных стиля в написании программ: <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">императивный</a> и <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">декларативный</a>.</p>
<p>Императивный — это классический вариант написания программы, при котором программист сам задает шаги алгоритма для получения конечного результата.
А сам текст программы состоит из последовательности команд, которые читают, сохраняют и обрабатывают данные или вызывают другие команды.</p>
<p>Декларативный — в этом стиле программист описывает условия задачи и правила для получения требуемого результата,
но не требуется детально описывать все шаги работы алгоритма, оставляя их на усмотрения компьютера.</p>
<p>Именно к декларативному стилю относится язык Пролог, да и все остальные логические языки программирования.
К декларативному стилю написания программ следует относить и язык структурированных запросов (SQL).</p>
<p>И проблема под называнием <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D0%B9_%D0%B2%D0%B7%D1%80%D1%8B%D0%B2">«комбинаторный взрыв»</a> сильнее всего оказывает негативное влияние как раз на подобные языки.
Ведь в императивном подходе программист сам отвечает за последовательность выполняемых команд, и если он запрограммировал алгоритм полного перебора всех возможных вариантов решений, то он сам себе злобный Буратино.</p>
<p>Другое дело, программирование в декларативном стиле. Разработчик хоть и может указать ограничения, которые следует применять при поиске решения,
но это возможно только в том случае, когда известен алгоритм решения задачи.
Но если алгоритм решения  известен, то проще использовать императивный стиль, как раз и реализуя этот алгоритм!</p>
<p>Поэтому основное применения языков программирования в декларативном стиле — отказаться от необходимости описания четкого алгоритма поиска решения,
отдав это компьютеру на откуп. Для которого самое простое решение «в лоб» - полный перебор возможных вариантов.</p>
<p>Именно в этом случае и начинается экспоненциальный рост времени выполнения алгоритма.
И начиная с определенного порога, время ожидания ответа становится неприемлемым для реального использования.
Это и означает «Комбинаторный взрыв», резкий («взрывной») рост времени выполнения алгоритма при увеличении размера входных данных.</p>
<h2 id="проблема-поиска-решений">Проблема поиска решений<a class="td-heading-self-link" href="#%d0%bf%d1%80%d0%be%d0%b1%d0%bb%d0%b5%d0%bc%d0%b0-%d0%bf%d0%be%d0%b8%d1%81%d0%ba%d0%b0-%d1%80%d0%b5%d1%88%d0%b5%d0%bd%d0%b8%d0%b9" aria-label="Heading self-link"></a></h2>
<p>В языке Пролог эта проблема решалась за счет использования механизма отката и  отсечений.
Иногда еще уточняли про «красное» и «зеленое» отсечение решений.
Но в любом случае, это были <strong>алгоритмические</strong> механизмы для ограничения количества размера дерева возможных решений,
а необходимость их применения все равно остается на программисте.</p>
<p>Но чтобы их правильно реализовывать, нужно знать алгоритм решения, что опять возвращает нас к утверждению о том,
что если известен алгоритм, то и программировать его удобнее в императивном стиле.</p>
<p>А если полный алгоритм решения задачи не известен (или не подходит, например из-за большого времени для его работы),
то в результате остается либо увеличивать производительность системы, чтобы сократить время выполнения алгоритма,
либо искать другое решение, в том числе, сокращая вычислительную сложность поиска решений, например, исключая заведомо не подходящие данные,
чтобы уменьшить возможные комбинации их перебора.</p>
<h3 id="масштабирование-производительности">Масштабирование производительности<a class="td-heading-self-link" href="#%d0%bc%d0%b0%d1%81%d1%88%d1%82%d0%b0%d0%b1%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bf%d1%80%d0%be%d0%b8%d0%b7%d0%b2%d0%be%d0%b4%d0%b8%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d0%be%d1%81%d1%82%d0%b8" aria-label="Heading self-link"></a></h3>
<p>Увеличение производительности тоже бывает разным и работает не во всех случаях.
Вертикальное масштабирование производительности одного узла вычислительной среды имеет свой естественный предел.
И даже многократное увеличение скорости работы компьютера может лишь отдалить порог терпения пользователя при ожидании получения результата,
но не в состоянии принципиально решить саму проблему.</p>
<p>Другое дело горизонтальное масштабирование, при котором выполнение алгоритма запускается на отдельных узлах, которые параллельно решают одну и ту же задачу.
Такой способ масштабирования позволяет уже значительно сократить время получения итогового результата для сложных вычислительных задач.
И хотя это способ является решением «в лоб», но успехи в области data science доказывают успешность такого подхода.</p>
<p>Конечно, у горизонтального масштабирования тоже есть подводные камни.
В первую очередь, сам алгоритм должен допускать возможность параллельного выполнения независимо от других узлов.
Также требуется автоматизация управления заданиями, самими вычислительными узлами, да и всей системой в целом.</p>
<p>Тут частично может помочь парадигма функционального программирования, которая ограничивает результат вычисления функций только входными параметрами
и результатом выполнения других функций, но сам результат не зависит от состояния системы или иных внешних данных.</p>
<h3 id="поиск-обобщенного-решения">Поиск обобщенного решения<a class="td-heading-self-link" href="#%d0%bf%d0%be%d0%b8%d1%81%d0%ba-%d0%be%d0%b1%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%bd%d0%be%d0%b3%d0%be-%d1%80%d0%b5%d1%88%d0%b5%d0%bd%d0%b8%d1%8f" aria-label="Heading self-link"></a></h3>
<p>Вторым способом решения решения проблемы комбинаторного взрыва является уменьшение вычислительной сложности решения.
Тут имеется ввиду не выбор другого алгоритма или решение задачи в символьном виде.
Если такое возможно, то все опять сразу сведется к императивному стилю программированию.</p>
<p>Я имею ввиду возможность поиска самого алгоритма решения.
Точнее не совсем алгоритма, а возможность применения к входным данным различные методы отбора, чтобы исключить необходимость их полного перебора.
По сути, это сводится к применению различных методов и механизмов обработки входных данных с учетом различных закономерностей.</p>
<p>Это возможно как алгоритмическими методами (откат и отсечение в Прологе), так и с применением машинного обучения,
которое очень хорошо справляется с поиском различных закономерностей.</p>
<p>Естественно, такой способ подходит не для всех классов задач. Он не подходит для выявления <strong>ВСЕХ возможных решений</strong>.
Но там где это не требуется, подобные способы уменьшения вычислительной сложности имеют право на существование.</p>
<p>Например, не требуется искать все возможные лекарства от конкретной болезни, достаточно <strong>одного</strong>, с учетом определенных ограничений, которое гарантированно подействует.</p>
<p>К тому же, даже при нахождении частных решений, всегда существует шанс, что с их помощью получится увидеть не очевидные на первый взгляд закономерности,
которые помогут показать новые пути алгоритмического уменьшения вычислительной сложности основной задачи.</p>
<h2 id="область-не-решаемых-задач">Область не решаемых задач<a class="td-heading-self-link" href="#%d0%be%d0%b1%d0%bb%d0%b0%d1%81%d1%82%d1%8c-%d0%bd%d0%b5-%d1%80%d0%b5%d1%88%d0%b0%d0%b5%d0%bc%d1%8b%d1%85-%d0%b7%d0%b0%d0%b4%d0%b0%d1%87" aria-label="Heading self-link"></a></h2>
<blockquote>
<p>Как вы считает, а реально ли создать язык логического программирования, который бы сам умел автоматизировать поиск решений для задач подобных классов? Или хотя бы имел в своем арсенале встроенные механизмы для автоматизации подобной деятельности?</p>
</blockquote>
<h3 id="результаты-опроса-из-оригинальной-публикацииhttpshabrcomruarticles536268">Результаты опроса из <a href="https://habr.com/ru/articles/536268/">оригинальной публикации</a><a class="td-heading-self-link" href="#%d1%80%d0%b5%d0%b7%d1%83%d0%bb%d1%8c%d1%82%d0%b0%d1%82%d1%8b-%d0%be%d0%bf%d1%80%d0%be%d1%81%d0%b0-%d0%b8%d0%b7-%d0%be%d1%80%d0%b8%d0%b3%d0%b8%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d0%be%d0%b9-%d0%bf%d1%83%d0%b1%d0%bb%d0%b8%d0%ba%d0%b0%d1%86%d0%b8%d0%b8httpshabrcomruarticles536268" aria-label="Heading self-link"></a></h3>
<pre tabindex="0"><code>- 57.47%    Ха-ха! То, что хочет автор и называется искусственным интеллектом (50 голосов)
- 27.59%    Поиск решений нельзя автоматизировать (24 голоса)
- 19.54%    Это уже есть и все давно придумано (17 голосов)
- 9.2%      Такой язык не нужен, т.к. нейросети могут всё (8 голосов)
- 3.45%     Свой вариант написал в комменатрии (3 голоса)
</code></pre><p>Проголосовали 87 пользователей. Воздержались 62 пользователя.</p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-849ec5b11ef9375c495caa904b271aae">Интернациональное программирование на естественных языках</h1>
	
	<div class="td-byline mb-4">
		
        
		<time datetime="2020-12-05" class="text-muted">05.12.2020</time>
        
	</div>
	<p><img alt="КДПВ" src="/ru/blog/langs.jpeg"></p>


<div class="pageinfo pageinfo-primary">
<p>Внимание!!!</p>
<p>Данная статья содержит описание синтаксиса NewLnag предыдущей версии.</p>
<p>Актуальную версию синтаксиса языка можно посмотреть <a href="/ru/docs/">тут</a>.</p>

</div>

<p>В последнее время часто попадаются на глаза статьи о новых языках программирования,
а так же различные рейтинги и прогнозы, связанные с популярностью компьютерных языков.</p>
<p>Заявляют о себе и новые <a href="https://habr.com/ru/company/testo_lang/blog/521682/">инструментальные средства</a>,
которые в своей работе используют  собственные форматы описания конфигурационных файлов или последовательности выполняемых команд,
которые так же очень сильно приближает их к понятию «язык программирования».</p>
<p>Цель написания данной статьи — формулировка ожиданий и возможной реализации абстрактного языка программирования,
который может стать универсальным инструментом для общения между компьютером и человеком.</p>
<h2 id="о-программистах">О программистах<a class="td-heading-self-link" href="#%d0%be-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%81%d1%82%d0%b0%d1%85" aria-label="Heading self-link"></a></h2>
<p>Если начинать с самого начала, то когда-то давно я слышал перефразированное высказывание,
«каждый программист должен написать свою базу данных, текстовый редактор и язык программирования».
И если первые две вещи я уже давным давно написал, то с языком программирования пока не сложилось.</p>
<p>Ведь как обычно создаются языки программирования?</p>
<p>У каждого программиста всегда есть какой-то своей предыдущий опыт:</p>
<ul>
<li>знания одного или нескольких языков программирования (как же без этого)</li>
<li>негативный опыт от их использования (в противном случае, если все устраивает, то зачем придумывать что-то новое?)</li>
<li>желания получить новые возможности (когда в существующих языках чего-то не хватает)</li>
</ul>
<p>А перед тем, как описывать синтаксис, выбирать ключевые слова и начинать основную работу:
лексер, парсер, базовые библиотеки, нужно дать ответ на основные вопросы:</p>
<ul>
<li>Компилятор/интерпретатор/транспилятор(JIT)?</li>
<li>Статическая или динамическая типизация?</li>
<li>Ручное управление памятью или автоматическое со сборщиком мусора?</li>
<li>Модель программирования: ООП, функциональное, структурное или что-то новое?</li>
<li>Разрешены ли вставки из других языков программирования и т. д.?</li>
</ul>
<p>У меня, наверно, как и у большинства читателей, присутствует опыт использования нескольких языков программирования.
Поэтому давно сложилось практика, что для решения задачи лучше взять известный язык или даже выучить новый, вместо того,
чтобы начинать писать собственный.</p>
<p>Тем более, что не хочется придумывать еще один язык просто ради галочки или ради самого языка.
Я считаю, что цель его создания должна быть за пределами потребностей самого разработчика.</p>
<p>И мне кажется, что удалось определить область, для которой разработка языка программирования может быть востребованной,
а потраченные на него усилия могут принести реальную пользу.</p>
<h2 id="о-не-программистах">О не программистах<a class="td-heading-self-link" href="#%d0%be-%d0%bd%d0%b5-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%81%d1%82%d0%b0%d1%85" aria-label="Heading self-link"></a></h2>
<p>Эта область — программирование для «не программистов» на «естественном» языке.
Я специально взял слова «не программистов» и «естественном» в кавычки, т.к. эти термины являются очень условными.</p>
<p>Ведь если не программист начинает программировать, то сам того не осознавая, он автоматически становится программистом ;-).
А «естественным» язык программирования быть не может по определению.
Точнее для компьютеров скорее всего «естественным» будет язык Assembler или набор машинных команд.</p>
<blockquote>
<p>Поэтому, цель максимум — приблизить язык программирования к естественному человеческому языку.</p>
</blockquote>
<p>Это не только сделает чтение текста программы более понятным для не профессионалов,
но и позволит начинать составлять программы просто освоив письменную речь, используя самый минимум основных правил.</p>
<p>Но в подобной формулировке кроется очень большая проблема!</p>
<blockquote>
<p>Любой язык программирования является интернациональным, т.к. его синтаксис не зависит от естественного языка, на котором общается программист.</p>
</blockquote>
<p>А если текст программы будет на &ldquo;естественном&rdquo; языке, то она станет понятной только для знающих этот язык,
одновременно становясь непонятной для всех остальных.</p>
<p>В качестве иллюстрации: <a href="http://espressocode.top/natural-language-programming/">раз</a> или <a href="https://habr.com/ru/post/268401/">два</a>.
Если пофантазировать насчет хотелок к такому языку, то видятся следующие требования и ограничения:</p>
<ul>
<li>Так как каждый пользователь является носителем своего родного естественного языка (или даже нескольких), то жестко задавать ключевые слова невозможно, из чего следует, что основой такого языка должны стать только правила пунктуации, но никак не лексика или грамматика.</li>
<li>Компилятор/транслятор должен уметь преобразовывать исходный текст программы не только в машинный код для компьютера, но в другой вариант &ldquo;естественного&rdquo; языка, чтобы пользователь мог работать с исходным текстом на известном ему &ldquo;естественном&rdquo; языке.</li>
<li>Очень хочется видеть в новом языке <del>толерантность</del> терпимость к очепяткам. Подобная «фича» присутствует в письме на естественном языке, и несмотря на наличие опечаток, практически всегда сохраняется смысл. Естественно, в данном случае не стоит доходить до фанатизма. Компилятор не читает мысли и не может в действительности «понять», что имел ввиду пользователь, и все же довольно часто можно игнорировать опечатки в тексте программы исходя из контекста (пусть и с выводом предупреждающих сообщений).</li>
</ul>
<p>Тем не менее, такой язык должен оставаться именно языком программирования со всеми  возможностями создания программ любого уровня сложности,
включая функциональное и объектно-ориентированное программирование и однозначное понимание написанного.</p>
<h2 id="о-гипотетическом-языке">О гипотетическом языке<a class="td-heading-self-link" href="#%d0%be-%d0%b3%d0%b8%d0%bf%d0%be%d1%82%d0%b5%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%bc-%d1%8f%d0%b7%d1%8b%d0%ba%d0%b5" aria-label="Heading self-link"></a></h2>
<p>Если взять за основу правила письменной речи, то основные соглашения и пунктуация для нового языка могут выглядеть примерно так:</p>
<ul>
<li>Любой текст состоит из предложений и комментариев. Предложения обрабатываются, а комментарии игнорируются.</li>
<li>Предложение состоит из последовательности терминов, литералов и символов, разделенных пробелами и знаками препинания и завершается символом конца предложения.</li>
<li>Термин — слитно написанная последовательность букв, цифр и символов &ldquo;:&rdquo; и &ldquo;_&rdquo;.</li>
<li>Литерал — константы, включаемые непосредственно в текст программы, тип которой определяется однозначно. Это символьные строки в кавычках, целые и вещественные числа, и некоторые специальные форматы (время, дата).</li>
<li>Символы — все остальное символы, которые не относятся к знакам препинания, пробельным символам, цифрам и буквам.</li>
<li>Знаки препинания — символы пунктуации, имеющие специальное значение при разборе текста программы:
<ul>
<li>«.»,«;»,«!»,«?»,«…»  — конец предложения.</li>
<li>«=» — присвоение значения.</li>
<li>&quot;&quot; (кавычки) — определение символьной строки.</li>
<li>«()» - передача параметров/аргументов или группировка операторов для определения приоритета выполнения операций.</li>
<li>«[]» - массив или обращение к элементу массива.</li>
<li>«{}» - включение в текст исходного кода программы на обычном языке программирования.</li>
<li>«$» — системная переменная.</li>
<li>«@» — системная функция.</li>
<li>«,» (запятая) — перечисление.</li>
<li>«:» (двоеточие) — список или логическая связь.</li>
</ul>
</li>
</ul>
<p>Если с символом присвоения, кавычками, круглыми и квадратными скобками все должно быть  более-менее понятно,
т.к. их назначение соответствует аналогичному в подавляющем большинстве языков программирования,
то про назначение остальных символов (фигурных скобок, двоеточия, запятой и системных функций/переменной), следует немного пояснить.</p>
<p>Раз цель гипотетического языка программирования все же написание программ,
то необходимо предусмотреть возможность делать вставки обычного программного кода без учета всех возможностей и неоднозначностей,
которые присущи любому естественному языку.</p>
<p>Так же эта возможность требуется для реализации низкоуровневых функций и для взаимодействия с внешними библиотеками.</p>
<p>При создании подобных вставок и могут использоваться фигурные скобки, весь текст между которыми будет вставляться в итоговый файл практически без обработки.</p>
<p>Для похожих целей служат и символы «$» — системная переменная и «@» — системная функция. Если такой символ поставить в начале слова,
тогда он станет обозначать объект с соответствующим назначением. Например «@exit» — будет означать функцию,
а «$var» — переменную с соответствующими именами, а сами объекты станут доступны как в обычном коде,
так и в программных вставках внутри фигурных скобок.</p>
<p>Аналогичным образом организуется и доступ к отдельным полям/методам объектов:
«объект@метод» или «объект$поле».</p>
<p>Символ запятая «,» применяется для указание последовательности равноправных логических блоков в одном предложении или для создания списков.</p>
<p>Символ двоеточия «:» используется для создания списков и для обозначения логической связи между двумя частями слова/текста, в том числе для указания полного пути модуля.</p>
<p>Например, создание списка:</p>
<p><code>В_строку: элемент 1, элемент 2, последний элемент.</code></p>
<pre tabindex="0"><code>Форматированный_список:
- элемент 1;
- элемент 2;
- последний элемент.
</code></pre><p>Логическое следствие/указание связи:</p>
<pre tabindex="0"><code>module:calc //термин «calc», который находится в модуле «module»
super:module:example$var //переменная «$var» которая находится в указанной иерархии.
</code></pre><p>Как можно заметить, использование знаков препинания взято из их прямого назначения, принятого в письменной речи,
что должно обеспечить определенный  компромисс между синтаксисом в стандартных языках программирования и письмом на естественном языке.</p>
<h2 id="о-компьютерах">О компьютерах<a class="td-heading-self-link" href="#%d0%be-%d0%ba%d0%be%d0%bc%d0%bf%d1%8c%d1%8e%d1%82%d0%b5%d1%80%d0%b0%d1%85" aria-label="Heading self-link"></a></h2>
<p>Так как речь идет все же о языке программирования, то не обойтись без стандартных алгоритмических конструкций: следования, ветвления и циклов.</p>
<p>Следование легко описывается обычными правилам письма на естественном языке.
В случае последовательного выполнения в одном предложении, операции и вызовы функций записываются последовательно через запятую.
Если они располагаются в разных предложениях, то они записываются так же друг за другом.
Причем форматирование по абзацам служит только для лучшего восприятия текста и логического разделения отдельных фрагментов.</p>
<p>При создании условных и циклических управляющих конструкций уже потребуются ключевые слова.
Но так как согласно исходным пожеланиям к языку, резервировать обычные термины для записи алгоритмических конструкций нельзя,
то перед ключевыми словами достаточно указывать символ системной функции, что позволит отличить обычный термин от ключевого (управляющего) слова.</p>
<p>Естественно, при программировании, данными терминами хоть и можно будет пользоваться, но делать это совсем не обязательно.
Так как при настройке под конкретный естественный язык, системным функциям и ключевым словам нужно обязательно присвоить конкретные термины и пользоваться уже ими, например:</p>
<pre tabindex="0"><code>перейти = @goto,
метка = @label,
продолжить = @continue,
прервать=@break и т.д.
</code></pre><p>И последняя по очереди, но наверно самая важная по сути конструкция: передача параметров  при вызовах функций.
Если стремиться к полностью естественному синтаксису, тогда мы получим тот самый естественный язык, который очень сложно анализировать.</p>
<p>Тем не менее, мне кажется, что можно скомбинировать оба два подхода, если отказаться от обязательного использования круглых скобок,
там, где это допустимо по синтаксису.</p>
<pre tabindex="0"><code>Компьютерный: функция(параметр1, функция2(), параметр3=значение).
Естественный: функция параметр1 функция2 параметр3=значение.
</code></pre><p>Но:</p>
<pre tabindex="0"><code>Компьютерный: функция( функция2(параметр) ).
Естественный: функция функция2(параметр).
Или так: функция (функция2 параметр).
</code></pre><p>Другими словами, для естественного порядка указания аргументов, скобки для функций и запятые между параметрами могут быть опущены.
Хотя их использование должно определяться в первую очередь целевым естественным языком, а не синтаксисом.</p>
<h2 id="о-возражениях">О возражениях<a class="td-heading-self-link" href="#%d0%be-%d0%b2%d0%be%d0%b7%d1%80%d0%b0%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f%d1%85" aria-label="Heading self-link"></a></h2>
<p>Предвижу обоснованные возражения против использования подобного языка со стороны программистов.
Программа на нем по любому получится значительно многословнее, чем с использованием строгого формального синтаксиса обычных компьютерных языков.</p>
<p>Поэтому напомню про его обязательное свойство - умение преобразовывать текст программы с одного языка на другой.
Это позволяет писать программы как с использованием строго формального синтаксиса без использования переопеределенных терминов на естественном языке,
так и преобразовывать исходный текст в &ldquo;естественный&rdquo; язык для &ldquo;не программиста&rdquo;.</p>
<p><a href="https://habr.com/ru/articles/531400/">Ссылка на первую публикаци</a></p>

</div>





    
	
  



          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="User mailing list" aria-label="User mailing list">
    <a target="_blank" rel="noopener" href="mailto:mail@newlang.net" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="" aria-label="">
    <a target="_blank" rel="noopener" href="" aria-label="">
      <i class=""></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="" aria-label="">
    <a target="_blank" rel="noopener" href="" aria-label="">
      <i class=""></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/rsashka/newlang" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="" aria-label="">
    <a target="_blank" rel="noopener" href="" aria-label="">
      <i class=""></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="" aria-label="">
    <a target="_blank" rel="noopener" href="" aria-label="">
      <i class=""></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2024
    <span class="td-footer__authors">The NewLang Authors</span></span><span class="td-footer__all_rights_reserved">Все права защищены</span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/js/main.js"></script>
<script defer src="/js/click-to-copy.js" crossorigin="anonymous"></script>
<script src='/js/tabpane-persist.js'></script>

  </body>
</html>
