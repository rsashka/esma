<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NewLang – Функции</title>
    <link>http://localhost:1313/ru/tags/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8/</link>
    <description>Recent content in Функции on NewLang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    
	  <atom:link href="http://localhost:1313/ru/tags/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Функции</title>
      <link>http://localhost:1313/ru/docs/types/funcs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/ru/docs/types/funcs/</guid>
      <description>
        
        
        &lt;p&gt;Определение функции происходит с помощью операторов &lt;a href=&#34;http://localhost:1313/ru/docs/ops/create/&#34;&gt;создания объектов&lt;/a&gt;,
имя функции должно соответствовать &lt;a href=&#34;http://localhost:1313/ru/docs/syntax/naming/&#34;&gt;правилам именования&lt;/a&gt;,
после которого указываются круглые скобки. &lt;em&gt;В настоящий момент поддерживается создание функций только в качестве статических объектов
с однократной инициализацией с помощью оператора &amp;lsquo;&lt;strong&gt;::=&lt;/strong&gt;&amp;rsquo;&lt;/em&gt;;&lt;/p&gt;
&lt;p&gt;Телом функции должен быть &lt;a href=&#34;http://localhost:1313/ru/docs/ops/block/&#34;&gt;блок кода&lt;/a&gt;, который располагается в пространстве имен определения этой функции.&lt;/p&gt;
&lt;p&gt;Функции поддерживают аргументы по умолчанию, а сами аргументы указываются как в Python,
т.е. вначале идут обязательные, далее идут аргументы со значениями по умолчанию,
где его имя отделяется от дефолтного значения знаком равно &amp;ldquo;&lt;strong&gt;=&lt;/strong&gt;&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Если функция допускает обработку произвольного количества аргументов,
то последним в списке параметров должно быть указано многоточие &amp;ldquo;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;У аргументов функции может быть указан допустимый тип данных.
Тип возвращаемого значения указывается после закрывающей скобки.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;У аргументов и у типа возвращаемого значения можно указать сразу несколько допустимых типов данных.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Для этого их необходимо перечислить через запятую и заключить в угловые скобки, т.е.&lt;/em&gt;*&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func(arg:&amp;lt;:Int8, :Int16, :Int32&amp;gt;): &amp;lt;:Int8, :Int16, :Int32&amp;gt; ::= {$arg*$arg};
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;*) Данная функциональность запланирована, но пока не реализована&lt;/p&gt;
&lt;p&gt;Для создания функций используются те же правила синтаксиса и операторы, что и для создания переменных, только после имени функции обязательно должны быть указаны круглые скобки.&lt;/p&gt;
&lt;p&gt;Синтаксис &lt;em&gt;NewLang&lt;/em&gt; поддерживает два типа функций: обычные и чистые функции.&lt;/p&gt;
&lt;h2 id=&#34;обычные-функции&#34;&gt;Обычные функции&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%d0%be%d0%b1%d1%8b%d1%87%d0%bd%d1%8b%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Обычная функция — такие функции являются именно обычными функциями в понимании С/С++.
Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д.
?????????????????????????????&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hello(str) ::= { 
  $printf ::= :Pointer(&amp;#39;printf(format:FmtChar, ...):Int32&amp;#39;);
  $printf(&amp;#39;call: %s&amp;#39;, $str);
  $str;
};
hello(&amp;#39;Привет, мир!&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;чистые-функции&#34;&gt;Чистые функции&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%d1%87%d0%b8%d1%81%d1%82%d1%8b%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Чистая функция — это тоже обычная функция, только в том смысле, какой в него вкладывает функциональное программирование.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;У чистой функции отсутствует доступ к контексту и глобальным переменным, поэтому она может обрабатывать только те данные,
которые были ей переданы в качестве аргументов&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Создание чистой функции происходит с помощью операторов &lt;strong&gt;:-&lt;/strong&gt; или &lt;strong&gt;::-&lt;/strong&gt;, а сам оператор заимствован из языка Пролог.
????????????????????????????????
Чистые фунции, так же как и обычные, тоже могут быть только статическими объектами, поэтому их нельзя определять с именами лоакльных объектов.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Sum2(arg1, arg2) ::- {$arg1+$arg2;}; # Тоже самое, но если функция с таким именем уже существует, то будет ошибка

???????????????????????????????????????????????????
Sum1(arg1, arg2) :- {$arg1+$arg2;}; # Создать или переопределить простую функцию, которая возвращает сумму аргументов
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;лямбда-функции&#34;&gt;Лямбда функции&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%d0%bb%d1%8f%d0%bc%d0%b1%d0%b4%d0%b0-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Лямбда функции, это анонимная функция без указания имени, т.е. вместо имени функции стоит подчерк, и её нельзя вызвать по имени.
Но зато лямбда функцию можно передавать как аругмент в другие функции, например при создании &lt;a href=&#34;http://localhost:1313/ru/docs/types/iter/&#34;&gt;итератора&lt;/a&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  _()::={ ... };
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;корутины&#34;&gt;Корутины&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%d0%ba%d0%be%d1%80%d1%83%d1%82%d0%b8%d0%bd%d1%8b&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Любую функцию можно определить как корутину (сопрограмма, Coroutine) - функция, выполнение которой можно прерываться явно методами языка программирования.
В отличие от прерывания выполнения потока (thread), который реализован средствами ОС и его переключение происходит неявно и в произвольный момент времени.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  func() ::= (){ ... };
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;переопределение-функций&#34;&gt;Переопределение функций&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#%d0%bf%d0%b5%d1%80%d0%b5%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b9&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Перегрузка функций по типам аргументов &lt;em&gt;NewLang&lt;/em&gt; отсуствует, поэтому нельзя создать несколько функций с однинаковым именем, но разными типами аругментов.
Но можно переопределить функцию с помощью оператора &amp;ldquo;&lt;strong&gt;[]=&lt;/strong&gt;&amp;rdquo;, а в теле новой функции обратиться к первоначальной функции по системному имени &amp;ldquo;&lt;strong&gt;$$&lt;/strong&gt;&amp;rdquo;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;«Требование от субтипов: пусть φ(x) — свойство, доказуемое относительно объектов x типа T. Тогда φ(y) должно быть истинно для объектов y типа S, где S — субтип T»12.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Это называется принципом подстановки Лисков.
Я не буду вдаваться в подробности, но основной смысл в том, что любое предусловие (для типов, данных или состояния)
параметров не может быть строже, чем для супертипа, а любое постусловие не может быть слабее, чем у супертипа13.
Эта формулировка связана с методологией контрактного программирования, зародившегося примерно в то же время.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Новая функция должна иметь аргументы, &lt;a href=&#34;http://localhost:1313/ru/docs/types/generics/&#34;&gt;совместимые&lt;/a&gt; с типом аргумента первоначальной функцией.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    func(arg:Int8):Int8 ::=  ... ;

    func(arg:Int16):Int16 =  ... ; # ОК Int8 -&amp;gt; Int16

    func(arg:String):Int16 =  ... ;  # Ошибка String -&amp;gt; Int16

    func(arg:Int16, arg2:Int16):Int16 =  ... ;

    func(arg:Integer, ...):Integer =  ... ; # ОК обобщенные тип
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
  </channel>
</rss>
