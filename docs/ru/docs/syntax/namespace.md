---
title: Пространства имен
weight: 20
---

*NewLang* поддерживает пространства имен, разделителем в которых, как и в С++, выступает двойное двоеточие "**::**".

Область имен может быть указана как для отдельного индетификатора, так и для целого [блока кода](/ru/docs/ops/block/).

В отличии от *namespace* в С++, области имен в *NewLnag* используются не только для организации кода в виде логических групп 
и с целью избежания конфликтов имен, но и для отнесения идентификатора, в котором явно указана область имен, к статическим объектам 
(память под которые выделяется на этапе комиляции программы).

Глобальное имя не может быть перекрыто макросом или локальной переменной при [разрешении имен (name lookup)](/ru/docs/syntax/naming/).
Создать глобальную (статическую) переменную в текущем пространстве имен можно указав переменную препроцессора **@::**.

Для использования пространства имен в [блоке кода](/ru/docs/ops/block/), его нужно указать перед открывающейся фигурной скобкой.
В таком именованном блоке кода завершающие "**::**" указывать не обязательно.

```bash
::var ::= 0; # Имя глобальной переменной в явном виде (не может быть перекрыто) 

ns { # Можно указать равнозначное ns::

    var ::= 0; # Имя ns::var (может быть перекрыто макросом или локальной переменной)
    @::var ::= 0; # Имя глобальной переменной ::ns::var (не может быть перекрыто) 

    name:: {
        var = 0; # Обращение к переменной ns::var
        var2 ::= 0; # Имя переменной будет ns::name::var2
        ::var = 1; # Переменная из глобального пространства имен
    };

    :: { # Глобальное пространство имен
        var = 1;  # Имя глобальной переменной ::var (может быть перекрыто) 
        ::ns::var = 0; # Имя другой глобальной переменной (не может быть перекрыто) 
    };
};
```

## Пространство имен, модули и пакеты

Пространство имен в *NewLang* поддерживает одновременно с [модульной структурой кода](/ru/docs/syntax/modules/) как в языках Java и Python
и при указании полного имени объекта, программные модули и пространства имен можно объединять. 

Например, полное имя переменой можно записать с указанием программного модуля `\root\dir\module::ns::name::var`, 
где **root** и **dir** это каталоги в файловой системе относительно текущего модуля, а **module** — имя файла, т.е. *root/dir/module.nlp*.


## Пространство имен и ООП

В *NewLang* не применяется декорирование (манглинг) имен, основанный на типах аргументов функций.

Тем не менее при создания уникальных идентификаторов для методов [классов](/ru/docs/types/class/) *NewLang* использует подход, похожий на применяемый в языке Python. 
При создании [метода класса](/ru/docs/types/class/) создается глобальная функция с именем класса и именем метода, объединенные через разделитель "**::**". 

Например, для класса `:NewClass` при создании метода `method` будет создана функция с именем `NewClass::method`.

Такая схема наименований методов полностью соответствует именованию функций в пространстве имен, 
и тем самым позволяет определять методы класса вне тела самого класса, просто указав нужное имя в пространстве имен или в явном виде.

Пример создания метода класса *NewClass* в области имен: 
```
    NewClass::  {
        method() := { };
    }
```

Пример создания метода класса *NewClass* с указанием полного имени: 
```
    NewClass::method() := { };
```
