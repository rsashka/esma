[{"body":" Operators are separated by a semicolon “;”. Indentations and line breaks are ignored. Single-line comments start with the symbol “#” until the end of the line, following the style of Python and Bash comments. Multi-line comments follow the C/C++ style and should be enclosed between “/*” and “*/”. Multi-line comments can be nested. Command sequences (code block) are enclosed in curly braces “{” and “}”. Most operators are expressions and return the result of the last operation. ","categories":"","description":"Правила синтаксиса и основные понятия языка программирования NewLang \n","excerpt":"Правила синтаксиса и основные понятия языка программирования NewLang \n","ref":"/docs/syntax/","tags":"","title":"Синтаксис"},{"body":" Операторы разделяются точкой с запятой «;». Отступы и переводы строк игнорируются. Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash. Многострочные комментарии соответствуют стилю С/С++ и должны располагаться между символами /* и */. Многосточные комментарии могут быть вложенными. Последовательность команд (блок кода) заключаются в фигурные скобки “{” и “}”. Большинство операторов являются выражениями и возвращают результат выполнения последней операции. ","categories":"","description":"Правила синтаксиса и основные понятия языка программирования NewLang \n","excerpt":"Правила синтаксиса и основные понятия языка программирования NewLang \n","ref":"/ru/docs/syntax/","tags":"","title":"Синтаксис"},{"body":"NewLang является языком с динамической типизацией и явное указание типа переменной не обязательно и на прямую не влияет на размер памяти, котрую она занимает. Тип переменных используется при проверке их совместимости, когда существующему объекту присваивается другое значение.\nПрисвоение нового значения переменной возможно только тогда, когда типы данных между собой совместимы или допускают автоматическое приведение. Это справедливо как во время компиляции исходного теста, так и во время выполнения.\nNewLang имеет закрытую иерархическую систему типов, т.е. любой новый тип данных, которые создает пользователь, обязательно должен быть наследником от уже существующего. Это напоминает реализуцию ООП в яызке Java, где каждый класс имеет в своем составе наследников Object.\nЗа счет закрытой иерархии типов реализуется и парадигма обобщённого программирования (generics).\nКаждый тип данных имеет краткое имя и функцию - конструктор.\nКраткое имя типа всегда начинается с символа двоеточия “:” и определяется в глобальной области видимости.\nФункция - конструктора типа, имеет тоже самое краткое имя типа, но без символа двоеточия “:”, и как и любая функция может располагаться в пользовательском пространстве имен.\nСоздать новый экземпляр типа нужно вызвать функцию - конструтор типа.\nСоздать новый экземпляр типа данных можно записав краткое имя типа как вызов функции, либо вызвать непосредственно функцию - конструтор типа, с указанием её полного пространства имен.\nТипы данных могут быть синонимами, т.е. два типа данных могут иметь одинаковое краткое имя, (соответствено, и одитнаковые функции конструкторы), но сами функции должны располагаться в разных областях пространства имен.\nВ этом случае, создание объекта - синонима типа, требует вызова функции конструктора с указанием её полного пространства имен, в противном случае будет вызвана функция согласно алгоритму разрешения имен (name lookup). .\nВозможно явное приведение одного типа данных к дргуому. Для этого применяется краткое имя (которое начинается с символа двоеточия “:”), как вызов функции, в параметрах которой передается один или несколько объектов, тип которых нужно привести к требуемому.\nТипы данных разделяются на простые и сложные (составные).\nПростые типы данных не могут Поля у простых типов данных не могут быть расширены\nСоздание типов происходит согласно правилам синтаксиса. Имя типа всегда начинается с символа двоеточия “:” и определяется в глобальной области видимости. Создание сложных типов (классов), может располагаться в пользовательском пространстве имен.\n, в том числе и конструктор классов, ","categories":"","description":"","excerpt":"NewLang является языком с динамической типизацией и явное указание …","ref":"/docs/types/","tags":"","title":"Типы данных"},{"body":"NewLang является языком с динамической типизацией и явное указание типа переменной не обязательно и на прямую не влияет на размер памяти, котрую она занимает. Тип переменных используется при проверке их совместимости, когда существующему объекту присваивается другое значение.\nПрисвоение нового значения переменной возможно только тогда, когда типы данных между собой совместимы или допускают автоматическое приведение. Это справедливо как во время компиляции исходного теста, так и во время выполнения.\nNewLang имеет закрытую иерархическую систему типов, т.е. любой новый тип данных, которые создает пользователь, обязательно должен быть наследником от уже существующего. Это напоминает реализуцию ООП в яызке Java, где каждый класс имеет в своем составе наследников Object.\nЗа счет закрытой иерархии типов реализуется и парадигма обобщённого программирования (generics).\nКаждый тип данных имеет краткое имя и функцию - конструктор.\nКраткое имя типа всегда начинается с символа двоеточия “:” и определяется в глобальной области видимости.\nФункция - конструктора типа, имеет тоже самое краткое имя типа, но без символа двоеточия “:”, и как и любая функция может располагаться в пользовательском пространстве имен.\nСоздать новый экземпляр типа нужно вызвать функцию - конструтор типа.\nСоздать новый экземпляр типа данных можно записав краткое имя типа как вызов функции, либо вызвать непосредственно функцию - конструтор типа, с указанием её полного пространства имен.\nТипы данных могут быть синонимами, т.е. два типа данных могут иметь одинаковое краткое имя, (соответствено, и одитнаковые функции конструкторы), но сами функции должны располагаться в разных областях пространства имен.\nВ этом случае, создание объекта - синонима типа, требует вызова функции конструктора с указанием её полного пространства имен, в противном случае будет вызвана функция согласно алгоритму разрешения имен (name lookup). .\nВозможно явное приведение одного типа данных к дргуому. Для этого применяется краткое имя (которое начинается с символа двоеточия “:”), как вызов функции, в параметрах которой передается один или несколько объектов, тип которых нужно привести к требуемому.\nТипы данных разделяются на простые и сложные (составные).\nПростые типы данных не могут Поля у простых типов данных не могут быть расширены\nСоздание типов происходит согласно правилам синтаксиса. Имя типа всегда начинается с символа двоеточия “:” и определяется в глобальной области видимости. Создание сложных типов (классов), может располагаться в пользовательском пространстве имен.\n, в том числе и конструктор классов, ","categories":"","description":"","excerpt":"NewLang является языком с динамической типизацией и явное указание …","ref":"/ru/docs/types/","tags":"","title":"Типы данных"},{"body":"Один из самых недооценных операторов, которй отсутствует в большинстве высокоуровневых языков программирования, это переменная с результатом выполнения предыдущей операции. В NewLang это системная переменная $^ (или DSL макрос @result), в которой всегда хранится результат выполнения последней операции (оператора).\nЭто чем-то похоже на глобальное значние error(), но не только для кода ошибки, а для значения любого оператора.\nПри её использовании многие синтаксические конструкции языка значительно упрощаются, так как не требуется предусматривать определение локальных переменных для сохранения промежуточных данных, например при возникновении ошибки.\n","categories":"","description":"","excerpt":"Один из самых недооценных операторов, которй отсутствует в большинстве …","ref":"/docs/ops/","tags":"","title":"Операторы и управляющие конструкции"},{"body":"Один из самых недооценных операторов, которй отсутствует в большинстве высокоуровневых языков программирования, это переменная с результатом выполнения предыдущей операции. В NewLang это системная переменная $^ (или DSL макрос @result), в которой всегда хранится результат выполнения последней операции (оператора).\nЭто чем-то похоже на глобальное значние error(), но не только для кода ошибки, а для значения любого оператора.\nПри её использовании многие синтаксические конструкции языка значительно упрощаются, так как не требуется предусматривать определение локальных переменных для сохранения промежуточных данных, например при возникновении ошибки.\n","categories":"","description":"","excerpt":"Один из самых недооценных операторов, которй отсутствует в большинстве …","ref":"/ru/docs/ops/","tags":"","title":"Операторы и управляющие конструкции"},{"body":"Ключем поиска объектов явялется строка с полным именем в иерархии имен относительно корня\nСистема классов реализации RunTime - единственный класс для приложения (процесса) - интерфейс для взаимодействия с операционной системой\nЗагружат и выгружает модули и является их владельцем (shared_ptr) Хранит глобальные объекты (ObjPtr) для глобальных объектов (встроенных типов и функций). Ключем явялется строка с полным именем объекта в иерархии имен относительно корня Хранит список глобальных объектов (типы данных и прототипы функций в TermPtr, которые создаются на этапе компиляции). Используется парсером и компилятором для разбора исходного текста и создания исполняемого файла. Module - класс для модуля\nХранение объектов модуля (shared_ptr) и добавляет weak_ptr в глобальный список объектов в RunTime Context - класс для хранения временных данных при выполнении программы\nОдин класс создается сразу при создании RunTime В дальнейшем создается по одному объекту для каждого нового потока (:Thread) Хранение списка объектов (weak_ptr) Хранение локальных объектов (ObjPtr), которые создаются на этапе выполнения Исходный текст -\u003e Парсинг -\u003e AST (TermPtr) -+-\u003e Компиляция в модуль (LLVM) -\u003e Выполнение модуля | +-\u003e Интерпретация (Выполнение AST)\nРеализация загрузки модулей и пакетов Загрузка модулей происодит следующим образом. Когда во время парсинга исходного текста встречается команда загруки модуля, создается отдельный экземпляр парсера, которому на вход подается исходный текст загружаемого модуля.\nЗагружаемый модуль парсится как обучный файл (включая обработку вложенных модулей), после чего парсер завершает работу. В результате получается отдельное AST загружаемого модуля и общая база макросов. После этого в AST модуля раскрываются области имен, производится проверка имен объетов и создание единой базы глобальных объектов.\nПосле проверки отдельного AST модуля, обработка текущего файла моедт быть прожолжена. После завершения обарботки файла раскрываются области имен, производится проверка имен объетов и создание единой базы глобальных объектов как и в случае с обработко отдельного AST модуля.\nПри такой схеме работы, компиляция отдельных AST у каждого модуля может производиться параллельно с остальными моделями, а создание общего исоплняемого файла после компиляции всех используемых модулей.\nЗагрузка пакета обработывается точто таким же образом, как и загрузка моделя.\nШаги сборки компилятора Сборка nlc Генерация с помощью nlc --no-runtime --no-dsl -emit-cpp модуля dsl Сборка модуля dsl Генерация с помощью nlc --no-runtime -emit-cpp пакета runtime Сборка пакета runtime В результате имеем готовый nlc с модулями runtime.nlm и dsl.nlm, а заодно и проверяем:\nгенерацию С++ кода без макросов сборку модуля загрузку модуля генерацию С++ кода с макросами сборку пакета загрузку пакета Выполнение тестов с модулями runtime.nlm и dsl.nlm\nОпции компилятора -no-dsl - не использовать автоматически загружаемый модуль dsl -no-runtime - не использовать автоматически загружаемый модуль runtime -emit-cpp - генерировать выходной *.cpp файл 5.5. alignas(N) Этот спецификатор появился в C++11. Применяется к простым переменным, массивам и классам. N — это выражение, вычисляемое при компиляции, его значение должно быть степенью двойки. Переменная при этом будет размещена по адресу, кратному значению N. Например:\nalignas(64) char cacheline[64]; cacheline:Int8[64](__alignas__=64) := _; constexpr Этот спецификатор появился в C++11. Применяется к простым переменным, массивам, функциям и функциям-членам. Для простой переменной или массива это означает, что ее значение вычисляется на этапе компиляции и не может быть изменено. Для функции это означает, что ее возвращаемое значение вычисляется на этапе компиляции, если значения аргументов известно на стадии компиляции. (Но такую функцию можно использовать и с обычными аргументами.) Вот пример:\nconstexpr double PI = 3.1415926535897932; constexpr int Square(int x) { return x * x; } PI^:Double = 3.1415926535897932; Square^(x:Int64):Int64 ::= { return x * x; } 5.7. consteval Этот спецификатор появился в C++20. Применяется к функциям и функциям-членам. Это более строгий вариант constexpr, при вызове такой функции значения аргументов должны быть всегда известны на стадии компиляции.\n????????????????????????????????????? Square^(x^:Int64):Int64 ::= { return x * x; } 5.8. noexcept Этот спецификатор появился в C++11. Применяется к функциям и функциям-членам и располагается в конце инструкции, после списка параметров. Этот спецификатор гарантирует отсутствие исключений в процессе выполнения тела функции.\nfunc() ::= {* *}; 5.9. mutable Применяются к нестатическим членам класса, такие члены можно изменять в константных функциях-членах (см. раздел 5.10.1).\nВ C++20 для агрегатных типов появилась еще назначенная инициализация (designated initialization): struct Point { int X; int Y; };\nPoint pt = { .X = 1, .Y = 2 };\nЭта инициализация позаимствована из C. Инициализируемые члены могут быть опущены и не только в конце, для них гарантируется инициализация по умолчанию. В отличие от C, порядок членов изменять нельзя, он должен быть таким же, как и при объявлении.\n","categories":"","description":"Описание реализация архитектуры для лучшего понимания отдельных важных моментов\n","excerpt":"Описание реализация архитектуры для лучшего понимания отдельных важных …","ref":"/docs/arch/","tags":"","title":"Архитектура"},{"body":"На память clang-17 не поддерживает:\nFeature Proposal Available Coroutines P0912R5 Partial Fully supported on all targets except Windows, which still has some stability and ABI issues. Extended floating-point types and standard names P1467R9 No Concepts P0848R3 Clang 16 (Partial) Modules No Начиная с C++ should adopt the same characters for C++26. Add @, $, and ` to the basic character set P2558R2 Yes Система классов реализации RunTime - единственный класс для приложения (процесса) - интерфейс для взаимодействия с операционной системой\nЗагружат и выгружает модули и является их владельцем (shared_ptr) Хранит сслыки на глобальные объекты (WeakPtr) и непосредственно глобальные объекты (встроенные типы и функции). Ключем явялется строка с внутренним именем объекта Хранит список глобальных объектов (типы данных и прототипы функций, которые создаются на этапе компиляции). Используется парсером и компилятором для разбора исходного текста и создания исполняемого файла. Module - класс для модуля\nХранение объектов модуля (shared_ptr) и добавляет weak_ptr в глобальный список объектов в RunTime Context - класс для хранения временных данных при выполнении программы\nОдин класс создается сразу при создании RunTime В дальнейшем создается по одному объекту для каждого нового потока (:Thread) Хранение списка объектов (weak_ptr) Хранение локальных объектов (ObjPtr), которые создаются на этапе выполнения Исходный текст -\u003e Парсинг -\u003e AST (TermPtr) -+-\u003e Компиляция в модуль (LLVM) -\u003e Выполнение модуля | +-\u003e Интерпретация (Выполнение AST)\nРеализация загрузки модулей и пакетов Загрузка модулей происодит следующим образом. Когда во время парсинга исходного текста встречается команда загруки модуля, создается отдельный экземпляр парсера, которому на вход подается исходный текст загружаемого модуля.\nЗагружаемый модуль парсится как обучный файл (включая обработку вложенных модулей), после чего парсер завершает работу. В результате получается отдельное AST загружаемого модуля и общая база макросов. После этого в AST модуля раскрываются области имен, производится проверка имен объетов и создание единой базы глобальных объектов.\nПосле проверки отдельного AST модуля, обработка текущего файла моедт быть прожолжена. После завершения обарботки файла раскрываются области имен, производится проверка имен объетов и создание единой базы глобальных объектов как и в случае с обработко отдельного AST модуля.\nПри такой схеме работы, компиляция отдельных AST у каждого модуля может производиться параллельно с остальными моделями, а создание общего исоплняемого файла после компиляции всех используемых модулей.\nЗагрузка пакета обработывается точто таким же образом, как и загрузка моделя.\nШаги сборки компилятора Сборка nlc Генерация с помощью nlc --no-runtime --no-dsl -emit-cpp модуля dsl Сборка модуля dsl Генерация с помощью nlc --no-runtime -emit-cpp пакета runtime Сборка пакета runtime В результате имеем готовый nlc с модулями runtime.nlm и dsl.nlm, а заодно и проверяем:\nгенерацию С++ кода без макросов сборку модуля загрузку модуля генерацию С++ кода с макросами сборку пакета загрузку пакета Выполнение тестов с модулями runtime.nlm и dsl.nlm\nОпции компилятора -no-dsl - не использовать автоматически загружаемый модуль dsl -no-runtime - не использовать автоматически загружаемый модуль runtime -emit-cpp - генерировать выходной *.cpp файл 5.5. alignas(N) Этот спецификатор появился в C++11. Применяется к простым переменным, массивам и классам. N — это выражение, вычисляемое при компиляции, его значение должно быть степенью двойки. Переменная при этом будет размещена по адресу, кратному значению N. Например:\nalignas(64) char cacheline[64]; cacheline:Int8[64](__alignas__=64) := _; constexpr Этот спецификатор появился в C++11. Применяется к простым переменным, массивам, функциям и функциям-членам. Для простой переменной или массива это означает, что ее значение вычисляется на этапе компиляции и не может быть изменено. Для функции это означает, что ее возвращаемое значение вычисляется на этапе компиляции, если значения аргументов известно на стадии компиляции. (Но такую функцию можно использовать и с обычными аргументами.) Вот пример:\nconstexpr double PI = 3.1415926535897932; constexpr int Square(int x) { return x * x; } PI^:Double = 3.1415926535897932; Square^(x:Int64):Int64 ::= { return x * x; } 5.7. consteval Этот спецификатор появился в C++20. Применяется к функциям и функциям-членам. Это более строгий вариант constexpr, при вызове такой функции значения аргументов должны быть всегда известны на стадии компиляции.\n????????????????????????????????????? Square^(x^:Int64):Int64 ::= { return x * x; } 5.8. noexcept Этот спецификатор появился в C++11. Применяется к функциям и функциям-членам и располагается в конце инструкции, после списка параметров. Этот спецификатор гарантирует отсутствие исключений в процессе выполнения тела функции.\nfunc() ::= {* *}; 5.9. mutable Применяются к нестатическим членам класса, такие члены можно изменять в константных функциях-членах (см. раздел 5.10.1).\nВ C++20 для агрегатных типов появилась еще назначенная инициализация (designated initialization): struct Point { int X; int Y; };\nPoint pt = { .X = 1, .Y = 2 };\nЭта инициализация позаимствована из C. Инициализируемые члены могут быть опущены и не только в конце, для них гарантируется инициализация по умолчанию. В отличие от C, порядок членов изменять нельзя, он должен быть таким же, как и при объявлении.\n","categories":"","description":"Описание архитектуры компилятора для и конкретных технических решений\n","excerpt":"Описание архитектуры компилятора для и конкретных технических решений\n","ref":"/ru/docs/arch/","tags":"","title":"Архитектура"},{"body":"NewLang имеет закрытую систему типов. т.е. любой новый тип данных, которые создает пользователь, обязательно должен быть наследником одного из уже существующих, т.е. расширять один из них. Такой поход напоминает создание классов в языке Java, в котором каждый новый класс имеет в своих родителях класс Object.\nС помощью обобщений (generics) можно писать код, который может работать с любым совместимым типом данных.\nФрагмент иерархии типов данных (строки и числа, а в скобках указаны синонимы типов):\n:Any -+-\u003e :Arithmetic -+-\u003e :Tensor -+-\u003e :Integer --\u003e :Int64 ... --\u003e :Int8 --\u003e :Bool | | | (:DWord64) (:Char) | | | (:Byte) | | | | | +-\u003e :Number --\u003e :Float64 --\u003e :Float32 --\u003e :Float16 --\u003e ... | | | (:Double) (:Single) | | | | | +-\u003e :Complex ... | | | +-\u003e :Rational | +-\u003e :String -+-\u003e :StrChar | | (:FmtChar) | | | +-\u003e :StrWide | (:FmtWide) | | ... Обобщенные типы :Any - обобщенный тип для всех остальных типов данных :Arithmetic - обобщенный тип для всех числовых типов :Tensor - обобщенный тип для чисел, которые можно представить в машинном формате :Integer - обощенный тип для всех целочисленных типов данных :Number - обощенный тип для всех чисел с плавающей точкой :Complex - обощенный тип для всех комплексных чисел :String - обощенный тип для текстовых строк Примеры определения функций с обобщенными типами only_int8(arg:Int8):Int8 := ... ; # Функиця принимает и возвращает только :Int8 any_int(arg:Integer):Integer := ... ; # Функиця принимает и возвращает только целые числа any_tensor(arg:Tensor):Tensor := ... ;# Функиця принимает и возвращает любые машинные типы чисел any_any1(arg:Any):None := ... ; # Функиця принимает любой тип аргумента и ничего не возвращает any_any2(arg) := ... ; # Тип не указан - функиця можен принимать и возвращать любой тип ","categories":"","description":"","excerpt":"NewLang имеет закрытую систему типов. т.е. любой новый тип данных, …","ref":"/docs/types/generics/","tags":["типы данных","ООП","коллекции"],"title":"Иерархия типов и обобщения"},{"body":"NewLang имеет закрытую систему типов. т.е. любой новый тип данных, которые создает пользователь, обязательно должен быть наследником одного из уже существующих, т.е. расширять один из них. Такой поход напоминает создание классов в языке Java, в котором каждый новый класс имеет в своих родителях класс Object.\nС помощью обобщений (generics) можно писать код, который может работать с любым совместимым типом данных.\nФрагмент иерархии типов данных (строки и числа, а в скобках указаны синонимы типов):\n:Any -+-\u003e :Arithmetic -+-\u003e :Tensor -+-\u003e :Integer --\u003e :Int64 ... --\u003e :Int8 --\u003e :Bool | | | (:DWord64) (:Char) | | | (:Byte) | | | | | +-\u003e :Number --\u003e :Float64 --\u003e :Float32 --\u003e :Float16 --\u003e ... | | | (:Double) (:Single) | | | | | +-\u003e :Complex ... | | | +-\u003e :Rational | +-\u003e :String -+-\u003e :StrChar | | (:FmtChar) | | | +-\u003e :StrWide | (:FmtWide) | | ... Обобщенные типы :Any - обобщенный тип для всех остальных типов данных :Arithmetic - обобщенный тип для всех числовых типов :Tensor - обобщенный тип для чисел, которые можно представить в машинном формате :Integer - обощенный тип для всех целочисленных типов данных :Number - обощенный тип для всех чисел с плавающей точкой :Complex - обощенный тип для всех комплексных чисел :String - обощенный тип для текстовых строк Примеры определения функций с обобщенными типами only_int8(arg:Int8):Int8 := ... ; # Функиця принимает и возвращает только :Int8 any_int(arg:Integer):Integer := ... ; # Функиця принимает и возвращает только целые числа any_tensor(arg:Tensor):Tensor := ... ;# Функиця принимает и возвращает любые машинные типы чисел any_any1(arg:Any):None := ... ; # Функиця принимает любой тип аргумента и ничего не возвращает any_any2(arg) := ... ; # Тип не указан - функиця можен принимать и возвращать любой тип ","categories":"","description":"","excerpt":"NewLang имеет закрытую систему типов. т.е. любой новый тип данных, …","ref":"/ru/docs/types/generics/","tags":["типы данных","ООП","коллекции"],"title":"Иерархия типов и обобщения"},{"body":"Objects and data types can be named using letters, numbers, and underscores in any combination, provided that the first character of the name is not a digit.\nAll identifiers must be unique, and to avoid collisions, you can use namespaces and a modular code structure supported simultaneously by NewLang.\nOverloading functions based on argument types is absent in NewLang, so defining multiple functions with the same name but different arguments is not possible, but you can override a function, including extending the types of accepted arguments or increasing their number.\nAn object identifier can contain one or more special characters - qualifiers (or sigils), which represent specific values. An object identifier that does not contain a qualifier is called simple:\nName Qualifiers: ‘@’ - the at sign prefix is used to specify the name of a macro, which is processed by the preprocessor before the start of the program’s syntactic analysis. ‘@’ - the at prefix is used to specify the name of a macro that is processed by the preprocessor before the start of the syntactic analysis of the source code of the program. ‘$’ - the dollar sign at the beginning of an object’s name denotes an automatic name for a temporary variable, the memory space for which is dynamically allocated during the application’s execution, and the lifetime is limited by the language semantics. ‘::’ - the double colon serves as a separator for namespaces and indicates a static object, the memory space for which is allocated during the compilation of the application or module. If the name starts with ‘::’, the object’s scope will be global and it will be accessible throughout the application. Otherwise, the object’s visibility will be limited to the current program module. ‘.’ - the dot prefix is used when accessing a module or class field (limits the scope to the current object). The dot prefix can be used when defining (calling) a function to explicitly identify a named argument, preventing it from being overridden by a preprocessor macro. ‘\\’ - the backslash at the beginning of a term denotes the name of a program module, and also separates directory names in the hierarchy of program module placement. ‘:’ — colon at the beginning of the term denotes the name of a data type or a class constructor ‘%’ — the percent sign prefix is used for imported symbols (native variables and functions) ‘^’ — the caret symbol after the name is used to give immutability (constancy, non-modifiability) to the object. Name Lookup If the object name does not contain a qualifier, it is called simple. Creating an object with a simple name is equivalent to creating a local object.\nIn other cases, when NewLang encounters a simple object name without a qualifier (sigil), a special algorithm comes into play that associates the simple name found in the source code of the program with its declaration or a specific object by its internal name.\nResolution of simple names without a qualifier (name lookup for function/variable names) always occurs in a strictly defined order:\nFirst, the search for the name is among macros Next, the search is among local objects up to objects of the current module Lastly, the search is among global objects with a gradual expansion of the namespace search scope from current to global Such a sequence of name resolution always provides the opportunity to redefine global/local objects or argument names in functions for existing code without serious changes.\nFor example, for the name name in the namespace ns, the search occurs in the following sequence: @name -\u003e $name -\u003e ns::name -\u003e ::ns::name -\u003e ::name, and for the name arg, only @arg is checked:\nns:: { name(arg=\"value\"); }; And at the same time, there will always be the possibility to specify a specific object regardless of the algorithm for resolving simple names. It is sufficient to explicitly specify the qualifier in the object name.\nFor example, to access the global object name from the namespace ns in the above example, you need to use the full object name ::ns::name, and the named argument ’. arg’ will not be replaced by the @arg macro if it is defined:\n::ns::name(.arg=\"value\"); Forward Declaration In the program text, you can only refer to actually existing (created) objects. But in cases where it is necessary to refer to an object that is created in another module or will be created later, you can make a preliminary declaration, in which the compiler registers the name and type of the object without its actual creation.\nBy means of a forward declaration, one can refer only to static objects (data types), or local class fields that the compiler does not yet know about but which will be defined during the compilation process later.\nFor a forward declaration, only the fully qualified name can be used, which must exactly match the object’s name when it is subsequently created.\nThe same syntax is used for a forward declaration as for the actual creation of an object, only an ellipsis should be specified to the right of the creation operator.\nThe scope of a forward declaration corresponds to the scope of its placement, not the actual scope of the object (even for global objects).\n# Preliminary definition of a module variable # Applies to the entire module var_module:Int32 := ...; func() ::= { # Preliminary announcement using DSL # (only works inside a function body) @declare( func2(arg:Int32):Int32 ); var_module = func2(var_module); @return var_module; }; func2(arg:Int32):Int32 ::= { @return $arg*$arg; } var_module:Int32 := 1; Argument Names, Special, System Names The notation of argument names in functions is very similar to referencing arguments in bash scripts, where “$1” or “$name” represents the ordinal number or name of the corresponding argument.\nThe reserved name “$0” denotes the current object, and the name “$$” denotes the parent object.\nAll function arguments are collected in a single dictionary with the special name $*\nThe immutable variable “$^” contains the result of the last operator or code block execution.\nThe full name of the current module is contained in the variable @\\\\, and the current namespace in the variable @::, i.e.:\n# File name filename.src in directory dir ns:: { # Use namespace ns name:: { # Preprocessor command \"@#\" - convert to a string ns_str := @# @::; # String with namespase \"::ns::name::\" mod_str := @# @\\\\; # String with module name \"\\\\dir\\filename\" }; }; Scope The underscore symbol, as well as an underscore at the beginning of a name or double underscores at the beginning and end of a name, have special meanings.\nA single underscore corresponds to a protected, and two underscores to a private scope of an object within a module or class, in accordance with the conventions in the Python language.\nHowever, just like in Python, scopes are more of a “gentleman’s agreement,” and with explicit naming, access to protected objects can be obtained by simply specifying the full object name.\nIn addition, there are also system fields and objects that start and end with two underscores.\n‘$’ - The dollar sign at the beginning of a name denotes a system (local) name of a temporary variable, the memory space for which is allocated during execution, and the lifetime is limited by the language semantics. ‘::’ - Double colons serve as a separator when specifying namespaces. Explicit namespace specification is a sign of a static object, the memory space for which is allocated during the compilation of the application or module. ","categories":"","description":"Rules for naming variables, functions, and data types","excerpt":"Rules for naming variables, functions, and data types","ref":"/docs/syntax/naming/","tags":"","title":"Naming Objects"},{"body":"NewLang is a language with dynamic typing, and explicit type declaration does not affect the memory size occupied by a variable. Type information is used when checking their compatibility, when assigning a value of a different type to an existing object. This operation is possible only when the types are compatible and allow for automatic conversion. This is true both during parsing/compilation of the source text and during execution in interpreter and/or compiled file modes.\nArithmetic types All numbers (except rational) in NewLang are tensors, i.e. arrays of one type with an arbitrary number of dimensions and the same column size in each. A unit number is also a tensor of zero size.\nOnly signed integers are supported, as there is no special need for unsigned numbers, and there are many problems with them that can be found very easily.\nIssues with unsigned numbers (from the internet): First, subtracting two unsigned numbers, for example 3 and 5. 3 minus 5 equals 4294967294 because -2 cannot be represented as an unsigned number. Second, unexpected behavior may occur when mixing signed and unsigned integer values. C++ can freely convert signed and unsigned numbers, but does not check the range to ensure that you are not overflowing your data type.\nThe names of the built-in arithmetic types: :Int8, :Int16, :Int32, :Int64, :Float16, :Float32, :Float64, :Complex16, :Complex32, :Complex64 speak for themselves. And although among them there are names that are inherent to unsigned numbers (:Byte, :Word, :DWord, etc.), they are synonyms and are used for interaction with native C++ code.\nLogical type A separate type is the logical type: Bool, which can only take values 0 or 1 (false/true respectively), and depending on the operation being performed, it can also be classified as integer types, or not included in their composition (this approach to interpreting the logical data type was taken from the Torch library).\n// Treat bool as a distinct \"category,\" to be consistent with type promotion // rules (e.g. `bool_tensor + 5 -\u003e int64_tensor`). If `5` was in the same // category as `bool_tensor`, we would not promote. Differing categories // implies `bool_tensor += 5` is disallowed. // // NB: numpy distinguishes \"unsigned\" as a category to get the desired // `bool_tensor + 5 -\u003e int64_tensor` behavior. We don't, because: // * We don't want the performance hit of checking the runtime sign of Scalars. // * `uint8_tensor + 5 -\u003e int64_tensor` would be undesirable. Tensor Indexing Access to tensor elements is done by an integer index starting from 0. For a multidimensional tensor, element indices are listed in square brackets separated by commas. Access to elements through a negative index is supported, which is handled in the same way as in Python (-1 is the last element, -2 is the second to last, and so on).\nRanges can be used as tensor indices, which are handled the same way as in Python, as well as the value :None and ellipsis .... The value :None, meaning absence of an index, signifies an arbitrary size of the tensor in one specific dimension, while the ellipsis ... denotes an arbitrary dimension in any number of dimensions (hence, it can appear in the tensor index only once).\nThe tensor literal in the program text is written in square brackets with a mandatory closing comma, i.e. [1, 2,] - this is a literal one-dimensional tensor of two numbers. After the closing bracket, the tensor type can be explicitly specified. If the type is not specified, it is automatically output based on the specified data and the minimum possible byte size that allows all values to be saved without loss of accuracy is selected.\nExamples of creating tensors and transforming their dimensions can be found here.\nRational Numbers For calculations with unlimited precision in NewLang, a separate type is used - rational numbers. They are written in the form of a common fraction, in which the numerator must be an integer, and the denominator natural (an integer without zero).\nA backslash is used as the fraction separator, i.e. 1\\1 - rational number 1, -5\\1 - rational number -5, etc.\n","categories":"","description":"","excerpt":"NewLang is a language with dynamic typing, and explicit type …","ref":"/docs/types/numbers/","tags":"","title":"Numbers"},{"body":"В качестве имен объектов и типов данных можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ имени не является цифрой.\nВсе идентификаторы должны быть уникальны, а для избежания коллизий можно использовать пространство имен и модульную структуру кода, которые NewLang поддерживает одновременно.\nПерегрузка функций по типам аргументов NewLang отсуствует, поэтому несколько функций с однинаковым именем но разными аругментами определить нельзя, но можно переопределить функцию, в том числе и расширив типы принимаемых аргументов или увеличив их количество.\nИдентификатор объекта может содержать один или несколько специальных символов - квалификаторов (или сигилов), за которыми закрепелено определенное значение. Идентификатор объекта который не содержит квалификатора, называется простым:\nКвалификаторы имен: ‘@’ — префикс собачка используется для указания имени макроса, который обрабатыватся препроцессором до начала синтаксического анализа исходного текста программы. ‘$’ — знак доллара в начале имени объекта обозначает автоматичекое имя временной переменной, область памяти для которой выделяется динамически во время выполнения приложения, а время жизни ограничено семантикой яызка ‘::’ — двойное двоеточие является разделителем пространства имен, и является признаком статического объекта, область памяти для которого выделяется во время компиляции приложения или модуля. Если имя начинается на ‘::’, то область видимости объекта будет глобальной и он будет доступен в рамках всего приложения. В противном случае, видимость объекта будет ограничена только текущим программным модулем. ‘.’ — префикс точка используется при обращении к полю модуля или класса (ограничивает область видимости текущим объектом). Префикс точка может использоваться при определении (вызове) функции для явной идентификации именованного аргумента, чтобы его нельзя было перекрыть макросом препроцессора. ‘\\’ — обратный слеш в начале термина обозначает имя программного модуля, а так же разделяет имена каталогов в иерархии размещения программных модулей. ‘:’ — двоеточие в начале термина обозначает имя типа данных или конструктор класса ‘%’ — префикс знак процента указывается для импортируемых символов (нативных переменных и функций) ‘^’ — символ карет (крышечка/домик) после имени используется для придания объекту иммутабельности (константности, не изменяемости). Разрешение имен (name lookup) Если имя объекта не содержит квалификатора, оно называется простым. Создание объекта с указанием простого имени равнозначно созданию локального объекта.\nВ других случаях, когда NewLang встречает простое имя объекта без квалификатора (сигила), то в дело вструпает специальный алгоритм, который связывает простое имя, встретившееся в исходном тексте программы, с его декларацией или конкретным объектом по его внутреннему имени.\nРазрешение простых имен без квалификатора (name lookup, или поиск имени функции/переменной) происходит всегда в строго определенном порядке:\nв первую очередь происходит поиск имени среди макросов далее выполняется поиск имени среди локальных объектов до объектов текущего модуля в последнюю очередь выполняется поиск среди глобальных объетов с постепенным расширением пространства имен области поиска от текущей до глобальной Такая последовательность разрешение имен всегда предоставляет возможность переопределить глобальные/локальные объекты или имена аргументов у функций для уже существующего кода без его серъезных изменений.\nНапример, для имени name в области имен ns поиск происходит в следующей последовательности: @name -\u003e $name -\u003e ns::name -\u003e ::ns::name -\u003e ::name, а для имени arg проверяется только @arg:\nns:: { name(arg=\"value\"); }; И в тоже время, всегда остатся возможность указать конкретный объект не зависимо от работы алгоритма разрешение простых имен. Достаточно указать квалификатор в имени объекта в явном виде.\nНапример, обратиться к глобальному объекту name из пространства имен ns из примера выше, нужно по полному имени объекта ::ns::name, а именованнй аргумент ’. arg’ не будет заменен макросом @arg, если такой будет определен:\n::ns::name(.arg=\"value\"); Предварительное объявление В тексте программы можно ссылаться только на реально существующие (созданные) объекты. Но для тех случаев, когда требуется сослаться на объект, который создан в другом модуле или будет создан позже, можно сделать предварительное объявление, при котором компилятор регистриурет имя и тип объекта без его реального создания.\nЗа счет предварительного объявления можно ссылаться только на статические объекты (типы данных), или локальные поля класса о которых компилятор ещё не знает, но которые будут определены в процессе компиляции позже.\nДля предварительного объявления можно использовать только полное квалифцированное имя, которое должно будет в точности совпадать с именем обекта при его последующем создании.\nДля предварительного объявления используется точто такой же синтаксис, как и при реальном создании объекта, только с права от операторо создания должно быть указано многоточие.\nОбласть видимости предварительное объявения соответствует области видимости его размещенея, а не реальвой области видимости объекта (это касается даже глобальных объектов).\n# Предварительное определение переменной модуля # Действует для всего модуля var_module:Int32 := ...; func() ::= { # Предварительное объявление с помощью DSL # (действует только внутри тела функции) @declare( func2(arg:Int32):Int32 ); var_module = func2(var_module); @return var_module; }; func2(arg:Int32):Int32 ::= { @return $arg*$arg; } var_module:Int32 := 1; Имена аргументов, специальные, системные имена Обозначение имен аргументов у функций очень похоже на обращение к аргументы в bash скриптах, где “$1” или “$name” — порядковый номер или имя соответствующего аргумента.\nЗарезервированное имя “$0” обозначает текущий объект, а именем “$$” обозначается родительский объект.\nВсе аргументы функции собранны в одном словаре со специальным имеенм $*\nНеизменяемая переменная “$^” содержит результат выполнения последнего оператора или блока кода.\nПолное имя текущего модуля содержится в переменной @\\\\, а текущая область имен в переменной @::, т.е.:\n# Имя файла filename.src в каталоге dir ns:: { # Использовать пространство имен ns name:: { # Команда препроцессора \"@#\" - преобразовать в символьную строку ns_str := @# @::; # Строка с областью имен \"::ns::name::\" mod_str := @# @\\\\; # Строка с именем модуля \"\\\\dir\\filename\" }; }; Области видимости Символ подчерка, а так же подчерк в начале имени или двойные подчерки в начале и в конце имени имеют специальное значение.\nОдин подчерк соответствует защищенной, а два подчерка - приватной области видимости объекта в модуле или классе, что соответствует принятым соглашениям в языке Python.\nНо так же, как и в языке Python, области видимости больше соответствуют “джентльменской” договоренности и при явном указании имени, доступ к защищенным объектам можно получить, просто указав полное имя объекта.\nВ дополнении к этому, существуют еще системные поля и объекты, которые начинаются и заканчиваются на два подчерка.\n‘$’ — знак доллара в начале имени обозначает системное (локальное) имя временной переменной, область памяти для которой выделяется во время выполнения, а время жизни ограничено семантикой яызка ‘::’ — двойное двоеточие являются разделителем при указании пространства имен. Явное указание пространства имен является признаком статического объекта, область памяти для которого выделяется во время компиляции приложения или модуля. ","categories":"","description":"Правила именования переменных, функций и типов данных","excerpt":"Правила именования переменных, функций и типов данных","ref":"/ru/docs/syntax/naming/","tags":"","title":"Именование объектов"},{"body":" Область видимости объекта =/= время жизни объекта Область видимости объекта определяется его расположением в программном коде (блоки кода, пространство имен, модели и т.д.) Объект может существовать, но может быть не доступен из текущей области видимости.\nИмя объекта, создание объекта и его расположение Имя объекта - его уникальный идентификатор, который однозначно определяется местом его расположения (нахождение сильной ссылки на объект). Имя у объекта может быть всегда, даже тогда, когда сам объект физически еще не создан (например при предварительном объявлении).\nСоздания объектов и присвоения новых значений Для создания объектов и присвоения им новых значений в NewLang используется несколько операторов:\n“::=” или “::-” - используется для создания только новых объектов. Если объект с таким именем был определен ранее, то произойдет ошибка компиляции. “:=” или “:-” - используется для создания новых объектов с возможностью перекрытия имен. Если локальный объект с таким именем был определен ранее, то новый объект будет его перекрывать. “=” - применяется только для присвоения значения уже существующим объектам. Если объект с указанным именем отсутствует, то возникает ошибка компиляции. “:=:” - Оператор не создает нового объекта, а обменивает значения уже существуюих (переменные должны иметь одинаковые/совместимые типы данных). ?????????????????????????????????????\n“[]=” - добавлеят новый элемент к словарю или переопределяет созданное ранее имя функции или метод класса. Похож на оператор присвоения значения “=”, но в отличии от него не удаляет старое значение, а сохраняет его в стек переопределнных имен, и к старому значению можно обратиться по системному имени “$$” ????????????????? *). Не может применяться к макросам. Использование трех разных видов операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе.\nНапример, при определении класса :NewClass2:\n:NewClass := :Class() { # Базовый класс filed ::= 2; # Однократная инициализация (статическоого) члена класса method() ::= {}; # Регистрация метода }; :NewClass2 := :NewClass() { filed ::= 2; # Будет ошибка, т.к. field уже есть в базовом классе method() = {}; # Аналог override, т.к. method должен существовать в базовом классе }; Если же контролировать момент создание объектов и присвоения им значений не требуется, то можно пользоваться единственным оператором :=.\nvar := 1.0; # Создать новую переменную var без явного указания типа var := 100; # Присвоить новое значение уже существующей переменной printf(format:FmtChar, ...):Int32 ::= %printf...; # Создать новый или переопределить printf ??????????????????????????????????????????? Присваивание значения сразу нескольким переменным и оператор распаковки словаря NewLang поддерживает операцию присваивания значения сразу нескольким переменным, которые должны быть перечислены через запятую слева от оператора присвоения. С правой стороны от оператора присвоения может находится только одно значение. А для обмена занчениями двух переменных, вместо традиционной записи:\na,b = b,a; Нужно использовать отдельный оператор обмена:\na :=: b; В качестве правого операнда в операторе присвоения допускается использовать оператор распаковки словаря … (многоточие), который можно использовать и при передаче аргументов в функцию.\nargs := (arg1=1, arg2=2, 3,4,); call(arg=0, ... args); # Что равносильно вызову call(arg=0, arg1=1, arg2=2, 3, 4); Словарь может быть указан и с левой стороны от оператора присвоения. Таким образом можно записать самый простой способ перебора всех его элементов: item, dictionary := ... dictionary;, т.е. когда первый элемент словаря сохраняется в переменную item, а из самого словаря удаляется, и так в цикле пока словарь не станет пустым.\nПример реализации цикла foreach для суммирования всех элементов словаря (или одномерного тензора) с использованием оператора раскрытия словаря (списка):\nsumma := 0; dictionary := (1,2,3,4,5,); @while( dictionary ) { # Первый элемент словаря перемещается в item item, dictionary := ... dictionary; summa += item; }; Заполнение данными При заполнении данными размерных тензоров существует краткий способ указания их начальных значений. Для этого используется многоточие в следующих вариантах:\n:Tensor[10](2,3, ...) - повторение всех предыдущих данных до полного заполнения тензора, что равносильно записи :Tensor[10](2,3, 2,3, 2,3, 2,3, 2,3).\n:Tensor[10](2, 3, ... 42 ...) - заполнение значением 42 до конца тензора, что равносильно записи :Tensor[10](2,3, 42,42,42,42,42,42,42,42).\n:Tensor[10](2, 3, ... rand() ...) - заполнение до конца тензора значением, которое будет возвращать функция. Указанная функция будет вызываться для каждого элемента до полного заполнения тензора (8 раз).\n:Tensor[10]( rand(), rand(), ...) - заполнение тензора двумя произвольными заначениями, то есть функция rand() будет вызвана дважды для двух первых элементов, после чего эти значения будут использоваться до полного заполнения тензора (как в первом примере).\n:Tensor[10]( ... 0..0.99..0.1 ) - заполнение тензора элементами диапазона, что равносильно записи\n:Tensor[10](0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9). Раскрытие диапазона создает фиксированное количество значений. Поэтому в данном примере размерность тензора можно не указывать, так как она будет создана автоматически.\n:Tensor[15]( ... 0..5 , ... ) - заполнение тензора элементами диапазона с их повторением до заданного размера тензора: :Tensor(0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4)\nЗаполнение данными в словарях и аргументах функций Предыдущие способы заполнения данными возможны только для тензоров фиксированного размера, так как позволяют получить произвольное количество значений, но их можно применять только в конце списка значения для инициализации.\nОператоры раскрытия словаря или диапазона создают ограниченное количество значений, но за счет этого их можно использовать не только для инициализации тензоров, но и в качестве начальных значений у словарей или создания аргументов при вызове функций, причем в произвольном месте, а не только в конце списка инициализации:\n:Tensor( ... 0..0.99..0.1 ) - заполнение тензора без указания его размера элементами диапазона, что равносильно записи :Tensor(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)\nfuntcion( 0, ... dict, 42 ) - раскрытие словаря как индивидуальных не именованных аргументов функции, к примеру funtcion( 0, 1, 2, 3, 42), если словарь dict содержал три элемента 1, 2 и 3.\nfuntcion( ... ... dict, end=4) - раскрытие словаря как индивидуальных именованных аргументов функции. Если словарь dict будет содержать элементы (1, two=2, three=3,), то это будет равносильно вызову функции funtcion( 1, two=2, three=3, end=4).\n","categories":"","description":"","excerpt":" Область видимости объекта =/= время жизни объекта Область видимости …","ref":"/docs/ops/create/","tags":"","title":"Создание объектов"},{"body":" Область видимости объекта =/= время жизни объекта Область видимости объекта определяется его расположением в программном коде (блоки кода, пространство имен, модели и т.д.) Объект может существовать, но может быть не доступен из текущей области видимости.\nИмя объекта, создание объекта и его расположение Имя объекта - его уникальный идентификатор, который однозначно определяется местом его расположения (нахождение сильной ссылки на объект). Имя у объекта может быть всегда, даже тогда, когда сам объект физически еще не создан (например при предварительном объявлении).\nСоздания объектов и присвоения новых значений Для создания объектов и присвоения им новых значений в NewLang используется несколько операторов:\n“::=” или “::-” - используется для создания только новых объектов. Если объект с таким именем был определен ранее, то произойдет ошибка компиляции. “:=” или “:-” - используется для создания новых объектов с возможностью перекрытия имен. Если локальный объект с таким именем был определен ранее, то новый объект будет его перекрывать. “=” - применяется только для присвоения значения уже существующим объектам. Если объект с указанным именем отсутствует, то возникает ошибка компиляции. “:=:” - Оператор не создает нового объекта, а обменивает значения уже существуюих (переменные должны иметь одинаковые/совместимые типы данных). ?????????????????????????????????????\n“[]=” - добавлеят новый элемент к словарю или переопределяет созданное ранее имя функции или метод класса. Похож на оператор присвоения значения “=”, но в отличии от него не удаляет старое значение, а сохраняет его в стек переопределнных имен, и к старому значению можно обратиться по системному имени “$$” ????????????????? *). Не может применяться к макросам. Использование трех разных видов операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе.\nНапример, при определении класса :NewClass2:\n:NewClass := :Class() { # Базовый класс filed ::= 2; # Однократная инициализация (статическоого) члена класса method() ::= {}; # Регистрация метода }; :NewClass2 := :NewClass() { filed ::= 2; # Будет ошибка, т.к. field уже есть в базовом классе method() = {}; # Аналог override, т.к. method должен существовать в базовом классе }; Если же контролировать момент создание объектов и присвоения им значений не требуется, то можно пользоваться единственным оператором :=.\nvar := 1.0; # Создать новую переменную var без явного указания типа var := 100; # Присвоить новое значение уже существующей переменной printf(format:FmtChar, ...):Int32 ::= %printf...; # Создать новый или переопределить printf ??????????????????????????????????????????? Присваивание значения сразу нескольким переменным и оператор распаковки словаря NewLang поддерживает операцию присваивания значения сразу нескольким переменным, которые должны быть перечислены через запятую слева от оператора присвоения. С правой стороны от оператора присвоения может находится только одно значение. А для обмена занчениями двух переменных, вместо традиционной записи:\na,b = b,a; Нужно использовать отдельный оператор обмена:\na :=: b; В качестве правого операнда в операторе присвоения допускается использовать оператор распаковки словаря … (многоточие), который можно использовать и при передаче аргументов в функцию.\nargs := (arg1=1, arg2=2, 3,4,); call(arg=0, ... args); # Что равносильно вызову call(arg=0, arg1=1, arg2=2, 3, 4); Словарь может быть указан и с левой стороны от оператора присвоения. Таким образом можно записать самый простой способ перебора всех его элементов: item, dictionary := ... dictionary;, т.е. когда первый элемент словаря сохраняется в переменную item, а из самого словаря удаляется, и так в цикле пока словарь не станет пустым.\nПример реализации цикла foreach для суммирования всех элементов словаря (или одномерного тензора) с использованием оператора раскрытия словаря (списка):\nsumma := 0; dictionary := (1,2,3,4,5,); @while( dictionary ) { # Первый элемент словаря перемещается в item item, dictionary := ... dictionary; summa += item; }; Заполнение данными При заполнении данными размерных тензоров существует краткий способ указания их начальных значений. Для этого используется многоточие в следующих вариантах:\n:Tensor[10](2,3, ...) - повторение всех предыдущих данных до полного заполнения тензора, что равносильно записи :Tensor[10](2,3, 2,3, 2,3, 2,3, 2,3).\n:Tensor[10](2, 3, ... 42 ...) - заполнение значением 42 до конца тензора, что равносильно записи :Tensor[10](2,3, 42,42,42,42,42,42,42,42).\n:Tensor[10](2, 3, ... rand() ...) - заполнение до конца тензора значением, которое будет возвращать функция. Указанная функция будет вызываться для каждого элемента до полного заполнения тензора (8 раз).\n:Tensor[10]( rand(), rand(), ...) - заполнение тензора двумя произвольными заначениями, то есть функция rand() будет вызвана дважды для двух первых элементов, после чего эти значения будут использоваться до полного заполнения тензора (как в первом примере).\n:Tensor[10]( ... 0..0.99..0.1 ) - заполнение тензора элементами диапазона, что равносильно записи\n:Tensor[10](0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9). Раскрытие диапазона создает фиксированное количество значений. Поэтому в данном примере размерность тензора можно не указывать, так как она будет создана автоматически.\n:Tensor[15]( ... 0..5 , ... ) - заполнение тензора элементами диапазона с их повторением до заданного размера тензора: :Tensor(0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4)\nЗаполнение данными в словарях и аргументах функций Предыдущие способы заполнения данными возможны только для тензоров фиксированного размера, так как позволяют получить произвольное количество значений, но их можно применять только в конце списка значения для инициализации.\nОператоры раскрытия словаря или диапазона создают ограниченное количество значений, но за счет этого их можно использовать не только для инициализации тензоров, но и в качестве начальных значений у словарей или создания аргументов при вызове функций, причем в произвольном месте, а не только в конце списка инициализации:\n:Tensor( ... 0..0.99..0.1 ) - заполнение тензора без указания его размера элементами диапазона, что равносильно записи :Tensor(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)\nfuntcion( 0, ... dict, 42 ) - раскрытие словаря как индивидуальных не именованных аргументов функции, к примеру funtcion( 0, 1, 2, 3, 42), если словарь dict содержал три элемента 1, 2 и 3.\nfuntcion( ... ... dict, end=4) - раскрытие словаря как индивидуальных именованных аргументов функции. Если словарь dict будет содержать элементы (1, two=2, three=3,), то это будет равносильно вызову функции funtcion( 1, two=2, three=3, end=4).\n","categories":"","description":"","excerpt":" Область видимости объекта =/= время жизни объекта Область видимости …","ref":"/ru/docs/ops/create/","tags":"","title":"Создание объектов"},{"body":"NewLang является языком с динамической типизацией и явное указание типа не влияет на размер памяти, занимаемой переменной. Информация о типах используется при проверке их совместимости, когда существующему объекту присваивается значение другого типа. Такая операция возможна только тогда, когда типы совместимы между собой и допускают автоматическое приведение. Это справедливо как во время парсинга/компиляции исходного теста, так и во время выполнения в режимах интерпретатора и/или скомпилированного файла.\nАрифметические типы Все числа (кроме рациональных) в NewLang являются тензорами, т.е. массивами одного типа с произвольным количеством измерений и одинаковым размером столбцов в каждом. Единичное число, это тоже тензор нулевого размера.\nПоддерживаются только знаковые целые числа, т.к. в без знаковых числах особая нужда отсутствует, а проблем с ними можно найти очень много на ровном месте.\nПроблемы без знаковых чисел (из интернета):\nВо-первых, вычитание двух без знаковых чисел, например 3 и 5. 3 минус 5 равно 4294967294, т.к. -2 не может быть представлено как без знаковое число. Во-вторых, непредвиденное поведение может возникнуть при смешивании целочисленных значений со знаком и без знака. С++ может свободно преобразовывать числа со знаком и без знака, но не проверяет диапазон, чтобы убедиться, что вы не переполняете свой тип данных.\nИмена встроенных арифметических типов: :Int8, :Int16, :Int32, :Int64, :Float16, :Float32, :Float64, :Complex16, :Complex32, :Complex64 говорят сами за себя. И хотя среди них присуствуют названия, присущие беззнаковым числам (:Byte, :Word, :DWord и т.д.), они являются синонимами и применяются для взаимодействия с нативным C++ кодом.\nЛогический тип Отдельным типом идет логический тип :Bool, который может принимать значения только 0 или 1 (false/true соответственно), и в зависимости от выполняемой операции тоже может быть отнесен к целочисленным типам, так и не входить в их состав (данный подход интерпретации логического типа данных был взят из библиотеки Torch).\n// Treat bool as a distinct \"category,\" to be consistent with type promotion // rules (e.g. `bool_tensor + 5 -\u003e int64_tensor`). If `5` was in the same // category as `bool_tensor`, we would not promote. Differing categories // implies `bool_tensor += 5` is disallowed. // // NB: numpy distinguishes \"unsigned\" as a category to get the desired // `bool_tensor + 5 -\u003e int64_tensor` behavior. We don't, because: // * We don't want the performance hit of checking the runtime sign of Scalars. // * `uint8_tensor + 5 -\u003e int64_tensor` would be undesirable. Индексация тензоров Доступ к элементам тензора происходит по целочисленному индексу, который начинается с 0. Для многомерного тензора, индексы элемента перечисляются в квадратных скобках через запятую. Поддерживается доступ к элементам через отрицательный индекс, который обрабатывается точно так же, как в Python (-1 последний элемент, -2 предпоследний и т.д.).\nВ качесте индекса тензора могут быть использованы диапазоны которые обработываются точно так же как и в Python, а так же значение :None и многоточие .... Значение :None, т.е. отсуствие индекса, означает произвольный размер тензора в одном конкретном измерении, тогда как многоточие ... обозначет произвольную размерность в любом количестве измерений (поэтому может встречаться в индексе тензора только однократно).\nЛитерал тензор в тексте программы записывается в квадратных скобках с обязательной завершающей запятой, т.е. [1, 2,] — это литерал одномерный тензор из двух чисел. После закрывающей скобки тип тензора может быть указан в явном виде. Если тип не указан, то он выводится автоматически на основании указанных данных и выбирается минимально возможный байтовый размер, который позволяет сохранить все значения без потери точности.\nПримеры создания тензоров и преобразования их размерности можно посмотреть тут.\nРациональные числа Для вычислений с неограниченной точностью в NewLang используются отдельный тип - рациональные числа. Они записываются в форме обыкновенной дроби, в которой числитель должен быть целым числом, а знаменатель натуральным (целым без нуля). В качестве разделителя дроби используется обратная косая черта, т.е. 1\\1 - рациональное число 1, -5\\1 - рациональное числа -5 и т.д.\n","categories":"","description":"","excerpt":"NewLang является языком с динамической типизацией и явное указание …","ref":"/ru/docs/types/numbers/","tags":"","title":"Числа"},{"body":"Блок кода, это сгруппированный набор идущих подряд инструкций, которые выполняются как единое целое с возвращением результата выполнения последней из них. Блок кода, как и любая синтаксическая конструкция языка, должен завершаться точкой с запятой “;”.\nБлоки кода используются для ограничения области видимости переменных. С их помощью определяется иерархия области имен и реализуется система именования свойств и методов для классов. Именованные блоки кода могут выступать в качестве локальных меток для передачи потока выполнения.\nЗа счет того, что к блоку кода можно обратится как к единой инструкции, они могут использоваться в других операторах. Тело функции, также представляет собой блока кода, который располагается в пространстве имен определения этой функции.\nns:: { # Пространство имен ns name { # Пространство имен ns::name # В конце имени \"::\" можно не указывать }; :: { # Глобальное пространство имен ... }; { # Локальная переменная до завершения блока кода $local ::= 0; }; $local; # \u003c-- Ошибка! Локальная переменная не видна }; func_name(val) ::= { # Блок кода func_name:: @if($val) { ... } @else { ... }; }; Оформление блока кода Блок кода всегда начинается и заканчивается на фигурные скобки («{» и «}») и завершается точкой с запятой “;”. Существуют блоки кода, которые перехватывают потоки выполнения, с помощью которых реализуются возврат и обработка ошибок.\nТип возвращаемого значения блоком кода можно указать в явном виде. Для этого, после завершающей фигурной скобки, нужно указать разрешенный тип, после чего компилятор будет проверят корретность данных внутрие блока кода, которые могут быть возвращены.\nМожно указать сразу несколько типов, перечислив их через запятую в угловых скобрах.\n{ op1; op2; }; # \u003c--- Контроль типа возврата не производится { op1; op2; # \u003c--- Проверка типа возвращаемого значения } :Type; # \u003c--- Разрешенный тип { op1; op2; ... }: \u003c:Type1, :Type2, :Type3\u003e; # \u003c--- Несколько разрешенных типов возврата { op1; op2; ... }: \u003c ... \u003e; # \u003c--- Разрешен любой тип возвращаемого значения Расширенный синтаксис Расширенный синтаксис с нативным исходным кодом на языке реализации (С++), это тоже блок кода. Он начинается и заканчивается на фигурные скобки со знаком процента («{%» и «%}»).\nВнутри блока кода с расширенным синтаксисом можно применять произвольные элементы языка реализации (С++), но нужно иметь ввиду, что расширенный синтаксис является исходным текстом программы и напрямую подстваляется и выходной текст трансплайтера во время компиляции файла.\nС помощью блока кода с расширенным синтаксисом можно реализовать разные элементы, которые отсуствуют в основном синтаксисе, например, безусловный переход на заданную метку.\n@@ label $name @@ ::= @@@ {% @$name:; %} @@@; @@ goto $label @@ ::= @@@ {% goto @$label; %} @@@; @goto label_for_goto; # Skip this code @label label_for_goto; Взаимодействие расширенного синтаксиса с основным кодом программы происходит путем обращения к локальным объектам или макросам программы изнутри блока кода. Но для этого, имя объекта должно быть указано полностью, включая все квалификаторы имени.\nЕсли есть необходимость обратится к статическому объекту, его имя нужно заменить макросом, так как символ двоеточия используется в синтаксисе языков C/C++.\nНачиная с версии C++26 взаимодействие с расширенным синтаксисом может быть нарушено!\nAdd the same characters @, $, and ` to the basic character set [C++26] P2558R2\nfactorial := 1000; ::result := 1\\1; /* Rational number */ @@ res @@ ::= ::result; {% // Source on the C++ for( int i=2; i \u003c= static_cast\u003cunsigned int\u003e( $factorial ); i++ ){ @res *= i; } printf(\"\\nFactorial %i! = %s\\n\", static_cast\u003cunsigned int\u003e( $factorial ), static_cast\u003cconst char *\u003e( @res )); # std::cout \u003c\u003c \"Factorial \" \u003c\u003c static_cast\u003cunsigned int\u003e( $factorial ); # std::cout \u003c\u003c \"! = \" \u003c\u003c static_cast\u003cconst char *\u003e( @res ) \u003c\u003c std::endl; %} ","categories":"","description":"","excerpt":"Блок кода, это сгруппированный набор идущих подряд инструкций, которые …","ref":"/docs/ops/block/","tags":"","title":"Блоки кода"},{"body":"Блок кода, это сгруппированный набор идущих подряд инструкций, которые выполняются как единое целое с возвращением результата выполнения последней из них. Блок кода, как и любая синтаксическая конструкция языка, должен завершаться точкой с запятой “;”.\nБлоки кода используются для ограничения области видимости переменных. С их помощью определяется иерархия области имен и реализуется система именования свойств и методов для классов. Именованные блоки кода могут выступать в качестве локальных меток для передачи потока выполнения.\nЗа счет того, что к блоку кода можно обратится как к единой инструкции, они могут использоваться в других операторах. Тело функции, также представляет собой блока кода, который располагается в пространстве имен определения этой функции.\nns:: { # Пространство имен ns name { # Пространство имен ns::name # В конце имени \"::\" можно не указывать }; :: { # Глобальное пространство имен ... }; { # Локальная переменная до завершения блока кода $local ::= 0; }; $local; # \u003c-- Ошибка! Локальная переменная не видна }; func_name(val) ::= { # Блок кода func_name:: @if($val) { ... } @else { ... }; }; Оформление блока кода Блок кода всегда начинается и заканчивается на фигурные скобки («{» и «}») и завершается точкой с запятой “;”. Существуют блоки кода, которые перехватывают потоки выполнения, с помощью которых реализуются возврат и обработка ошибок.\nТип возвращаемого значения блоком кода можно указать в явном виде. Для этого, после завершающей фигурной скобки, нужно указать разрешенный тип, после чего компилятор будет проверят корретность данных внутрие блока кода, которые могут быть возвращены.\nМожно указать сразу несколько типов, перечислив их через запятую в угловых скобрах.\n{ op1; op2; }; # \u003c--- Контроль типа возврата не производится { op1; op2; # \u003c--- Проверка типа возвращаемого значения } :Type; # \u003c--- Разрешенный тип { op1; op2; ... }: \u003c:Type1, :Type2, :Type3\u003e; # \u003c--- Несколько разрешенных типов возврата { op1; op2; ... }: \u003c ... \u003e; # \u003c--- Разрешен любой тип возвращаемого значения Расширенный синтаксис Расширенный синтаксис с нативным исходным кодом на языке реализации (С++), это тоже блок кода. Он начинается и заканчивается на фигурные скобки со знаком процента («{%» и «%}»).\nВнутри блока кода с расширенным синтаксисом можно применять произвольные элементы языка реализации (С++), но нужно иметь ввиду, что расширенный синтаксис является исходным текстом программы и напрямую подстваляется и выходной текст трансплайтера во время компиляции файла.\nС помощью блока кода с расширенным синтаксисом можно реализовать разные элементы, которые отсуствуют в основном синтаксисе, например, безусловный переход на заданную метку.\n@@ label $name @@ ::= @@@ {% @$name:; %} @@@; @@ goto $label @@ ::= @@@ {% goto @$label; %} @@@; @goto label_for_goto; # Skip this code @label label_for_goto; Взаимодействие расширенного синтаксиса с основным кодом программы происходит путем обращения к локальным объектам или макросам программы изнутри блока кода. Но для этого, имя объекта должно быть указано полностью, включая все квалификаторы имени.\nЕсли есть необходимость обратится к статическому объекту, его имя нужно заменить макросом, так как символ двоеточия используется в синтаксисе языков C/C++.\nНачиная с версии C++26 взаимодействие с расширенным синтаксисом может быть нарушено!\nAdd the same characters @, $, and ` to the basic character set [C++26] P2558R2\nfactorial := 1000; ::result := 1\\1; /* Rational number */ @@ res @@ ::= ::result; {% // Source on the C++ for( int i=2; i \u003c= static_cast\u003cunsigned int\u003e( $factorial ); i++ ){ @res *= i; } printf(\"\\nFactorial %i! = %s\\n\", static_cast\u003cunsigned int\u003e( $factorial ), static_cast\u003cconst char *\u003e( @res )); # std::cout \u003c\u003c \"Factorial \" \u003c\u003c static_cast\u003cunsigned int\u003e( $factorial ); # std::cout \u003c\u003c \"! = \" \u003c\u003c static_cast\u003cconst char *\u003e( @res ) \u003c\u003c std::endl; %} ","categories":"","description":"","excerpt":"Блок кода, это сгруппированный набор идущих подряд инструкций, которые …","ref":"/ru/docs/ops/block/","tags":"","title":"Блоки кода"},{"body":"","categories":"","description":"","excerpt":"","ref":"/blog/","tags":"","title":"Articles"},{"body":"NewLang supports two types of strings:\n:StrChar - universal byte UTF-8 strings :StrWide - system character (wide characters) The single element of a universal UTF-8 string is one byte, while the single element of a system character string is a wide character wchar_t. And although the strings differ in the types of single string elements, the internal representation of both types of strings is the same. All data of character strings is stored as a universal byte UTF-8 sequence.\nByte Strings :StrChar The basic element of a universal byte string is one byte (specifically :Int8, i.e. an 8-bit signed integer). The number of characters in a byte string is returned in bytes, and accessing a string element by index is done by the byte of the character sequence.\nSince these strings are interpreted as a sequence of UTF-8 characters, caution must be taken when modifying individual bytes!\nSystem Strings :StrWide The individual element of the system string is a wide character wchar_t, and the number of elements in the system character string is returned in wide characters. The size of the wchar_t type depends on the operating system, so the size of one character :StrWide in Windows will be 2 bytes, and in Linux 4 bytes, which is related to their implementation specifics.\nThe main purpose of system strings is to simplify working in a text terminal, as one character always corresponds to one character cell without the need for constant conversion of UTF-8 code points.\nString Formatting Any variable can be accessed as a function (by specifying parentheses after its name) to create a copy/clone of the object, and for strings, this operation can be used as a template for formatting data.\nString formatting can be done in two ways:\nSpecify a format string with the types of data to be output (the format string corresponds to formatting in the standard printf function). To apply this formatting variant, the format string must specify the corresponding data type (: FmtChar or : FmtWide for regular and wide characters, respectively).\nWith this formatting method, named arguments cannot be used, and the compiler checks the types of the passed values for compliance with the format string only during compilation of the program text. This type of format string can be used as the last argument of a function to check the types of all subsequent arguments for compliance with the format string.\nIn all other cases, any strings and named arguments can be used as the format string, and the format itself corresponds to the format string from the {fmt} library. The only difference is the ability to specify not only the positional number of the argument, but also its name. Argument validation against the format string is performed during string cloning both at compile time and during program execution.\nThe formatting method is used by default for any type of string, but the format string is not checked in the function arguments.\nFor example:\n$fmt := '%s: %d':FmtChar; # Formatting like in printf $result := $fmt('value', 123); # \"value: 123\" - Check compile time only! $template := \"{name} {0}\"; # fmt::format equivalent \"{1} {0}\" $result := $template(\"template\", name = \"String\"); # result = \"String template\" ","categories":"","description":"","excerpt":"NewLang supports two types of strings:\n:StrChar - universal byte UTF-8 …","ref":"/docs/types/strings/","tags":"","title":"Character Strings"},{"body":" The materials are in the process of being translated into English!\nBasic materials on the NewLang programming language.\nThe description is valid for the current version 0.4\n","categories":"","description":"","excerpt":" The materials are in the process of being translated into English! …","ref":"/docs/","tags":"","title":"Documentation"},{"body":"NewLang supports namespaces, where the separator, like in C++, is a double colon “::”.\nA namespace can be specified for an individual identifier or for an entire code block.\nUnlike namespace in C++, namespaces in NewLang are used not only to organize code into logical groups and avoid name conflicts, but also to associate an identifier, explicitly specifying the namespace, with static objects (memory allocated during the compilation stage of the program).\nThe global name cannot be overridden by a macro or local variable during name lookup. To create a global (static) variable in the current namespace, you can specify the variable with the @:: preprocessor.\nTo use a namespace in a code block, it must be specified before the opening curly brace. In such a named code block, it is not necessary to specify the closing “::”.\n::var ::= 0; # Name of global variable explicitly (cannot be overridden) ns { # Equivalent to ns:: var ::= 0; # Name ns::var (can be overridden by macro or local variable) @::var ::= 0; # Name of global variable ::ns::var (cannot be overridden) name:: { var = 0; # Reference to variable ns::var var2 ::= 0; # Name of variable will be ns::name::var2 ::var = 1; # Variable from global namespace }; :: { # Global namespace var = 1; # Name of global variable ::var (can be overridden) ::ns::var = 0; # Name of another global variable (cannot be overridden) }; }; Namespaces, Modules, and Packages The namespace in NewLang supports both a modular code structure like in Java and Python languages, and when specifying the full name of an object, program modules and namespaces can be combined.\nFor example, the full name of a variable can be written with the indication of the program module \\root\\dir\\module::ns::name::var, where root and dir are directories in the file system relative to the current module, and module is the file name, i.e. root/dir/module.src.\nNamespace and OOP In NewLang, name decoration (mangling) based on function argument types is not used.\nHowever, when creating unique identifiers for class methods, NewLang uses an approach similar to that used in the Python language. When creating a class method, a global function is created with the class name and method name combined with the separator “::”.\nFor example, for the class :NewClass, when creating the method method, a function named NewClass::method will be created.\nThis method naming scheme fully corresponds to the naming of functions in the namespace, allowing class methods to be defined outside the body of the class simply by specifying the desired name in the namespace or explicitly.\nExample of creating a method of the class NewClass in the namespace:\nNewClass:: { method() := { }; } Example of creating a method of the class NewClass with specifying the full name:\nNewClass::method() := { }; ","categories":"","description":"","excerpt":"NewLang supports namespaces, where the separator, like in C++, is a …","ref":"/docs/syntax/namespace/","tags":"","title":"Namespaces"},{"body":"Именование объектов основано на правилах и выбирается из расчёта удобства для программиста. Название переменной или функции должно нести смысл, понятные параметры и тип возвращаемого значения, которые упрощают понимание алгоритма при последующем чтении исходного текста программы.\nНо обычные имена мало о чём говорят компьютеру. Поэтому при компиляции программы, имена объектов преобразуются для удобства машинной обработки и к ним добавляется служебная информация.\nВнутреннее имя объекта Каждый объект имеет свое внутреннее имя, уникальное в рамках текущего модуля, с помощью которого комипилятор языка однозначно связывает объект с данными в памяти компьютера.\nВнутреннее имя формируется во время анализа синтаксического дерева программы. Оно включает в себя имя объекта, его квалификатор и полное пространство имен, в котором объект был опеределен.\nУ статических объектов (типов и классов), внутренее имя соотвествует полному имени объекта с учетом всех областей имен, тогда как внутреннее имя автоматичеких объектов включает в себя и пустые (не именованные) блоки кода, которые заменяются на монотонно возрастающий порядковый номер блока (т.е. ::1::, ::2:: и т.д.). Включение в пространство имен пустых блоков кода необходимо для реализации возможности перекрытия имен у объектов, определенных в разных областях видимости.\nКроме этого, все квалификаторы объектов переносятся в конец имени, что и является отличительным признаком внутреннего имени (последний символ должен быть “$” или “:”).\nПримеры внутренних имен:\n# Глобальный статический объект ::var ::= 0; # ::var:: # Локальный объект модуля $var := 0; # var$ # Статический объект модуля @::var ::= 0; # var:: # Глобальные тип и конструктор класса :: :type := :Type; # ::type::: :: :cls := Class(){}; # ::cls::: # Синоним типа или конструктор класса модуля :type := :Type; # type::: :cls := Class(){}; # cls::: # Тип или конструктор класса всегда статические @:: :type := :Type; # type::: @:: :cls := Class(){}; # cls::: ns { $var := 0; # ns::var$ var ::= 0; # ns::var$ @::var ::= 0; # ns::var:: - статический объект :type := :Type; # ns::type::: :cls := Class(){}; # ns::cls::: @::func1() ::= {}; # ns::func1:: func2() ::= {}; # ns::func2:: # Не именованный блок кода { # Локальные имена перекрывают объявления выше $var := 0; # ns::1::var$ var := 0; # ns::1::var$ # Статический объект соответствует области имен @::var ::= 0; # ns::var:: # Типы данных всегда статические :type := :Type; # ns::type::: :cls := Class(){}; # ns::cls::: @::func3() := {}; # ns::func3:: # Локальная функция с ограниченной областью видимости ????? func4() := {}; # ns::1::func4$ } }; # Не именованный блок кода { $var := 0; # 2::var$ var ::= 0; # 2::var$ @::var = 0; # var:: - статический объект :type := :Type; # type::: :cls := Class(){}; # cls::: }; Манглинг внутренних имен Внутреннее имя уникально только в рамках одного модуля, но внутренние имена в разных модулях могут пересекаться.\nМанглинг внутренних имя предназначен для объединения нескольких модулей в рамках одной программы, и используется как способ кодирования имени функции, структуры, класса или другого типа данных при передачи дополнительной семантической информации от компилятора компоновщику.\nВнутреннее имя объекта после манглинга является корректным идентификатором для языков C/C++, что позволяет обращатся к объектам NewLang из внешних библиотек и приложений на языке реализации (C/C++) по семантически похожему имени (в отличии от манглинга имен в С++).\nМанглинг внутреннего имени заключается в замене каждого символа двоеточия на символ $, а у имени типа квалификатор заменяется тремя символами ‘$’, т.е. ’type $$$’.\nПри манглинге, к внутренним именам объектов добавляется специальный префикс, который кодирует имя компилируемого модуля. Имя текущего модуля находится в переменной препроцессора \"@$$\" и по умолчанию, содержит имя файла модуля (у главного модуля приложения имя модуля отсутствует).\nИмя модуля может быть однократно переопределено самым первым оператором модуля или заменено во время импорта модуля с помощью системного параметра __package__.\n# Задать имя модуля @$$ = \"\\dir\\file\"; # Импорт модуля с переопределением имени \\dir\\file(__package__=\"\\new\\module\\name\"); Тоже само с использвоанием DSL:\n@package \\dir\\name; # @$$ = \"\\dir\\file\"; @import \\dir\\name as \\new\\module\\name; # \\dir\\file(__package__=\"\\new\\module\\name\"); При манглинге имя модуля, по умолчанию имя файла отностительно каталога главного файла программы, размещается в начале внутреннего системного имени. Так как имя модуля, согласно правилам синтаксиса, может содерждать только строчные буквы и цифры, то разделитель каталогов (обратный слеш) заменяется на подчерк, а начало и конец имени модуля отмечаются комбинациями символов “_$” и “$_” соответственно.\nТак как локальной переменной с одним подчерком в качестве имени быть не может, то начало строки на “_$” служит отличительным признаком манглинга внутреннего имени объекта.\n@$$ = \"\\dir\\file\"; # Глобальный статический объект ::var ::= 0; # _$dir_file$_$$var$$ # Локальный объект модуля $var := 0; # _$dir_file$_var$ # Статический объект модуля @::var ::= 0; # _$dir_file$_var$$ # Глобальные тип и конструктор класса :: :type := :Type; # _$dir_file$_$$type$$$ :: :cls := Class(){}; # _$dir_file$_$$cls$$$ # Синоним типа или конструктор класса модуля :type := :Type; # _$dir_file$_type$$$ :cls := Class(){}; # _$dir_file$_cls$$$ ns { $var := 0; # _$dir_file$_ns$$var$ var ::= 0; # _$dir_file$_ns$$var$ @::var ::= 0; # _$dir_file$_ns$$var$$ - статический объект :type := :Type; # _$dir_file$_ns$$type$$$ :cls := Class(){}; # _$dir_file$_ns$$cls$$$ @::func() ::= {}; # _$dir_file$_ns$$func$$ func() ::= {}; # _$dir_file$_ns$$func$ # Не именованный блок кода { # Локальные имена перекрывают обяъявления выше $var := 0; # _$dir_file$_ns$$1$$var$ var := 0; # _$dir_file$_ns$$1$$var$ # Статический объект соответствует области имен @::var ::= 0; # _$dir_file$_ns$$var$$ # Типы данных и функции всегда статические :type := :Type; # _$dir_file$_ns$$type$$$ :cls := Class(){}; # _$dir_file$_ns$$cls$$$ @::func() := {}; # _$dir_file$_ns$$func$$ func() := {}; # _$dir_file$_ns$$1$$func$ ???????? } }; # Не именованный блок кода { $var := 0; # _$dir_file$_2::var$ var ::= 0; # _$dir_file$_2::var$ @::var = 0; # _$dir_file$_var$$ - статический объект :type := :Type; # _$dir_file$_type$$$ :cls := Class(){}; # _$dir_file$_cls$$$ }; Манглинг имен блока кода главного модуля программы:\n{ $var := 0; # _$$_1::var$ var ::= 0; # _$$_1::var$ @::var = 0; # _$$_var$$ - статический объект :type := :Type; # _$$_type$$$ :cls := Class(){}; # _$$_cls$$$ }; Встроенный блок кода и вызов функций В расширенном синатксисе с исходным кодом языка реализации можно взаимодействовать с другим кодом программы за счет обращения к локальным объектам или макросам изнутри блока кода.\nЭто досупкается как для обычных переменных, так и для имен функций, реализованных в NewLang, и для того, что бы компилятор C/C++ имел возможность создать правильный код, при раскрытии встроенного блока кода перед ним добавляются сигнатуры переменных и функций, которые используются во строенном блоке кода.\nДля имен переменных дополнительный манглинг имен не производится, а для функций автоматичсеки создается дополнительная сигнатура с описанием типов аргументов и их значений по умолчанию, если таковые используются.\nКаждая функция NewLang имеет две сигнатуры, первая (основная) принимает все аргументы в виде словаря, а вторая (дополнительная) с развернутым списком аргументов, чтобы её можно было вызывать как обычную C++ функцию и проверка типов могла происходить С/С++ непосредственно компилятором.\nМанглинг второго (дополнительного) имени функции заключается в добавлении в конец имени двух символов “_$”.\n# Определение функции в NewLang ::func_embed(int64_t arg_long, uint8_t arg_byte = 10): Int64 ::= { @return arg_long + arg_byte; } # С/С++ прототип для первого (основоного) имени # extern \"C\" _$$_func_embed$( Obj \u0026args ); # С/С++ прототип для второго (дополнительного) имени # extern \"C\" _$$_func_embed$_$(int64_t arg_long, uint8_t arg_byte = 10); # Тогда при раскрытии блока с расширенным синтаксисом # $func_embed заменяется на _$$_func_embed$_$, а компилятор С/С++ # будет в состоянии проверить её аргументы {% int64_t value = $func_embed(10, 20); %} Хотя может имеет смысл сделать inline шаблон для подобного вызова, а не создавать кополнительное имя?\n./object.h:732:25: error: deduced conflicting types ('int' vs 'const char *') for initializer list element type auto list = {args...}; ^~~~~ test/object_test.cpp:131:21: note: in instantiation of function template specialization 'newlang::Obj::operator()\u003cint, const char *\u003e' requested here str3 = (*format)(-1, \"222\"); ^ ","categories":"","description":"","excerpt":"Именование объектов основано на правилах и выбирается из расчёта …","ref":"/docs/arch/mangling/","tags":"","title":"Внутреннее имя и манглинг имен"},{"body":"Именование объектов основано на правилах и выбирается из расчёта удобства для программиста. Название переменной или функции должно нести смысл, понятные параметры и тип возвращаемого значения, которые упрощают понимание алгоритма при последующем чтении исходного текста программы.\nНо обычные имена мало о чём говорят компьютеру. Поэтому при компиляции программы, имена объектов преобразуются для удобства машинной обработки и к ним добавляется служебная информация.\nВнутреннее имя объекта Каждый объект имеет свое внутреннее имя, уникальное в рамках текущего модуля, с помощью которого комипилятор языка однозначно связывает объект с данными в памяти компьютера.\nВнутреннее имя формируется во время анализа синтаксического дерева программы. Оно включает в себя имя объекта, его квалификатор и полное пространство имен, в котором объект был опеределен.\nУ статических объектов (типов и классов), внутренее имя соотвествует полному имени объекта с учетом всех областей имен, тогда как внутреннее имя автоматичеких объектов включает в себя и пустые (не именованные) блоки кода, которые заменяются на монотонно возрастающий порядковый номер блока (т.е. ::1::, ::2:: и т.д.). Включение в пространство имен пустых блоков кода необходимо для реализации возможности перекрытия имен у объектов, определенных в разных областях видимости.\nКроме этого, все квалификаторы объектов переносятся в конец имени, что и является отличительным признаком внутреннего имени (последний символ должен быть “$” или “:”).\nПримеры внутренних имен:\n# Глобальный статический объект ::var ::= 0; # ::var:: # Локальный объект модуля $var := 0; # var$ # Статический объект модуля @::var ::= 0; # var:: # Глобальные тип и конструктор класса :: :type := :Type; # ::type::: :: :cls := Class(){}; # ::cls::: # Синоним типа или конструктор класса модуля :type := :Type; # type::: :cls := Class(){}; # cls::: # Тип или конструктор класса всегда статические @:: :type := :Type; # type::: @:: :cls := Class(){}; # cls::: ns { $var := 0; # ns::var$ var ::= 0; # ns::var$ @::var ::= 0; # ns::var:: - статический объект :type := :Type; # ns::type::: :cls := Class(){}; # ns::cls::: @::func1() ::= {}; # ns::func1:: func2() ::= {}; # ns::func2:: # Не именованный блок кода { # Локальные имена перекрывают объявления выше $var := 0; # ns::1::var$ var := 0; # ns::1::var$ # Статический объект соответствует области имен @::var ::= 0; # ns::var:: # Типы данных всегда статические :type := :Type; # ns::type::: :cls := Class(){}; # ns::cls::: @::func3() := {}; # ns::func3:: # Локальная функция с ограниченной областью видимости ????? func4() := {}; # ns::1::func4$ } }; # Не именованный блок кода { $var := 0; # 2::var$ var ::= 0; # 2::var$ @::var = 0; # var:: - статический объект :type := :Type; # type::: :cls := Class(){}; # cls::: }; Манглинг внутренних имен Внутреннее имя уникально только в рамках одного модуля, но внутренние имена в разных модулях могут пересекаться.\nМанглинг внутренних имя предназначен для объединения нескольких модулей в рамках одной программы, и используется как способ кодирования имени функции, структуры, класса или другого типа данных при передачи дополнительной семантической информации от компилятора компоновщику.\nВнутреннее имя объекта после манглинга является корректным идентификатором для языков C/C++, что позволяет обращатся к объектам NewLang из внешних библиотек и приложений на языке реализации (C/C++) по семантически похожему имени (в отличии от манглинга имен в С++).\nМанглинг внутреннего имени заключается в замене каждого символа двоеточия на символ $, а у имени типа квалификатор заменяется тремя символами ‘$’, т.е. ’type $$$’.\nПри манглинге, к внутренним именам объектов добавляется специальный префикс, который кодирует имя компилируемого модуля. Имя текущего модуля находится в переменной препроцессора \"@$$\" и по умолчанию, содержит имя файла модуля (у главного модуля приложения имя модуля отсутствует).\nИмя модуля может быть однократно переопределено самым первым оператором модуля или заменено во время импорта модуля с помощью системного параметра __package__.\n# Задать имя модуля @$$ = \"\\dir\\file\"; # Импорт модуля с переопределением имени \\dir\\file(__package__=\"\\new\\module\\name\"); Тоже само с использвоанием DSL:\n@package \\dir\\name; # @$$ = \"\\dir\\file\"; @import \\dir\\name as \\new\\module\\name; # \\dir\\file(__package__=\"\\new\\module\\name\"); При манглинге имя модуля, по умолчанию имя файла отностительно каталога главного файла программы, размещается в начале внутреннего системного имени. Так как имя модуля, согласно правилам синтаксиса, может содерждать только строчные буквы и цифры, то разделитель каталогов (обратный слеш) заменяется на подчерк, а начало и конец имени модуля отмечаются комбинациями символов “_$” и “$_” соответственно.\nТак как локальной переменной с одним подчерком в качестве имени быть не может, то начало строки на “_$” служит отличительным признаком манглинга внутреннего имени объекта.\n@$$ = \"\\dir\\file\"; # Глобальный статический объект ::var ::= 0; # _$dir_file$_$$var$$ # Локальный объект модуля $var := 0; # _$dir_file$_var$ # Статический объект модуля @::var ::= 0; # _$dir_file$_var$$ # Глобальные тип и конструктор класса :: :type := :Type; # _$dir_file$_$$type$$$ :: :cls := Class(){}; # _$dir_file$_$$cls$$$ # Синоним типа или конструктор класса модуля :type := :Type; # _$dir_file$_type$$$ :cls := Class(){}; # _$dir_file$_cls$$$ ns { $var := 0; # _$dir_file$_ns$$var$ var ::= 0; # _$dir_file$_ns$$var$ @::var ::= 0; # _$dir_file$_ns$$var$$ - статический объект :type := :Type; # _$dir_file$_ns$$type$$$ :cls := Class(){}; # _$dir_file$_ns$$cls$$$ @::func() ::= {}; # _$dir_file$_ns$$func$$ func() ::= {}; # _$dir_file$_ns$$func$ # Не именованный блок кода { # Локальные имена перекрывают обяъявления выше $var := 0; # _$dir_file$_ns$$1$$var$ var := 0; # _$dir_file$_ns$$1$$var$ # Статический объект соответствует области имен @::var ::= 0; # _$dir_file$_ns$$var$$ # Типы данных и функции всегда статические :type := :Type; # _$dir_file$_ns$$type$$$ :cls := Class(){}; # _$dir_file$_ns$$cls$$$ @::func() := {}; # _$dir_file$_ns$$func$$ func() := {}; # _$dir_file$_ns$$1$$func$ ???????? } }; # Не именованный блок кода { $var := 0; # _$dir_file$_2::var$ var ::= 0; # _$dir_file$_2::var$ @::var = 0; # _$dir_file$_var$$ - статический объект :type := :Type; # _$dir_file$_type$$$ :cls := Class(){}; # _$dir_file$_cls$$$ }; Манглинг имен блока кода главного модуля программы:\n{ $var := 0; # _$$_1::var$ var ::= 0; # _$$_1::var$ @::var = 0; # _$$_var$$ - статический объект :type := :Type; # _$$_type$$$ :cls := Class(){}; # _$$_cls$$$ }; Встроенный блок кода и вызов функций В расширенном синатксисе с исходным кодом языка реализации можно взаимодействовать с другим кодом программы за счет обращения к локальным объектам или макросам изнутри блока кода.\nЭто досупкается как для обычных переменных, так и для имен функций, реализованных в NewLang, и для того, что бы компилятор C/C++ имел возможность создать правильный код, при раскрытии встроенного блока кода перед ним добавляются сигнатуры переменных и функций, которые используются во строенном блоке кода.\nДля имен переменных дополнительный манглинг имен не производится, а для функций автоматичсеки создается дополнительная сигнатура с описанием типов аргументов и их значений по умолчанию, если таковые используются.\nКаждая функция NewLang имеет две сигнатуры, первая (основная) принимает все аргументы в виде словаря, а вторая (дополнительная) с развернутым списком аргументов, чтобы её можно было вызывать как обычную C++ функцию и проверка типов могла происходить С/С++ непосредственно компилятором.\nМанглинг второго (дополнительного) имени функции заключается в добавлении в конец имени двух символов “_$”.\n# Определение функции в NewLang ::func_embed(int64_t arg_long, uint8_t arg_byte = 10): Int64 ::= { @return arg_long + arg_byte; } # С/С++ прототип для первого (основоного) имени # extern \"C\" _$$_func_embed$( Obj \u0026args ); # С/С++ прототип для второго (дополнительного) имени # extern \"C\" _$$_func_embed$_$(int64_t arg_long, uint8_t arg_byte = 10); # Тогда при раскрытии блока с расширенным синтаксисом # $func_embed заменяется на _$$_func_embed$_$, а компилятор С/С++ # будет в состоянии проверить её аргументы {% int64_t value = $func_embed(10, 20); %} Хотя может имеет смысл сделать inline шаблон для подобного вызова, а не создавать кополнительное имя?\n./object.h:732:25: error: deduced conflicting types ('int' vs 'const char *') for initializer list element type auto list = {args...}; ^~~~~ test/object_test.cpp:131:21: note: in instantiation of function template specialization 'newlang::Obj::operator()\u003cint, const char *\u003e' requested here str3 = (*format)(-1, \"222\"); ^ ","categories":"","description":"","excerpt":"Именование объектов основано на правилах и выбирается из расчёта …","ref":"/ru/docs/arch/mangling/","tags":"","title":"Внутреннее имя и манглинг имен"},{"body":"Основные материалы по языку программирования NewLang.\nОписание акутально для текущей версии 4.0\n","categories":"","description":"","excerpt":"Основные материалы по языку программирования NewLang.\nОписание …","ref":"/ru/docs/","tags":"","title":"Документация"},{"body":"Все математические операторы имеют парный аналог с присвоением значения:\n+ и += — сложение арифметических типов данных; - и -= — вычитание арифметических типов данных; / и /= — деление (результат число с плавающей точкой); // и //= — целочисленное деление с округлением к меньшему числу (как в Python); * и *= — умножение (он же используется и для повторения текстовых строк); % и %= — остаток от целочисленного деления; Отдельный оператор для возведения в степень отсуствует.\nОператоры двоичного сдвига *) пока не реализованы .\u003c. - Битовый сдвиг влево .\u003e. - Битовый сдвиг вправо .\u003e\u003e. - Битовый сдвиг вправо с заполнением знакового бита .\u0026. - Битовый оператор И .|. - Битовый оператор ИЛИ .^. - Битовый оператор ИСКЛЮЧАЮЩЕЕ ИЛИ .~. - Битовый унарный оператор НЕ (инверсии) ","categories":"","description":"","excerpt":"Все математические операторы имеют парный аналог с присвоением …","ref":"/docs/ops/math/","tags":"","title":"Математические операторы"},{"body":"Все математические операторы имеют парный аналог с присвоением значения:\n+ и += — сложение арифметических типов данных; - и -= — вычитание арифметических типов данных; / и /= — деление (результат число с плавающей точкой); // и //= — целочисленное деление с округлением к меньшему числу (как в Python); * и *= — умножение (он же используется и для повторения текстовых строк); % и %= — остаток от целочисленного деления; Отдельный оператор для возведения в степень отсуствует.\nОператоры двоичного сдвига *) пока не реализованы .\u003c. - Битовый сдвиг влево .\u003e. - Битовый сдвиг вправо .\u003e\u003e. - Битовый сдвиг вправо с заполнением знакового бита .\u0026. - Битовый оператор И .|. - Битовый оператор ИЛИ .^. - Битовый оператор ИСКЛЮЧАЮЩЕЕ ИЛИ .~. - Битовый унарный оператор НЕ (инверсии) ","categories":"","description":"","excerpt":"Все математические операторы имеют парный аналог с присвоением …","ref":"/ru/docs/ops/math/","tags":"","title":"Математические операторы"},{"body":"NewLang поддерживает пространства имен, разделителем в которых, как и в С++, выступает двойное двоеточие “::”.\nОбласть имен может быть указана как для отдельного индетификатора, так и для целого блока кода.\nВ отличии от namespace в С++, области имен в NewLnag используются не только для организации кода в виде логических групп и с целью избежания конфликтов имен, но и для отнесения идентификатора, в котором явно указана область имен, к статическим объектам (память под которые выделяется на этапе комиляции программы).\nГлобальное имя не может быть перекрыто макросом или локальной переменной при разрешении имен (name lookup). Создать глобальную (статическую) переменную в текущем пространстве имен можно указав переменную препроцессора @::.\nДля использования пространства имен в блоке кода, его нужно указать перед открывающейся фигурной скобкой. В таком именованном блоке кода завершающие “::” указывать не обязательно.\n::var ::= 0; # Имя глобальной переменной в явном виде (не может быть перекрыто) ns { # Можно указать равнозначное ns:: var ::= 0; # Имя ns::var (может быть перекрыто макросом или локальной переменной) @::var ::= 0; # Имя глобальной переменной ::ns::var (не может быть перекрыто) name:: { var = 0; # Обращение к переменной ns::var var2 ::= 0; # Имя переменной будет ns::name::var2 ::var = 1; # Переменная из глобального пространства имен }; :: { # Глобальное пространство имен var = 1; # Имя глобальной переменной ::var (может быть перекрыто) ::ns::var = 0; # Имя другой глобальной переменной (не может быть перекрыто) }; }; Пространство имен, модули и пакеты Пространство имен в NewLang поддерживает одновременно с модульной структурой кода как в языках Java и Python и при указании полного имени объекта, программные модули и пространства имен можно объединять.\nНапример, полное имя переменой можно записать с указанием программного модуля \\root\\dir\\module::ns::name::var, где root и dir это каталоги в файловой системе относительно текущего модуля, а module — имя файла, т.е. root/dir/module.nlp.\nПространство имен и ООП В NewLang не применяется декорирование (манглинг) имен, основанный на типах аргументов функций.\nТем не менее при создания уникальных идентификаторов для методов классов NewLang использует подход, похожий на применяемый в языке Python. При создании метода класса создается глобальная функция с именем класса и именем метода, объединенные через разделитель “::”.\nНапример, для класса :NewClass при создании метода method будет создана функция с именем NewClass::method.\nТакая схема наименований методов полностью соответствует именованию функций в пространстве имен, и тем самым позволяет определять методы класса вне тела самого класса, просто указав нужное имя в пространстве имен или в явном виде.\nПример создания метода класса NewClass в области имен:\nNewClass:: { method() := { }; } Пример создания метода класса NewClass с указанием полного имени:\nNewClass::method() := { }; ","categories":"","description":"","excerpt":"NewLang поддерживает пространства имен, разделителем в которых, как и …","ref":"/ru/docs/syntax/namespace/","tags":"","title":"Пространства имен"},{"body":"Символьные строки NewLang поддерживает два типа строк:\n:StrChar - универсальные байтовые UTF-8 строки :StrWide - системные символьные (широкие символы) Единичным элементом универсальной UTF-8 строки является один байт, тогда как у системных символьных строк единичным элементом строки является широкий символ wchar_t.\nИ хотя строки различаются типами единичного элемента строки, но внутреннее представление у обоих типов строк одинаковое. Все данные символьных строки хранятся в виде универсальной байтовой UTF-8 последовательности.\nБайтовые строки :StrChar Единичным элементом универсальной байтовой строки является один байт (точнее :Int8, т.е. 8-ми битное целое число со знаком). Количество символов байтовой строки возвращается в байтах и обращение к элементу строки по индексу происходит к байту символьной последовательности. Так как данные строки интерпретируется как последовательность UTF-8 символов, нужно соблюдать осторожность при изменении отдельных байт!\nСистемные строки :StrWide Единичным элементом системной строки является широкий символ wchar_t, а количество элементов системной символьной строки возвращается в широких символах. Размер типа wchar_t зависит от операционной системы, поэтому размер одного символа :StrWide в Windows будет 2 байта, а в Linux 4 байта, что связано с их особенностями реализации.\nОсновоне назначение системных строк - упрощение работы в текстовом терминале, так как один символ всегда соответствует одному знакоместу без необходимости постоянного конвертирования кодовых точек UTF-8.\nФорматирование строк К любой переменной можно обратиться как к функции (указав после её имени круглые скобки) для создания копии/клона объекта, а для строк, такую операцию можно использовать как шаблон при форматировании данных.\nФорматирование строк можно сделать двумая способами:\nЗадать строку формата с указанием типов выводимых данных (строка формата соотвествует форматированию в стандартной функции printf). Для применения такого варината форматирования у строки формата необходимо указать соответствующий тип данных (:FmtChar или :FmtWide для обычных и широких символов соответствено).\nПри таком способе форматирования, именнованные аргументы использовать нельзя, а компилятор проверяет типы передаваемых значений на соответствие строке формата только во время компиляции текста программы.\nДанный тип форматной строки можно использовать как последний аргумент функции для проверки типов всех последующих аргументов на соотвестие строки формата.\nВо всех остальных случаях в качестве строки формата можно использовать любые строки и именованные аргументы, а сам формат соотвествует строке формата из библиотеки {fmt}.\nЕдинствено отличие заключается в возможности указания не только порядкового номера аргумента, но и его имени.\nПроверка аргументов на соответствие строки формата производится во время клонирования строки как во время компиляции, так и во время выполняения программы.\nДанный способ форматирования используется по умолчанию для любых типов строк, но проверка строки формата не выполняется в аргументах функции.\nНапример:\n$fmt := '%s: %d':FmtChar; # Форматирование как в printf $result := $fmt('value', 123); # \"value: 123\" - Check compile time only! $template := \"{name} {0}\"; # fmt::format equivalent \"{1} {0}\" $result := $template(\"шаблон\", name = \"Строка\"); # result = \"Строка шаблон\" ","categories":"","description":"","excerpt":"Символьные строки NewLang поддерживает два типа строк:\n:StrChar - …","ref":"/ru/docs/types/strings/","tags":["типы данных","строки"],"title":"Символьные строки"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/blog/","tags":"","title":"Статьи"},{"body":" Select an exmaple... Hello, world! Rational numbers without limitation of precision Factorial 40 Factorial 40 with DSL syntax Tensor example Playground run 0% Playground version: Output: ","categories":"","description":"","excerpt":" Select an exmaple... Hello, world! Rational numbers without …","ref":"/playground/","tags":"","title":"Playground and example code"},{"body":" Select an exmaple... Hello, world! Rational numbers without limitation of precision Factorial 40 Factorial 40 with DSL syntax Tensor example Playground run 0% Playground version: Output: ","categories":"","description":"","excerpt":" Select an exmaple... Hello, world! Rational numbers without …","ref":"/ru/playground/","tags":"","title":"Playground and example code"},{"body":"В NewLang реализована концепция программных модулей и пакетов - которая повторяет идею иерархического расположения файлов в каталогах файловой системы, примерно так же, как это сделано в языке Python, но разделителем имен выступает не точка, а символ “\\” (как разделитель каталогов в Windows).\nИмя модуля может содержать только строчные английские буквы или цифры. Данное ограничение связано с прямым отображением имен модулей на объекты в файловой системе, так как у разных файловых систем могут быть различные возможности с поддержкой кодировок и разные требования к преобразованию регистров символов.\nПод модулем в NewLang понимается файл исходным кодом (с расширением *.src). Модули предназначены для того, чтобы в них хранить часто используемые функции, классы, константы и т.п. Их можно условно разделить на модули и программы: программы предназначены для непосредственного запуска, а модули для импортирования их в другие программы, но функционально модули и программы ничем между собой не отличаются.\nОбъекты модуля Все объекты, определенные внутри одного модуля без указания глобального простанства имен, видны только в рамках текущего файла.\nВремя жизни статической и локальной переменных модуля одинаковые, и ограничены временм жизни самого модуля, но статическая и локальная переменные модуля отличаются с точки зрения многопоточности.\nСтатическая переменная модуля всегда будет в единственном экземпляре для всех потоков, тогда как локальная переменная модуля будет для каждого потока своя (аналог thread_local (C++11)).\nКак импортировать модули? Относительное имя программного модуля начинается на символ “\\”, и в этом случае расположение файла программного модуля указывается относительно текущего файла.\nАбсолютное имя программного модуля начинается на два символа “\\\\” и указывает на файл модуля относительно каталога текущего исполняемого файла (или в списке каталогов для поиска программных модулей, который можно переопределить, например, с помощью аргументов командной строки).\nПолное имя текущего модуля (файла) содержится в переменной препроцессора ‘@\\\\’.\nСамый простой способ импортировать модуль, это записать его имя со скобками как при вызове функции. Причем в скобках можно передать аргументы для инициализации модуля, список импортируемых функций и т.д.\nТак как NewLang разрабатывается как компилируемый язык, то загрузка модулей возможна как статически, так и динамически (очень похоже на статическую и динамическую ликновку с dll библиотеками).\n\\dir\\module() - статическая загрузка модуля по относительному пути \\\\root\\dir\\module() - статическая загрузка модуля по абсолютному пути \\\\(\"каталог\\файл\") - динамическая загрузка модуля во время выполнения программы При динамической линковке, компиляция исходного кода модуля и все проверки будут выполнятся только во время выполнения приложения, тогда как статическая загрузка модуля позволяет выявить возможные ошибки еще на этапе компиляции программы.\nПо умолчанию, при статической линковке модуля, импортируются все его макросы, функции и переменные модуля, тогда как при динамической загрузке моуля, макросы не импортируются. ?????????????????????????????????????????????????????????????\nЧто такое пакет в NewLang? Пакет в NewLang – это имя каталога, который включает в себя другие каталоги и модули и при этом содержит дополнительный файл __init__.src.\nПакеты используются как дополнение к пространству имен, что позволяет работать с модулями через указание уровня вложенности (через символ \\). Но в отличии от Python и Java, где модули и пакеты заменяют собой пространство имен (namespace), в NewLang модульная структура и области имен используются одновременно и при указании полного имени объекта, программные модули и пространства имен можно объединять.\nНапример, полное имя переменой можно записать с указанием программного модуля \\root\\dir\\module::ns::name::var, где root и dir это каталоги в файловой системе относительно текущего моделя, а module — имя файла, т.е. root/dir/module.src\nДля импортирования пакетов используется тот же синтаксис, что и для работы с модулями.\nИспользование пакетов Рассмотрим следующую структуру пакета:\nfincalc |-- __init__.src |-- simper.src |-- compper.src |-- annuity.src Пакет fincalc содержит в себе модули для работы с простыми процентами (simper.src), сложными процентами (compper.src) и аннуитетами (annuity.src). Файл __init__.src в отличии от Python, не может быть пустым, а должен в явном виде содержать команды загрузки модулей, входящих в пакет\nНапример для нашего случая содержимое __init__.src может быть вот таким:\n\\simper(); \\compper(); \\annuity(); Для использования функции fp из модуля для работы с простыми процентами, можно использовать один из следующих вариантов (для сравнения приведен аналогичный код на Python, когда это возможно):\nИмпорт одного модуля без указания псевдонима: Python:\nimport fincalc.simper fv = fincalc.simper.fv(pv, i, n) NewLang:\n\\fincalc\\simper(); fv := \\fincalc\\simper::fv(pv, i, n); С указанием псевдонима имени модуля: Python:\nimport fincalc.simper as sp fv = sp.fv(pv, i, n) NewLang:\nsp := \\fincalc\\simper(); fv := sp.fv(pv, i, n); Импорт одной конкретной функции: Python:\nfrom fincalc import fv result = fv(pv, i, n) NewLang:\n\\fincalc\\simper(__import__=\"fv\"); result := fv(pv, i, n); Импорт всего пакета: NewLang:\n\\fincalc(); result := fv(pv, i, n); ","categories":"","description":"","excerpt":"В NewLang реализована концепция программных модулей и пакетов - …","ref":"/docs/syntax/modules/","tags":"","title":"Модули и пакеты"},{"body":"В NewLang реализована концепция программных модулей и пакетов - которая повторяет идею иерархического расположения файлов в каталогах файловой системы, примерно так же, как это сделано в языке Python, но разделителем имен выступает не точка, а символ “\\” (как разделитель каталогов в Windows).\nИмя модуля может содержать только строчные английские буквы или цифры. Данное ограничение связано с прямым отображением имен модулей на объекты в файловой системе, так как у разных файловых систем могут быть различные возможности с поддержкой кодировок и разные требования к преобразованию регистров символов.\nПод модулем в NewLang понимается файл исходным кодом (с расширением *.src). Модули предназначены для того, чтобы в них хранить часто используемые функции, классы, константы и т.п. Их можно условно разделить на модули и программы: программы предназначены для непосредственного запуска, а модули для импортирования их в другие программы, но функционально модули и программы ничем между собой не отличаются.\nОбъекты модуля Все объекты, определенные внутри одного модуля без указания глобального простанства имен, видны только в рамках текущего файла.\nВремя жизни статической и локальной переменных модуля одинаковые, и ограничены временм жизни самого модуля, но статическая и локальная переменные модуля отличаются с точки зрения многопоточности.\nСтатическая переменная модуля всегда будет в единственном экземпляре для всех потоков, тогда как локальная переменная модуля будет для каждого потока своя (аналог thread_local (C++11)).\nКак импортировать модули? Относительное имя программного модуля начинается на символ “\\”, и в этом случае расположение файла программного модуля указывается относительно текущего файла.\nАбсолютное имя программного модуля начинается на два символа “\\\\” и указывает на файл модуля относительно каталога текущего исполняемого файла (или в списке каталогов для поиска программных модулей, который можно переопределить, например, с помощью аргументов командной строки).\nПолное имя текущего модуля (файла) содержится в переменной препроцессора ‘@\\\\’.\nСамый простой способ импортировать модуль, это записать его имя со скобками как при вызове функции. Причем в скобках можно передать аргументы для инициализации модуля, список импортируемых функций и т.д.\nТак как NewLang разрабатывается как компилируемый язык, то загрузка модулей возможна как статически, так и динамически (очень похоже на статическую и динамическую ликновку с dll библиотеками).\n\\dir\\module() - статическая загрузка модуля по относительному пути \\\\root\\dir\\module() - статическая загрузка модуля по абсолютному пути \\\\(\"каталог\\файл\") - динамическая загрузка модуля во время выполнения программы При динамической линковке, компиляция исходного кода модуля и все проверки будут выполнятся только во время выполнения приложения, тогда как статическая загрузка модуля позволяет выявить возможные ошибки еще на этапе компиляции программы.\nПо умолчанию, при статической линковке модуля, импортируются все его макросы, функции и переменные модуля, тогда как при динамической загрузке моуля, макросы не импортируются. ?????????????????????????????????????????????????????????????\nЧто такое пакет в NewLang? Пакет в NewLang – это имя каталога, который включает в себя другие каталоги и модули и при этом содержит дополнительный файл __init__.src.\nПакеты используются как дополнение к пространству имен, что позволяет работать с модулями через указание уровня вложенности (через символ \\). Но в отличии от Python и Java, где модули и пакеты заменяют собой пространство имен (namespace), в NewLang модульная структура и области имен используются одновременно и при указании полного имени объекта, программные модули и пространства имен можно объединять.\nНапример, полное имя переменой можно записать с указанием программного модуля \\root\\dir\\module::ns::name::var, где root и dir это каталоги в файловой системе относительно текущего моделя, а module — имя файла, т.е. root/dir/module.src\nДля импортирования пакетов используется тот же синтаксис, что и для работы с модулями.\nИспользование пакетов Рассмотрим следующую структуру пакета:\nfincalc |-- __init__.src |-- simper.src |-- compper.src |-- annuity.src Пакет fincalc содержит в себе модули для работы с простыми процентами (simper.src), сложными процентами (compper.src) и аннуитетами (annuity.src). Файл __init__.src в отличии от Python, не может быть пустым, а должен в явном виде содержать команды загрузки модулей, входящих в пакет\nНапример для нашего случая содержимое __init__.src может быть вот таким:\n\\simper(); \\compper(); \\annuity(); Для использования функции fp из модуля для работы с простыми процентами, можно использовать один из следующих вариантов (для сравнения приведен аналогичный код на Python, когда это возможно):\nИмпорт одного модуля без указания псевдонима: Python:\nimport fincalc.simper fv = fincalc.simper.fv(pv, i, n) NewLang:\n\\fincalc\\simper(); fv := \\fincalc\\simper::fv(pv, i, n); С указанием псевдонима имени модуля: Python:\nimport fincalc.simper as sp fv = sp.fv(pv, i, n) NewLang:\nsp := \\fincalc\\simper(); fv := sp.fv(pv, i, n); Импорт одной конкретной функции: Python:\nfrom fincalc import fv result = fv(pv, i, n) NewLang:\n\\fincalc\\simper(__import__=\"fv\"); result := fv(pv, i, n); Импорт всего пакета: NewLang:\n\\fincalc(); result := fv(pv, i, n); ","categories":"","description":"","excerpt":"В NewLang реализована концепция программных модулей и пакетов - …","ref":"/ru/docs/syntax/modules/","tags":"","title":"Модули и пакеты"},{"body":"Арифметическое сравнение Операторы арифметического сравнения представленными классическими \u003c, \u003e, \u003c=, \u003e=, == и !=. Они использются для сравнения между собой скаляров и рациональных чисел, а операторы сранвения на равенство == и !=, позвоялют сравнивать между собой в том числе и матрицы.\nОператоры сравнения == и != — операторы сравнения с автоматическим приведением совместимых типов для любых объектов\n== и != — операторы сравнения с автоматическим приведением совместимых типов для любых объектов\n=== и !== — операторы точного сравнения для любых объектов (автоматического приведения типов не выполняется). Для объектов сравниваются адреса размещения\nСтрогая статическая (номинальная) типизация Строгая статическая номинальная проверка типа объектов во время любых операций производится автоматически во время компиляции исходного текста программы, если хотя бы у одной из переменных при опеределении был указан её тип в явном виде.\nРезультат статической номинальной проверки типов будет успешным, если тип правого объекта может быть автоматически преобразован к типу левого операнда или тип правого операнада присутствует у левого в иерархии наследования.\nДинамическая номинальная типизация Для проверки имени типа (класса) объекта во время выполнения используется оператор тильда “~”. Это таже номинальная проверка типов, но только во время выполнения приложения. Левым операндом должен быть проверяемый объект, а правым — тип с которым сравнивается левый оператор.\nПравый оператор может быть строкой литералом, переменной строкового типа или именем проверяемого класса непосредственно. Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта или он присутствует у него в иерархии наследования.\nname := \"class\"; # Строковая переменная с именем класса var ~ name; var ~ :class; # Сравнение с типом var ~ \"class\"; # Имя типа как строка литерал Динамическая утиная типизация Оператор утиной типизации, два символа тильды “~~”. Проверяемым типом является левый оператор, а правый выступает в роли облазца для сравнения. Для простых типов сравнивается совместимость типа левого операнда по отношению к правому. А для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда, т.е.:\n# Истина (т. е. левый операнд словарь) (field1=\"value\", field2=2,) ~~ (); # Тоже истина (т. к. поле field1 присутствует у левого операнда) (field1=\"value\", field2=2,) ~~ (field1=_); # Ложь, т.к. поле not_found у левого операнда отсутствует (field1=\"value\", field2=2,) ~~ (not_found=_); Строгая утиная типизация Строгая утиная типизация “~~~” для простых типов сравнивается идентичности типов без учета совместимости, а для составных типов происходит сравнение всех свойств с помощью оператора строгого равенства.\nДля данной операции, пустой тип совместим только с другим пустим типом.\n","categories":"","description":"","excerpt":"Арифметическое сравнение Операторы арифметического сравнения …","ref":"/docs/ops/compare/","tags":"","title":"Операторы сравнения и типизация"},{"body":"Арифметическое сравнение Операторы арифметического сравнения представленными классическими \u003c, \u003e, \u003c=, \u003e=, == и !=. Они использются для сравнения между собой скаляров и рациональных чисел, а операторы сранвения на равенство == и !=, позвоялют сравнивать между собой в том числе и матрицы.\nОператоры сравнения == и != — операторы сравнения с автоматическим приведением совместимых типов для любых объектов\n== и != — операторы сравнения с автоматическим приведением совместимых типов для любых объектов\n=== и !== — операторы точного сравнения для любых объектов (автоматического приведения типов не выполняется). Для объектов сравниваются адреса размещения\nСтрогая статическая (номинальная) типизация Строгая статическая номинальная проверка типа объектов во время любых операций производится автоматически во время компиляции исходного текста программы, если хотя бы у одной из переменных при опеределении был указан её тип в явном виде.\nРезультат статической номинальной проверки типов будет успешным, если тип правого объекта может быть автоматически преобразован к типу левого операнда или тип правого операнада присутствует у левого в иерархии наследования.\nДинамическая номинальная типизация Для проверки имени типа (класса) объекта во время выполнения используется оператор тильда “~”. Это таже номинальная проверка типов, но только во время выполнения приложения. Левым операндом должен быть проверяемый объект, а правым — тип с которым сравнивается левый оператор.\nПравый оператор может быть строкой литералом, переменной строкового типа или именем проверяемого класса непосредственно. Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта или он присутствует у него в иерархии наследования.\nname := \"class\"; # Строковая переменная с именем класса var ~ name; var ~ :class; # Сравнение с типом var ~ \"class\"; # Имя типа как строка литерал Динамическая утиная типизация Оператор утиной типизации, два символа тильды “~~”. Проверяемым типом является левый оператор, а правый выступает в роли облазца для сравнения. Для простых типов сравнивается совместимость типа левого операнда по отношению к правому. А для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда, т.е.:\n# Истина (т. е. левый операнд словарь) (field1=\"value\", field2=2,) ~~ (); # Тоже истина (т. к. поле field1 присутствует у левого операнда) (field1=\"value\", field2=2,) ~~ (field1=_); # Ложь, т.к. поле not_found у левого операнда отсутствует (field1=\"value\", field2=2,) ~~ (not_found=_); Строгая утиная типизация Строгая утиная типизация “~~~” для простых типов сравнивается идентичности типов без учета совместимости, а для составных типов происходит сравнение всех свойств с помощью оператора строгого равенства.\nДля данной операции, пустой тип совместим только с другим пустим типом.\n","categories":"","description":"","excerpt":"Арифметическое сравнение Операторы арифметического сравнения …","ref":"/ru/docs/ops/compare/","tags":"","title":"Операторы сравнения и типизация"},{"body":"Для обработки перываний потока выполения, а также для обработки ошибкок компилятора используются С++ классы - наследники от std::exception, которые возвращают объект ошибки (значение).\nОшибка компилятора возвращает не только тестовое описание, но и объект TermPtr, при обработке которого возникла ошибка, тогда как перывание потока выполения возвращается объект ObjPtr.\nstd::exception -+-\u003e :ParserError | (TermPtr) | +-\u003e :RuntimeError ----\u003e :IntAny --+-\u003e :IntPlus (ObjPtr) | | +-\u003e :IntMinus При выполнении (генерации кода) именованные прерывания могут быть реализованы без использования исключений!\n","categories":"","description":"","excerpt":"Для обработки перываний потока выполения, а также для обработки …","ref":"/docs/arch/errors/","tags":"","title":"Реализация обработки ошибок и прерываний"},{"body":"Чтобы не усложнять обработку ошибок и не разделять их на внутренние и внешние, реализовано всего два класса для сообщения об ошибоках, накопительные и непосредственные + возврат значений.\nНакопительные ошибки и их реализация Накопительные ошибки используются при обработке исходного текста программы при его парсинге, анализа или компиляции. Накопительнность данных ошибок заключается в том, что процесс обработки исходного текста прерывается не сразу после возникновения первой ошибки, а только после превышения определнного лимита (по умолчанию –nlc-error-limit=10).\nДля логирования места возникновения ошибки используется макрос LOG_ERROR и при необходиости инкремент количества ошибок, или без оного (LOG_WARNING, LOG_INFO, LOG_DEBUG, LOG_DUMP) и обязательной пометкой термина TermPtr как причины её возникновения.\nПосле превышения лимита накопительных ошибок или при их наличии и завершении исходного текста программы, генерируется обычное исключение std::exception с описанием причины (последней ошибки).\nНепосредственные ошибки и их реализация Непосредственные ошибки применяются при выполнении (интерпретции) тела программы и предназнчены для информирования пользователя о возникновении ошибки прерывания работы программы. Так как контекст (текущий термин или строка в исходном файла) как правило не доступны, то сразу генерируется обычное исключение std::exception с описанием причины возникновения, а идентификация места её возникновения с конкретным исходным местом в тексте программы возлагается на обработчик прерываний.\nВозврат знечений Для обработки перываний потока выполения, используются отдельные С++ классы, которые не являются наследниками std::exception, чтобы специально разделить код обработки возврата значений от обработки ошибок, а при выполнении (генерации кода) именованные прерывания могут быть реализованы вообще без использования исключений (return, break, continue или goto)!\n:IntAny --+-\u003e :IntPlus (ObjPtr) | | +-\u003e :IntMinus ","categories":"","description":"","excerpt":"Чтобы не усложнять обработку ошибок и не разделять их на внутренние и …","ref":"/ru/docs/arch/errors/","tags":"","title":"Реализация прерываний и обработки ошибок"},{"body":"Объектно ориентированное программирование NewLang поддерживает следующую концепцию объектно-ориентированного программирования:\nКаждый объект представляет собой отдельный тип данных, который наследуется от другого типа или от одного из его наследников (что очень похоже на концепцию объектов в языке Java), а экземпляр конкретного класса создается путем вызова его типа.\nНаследование поддерживается для типов словарь (:Dictionary) и класс (:Class) и всех их потомков.\nСловарь Словарь (:Dictionary) — набор данных произвольного типа с доступом к отдельным элементам по целочисленному индексу или по имени элемента при его наличии (это похоже и на tuple и на структуру одновременно). Словари отличаются от тензоров тем, что всегда имеют только одно измерение, но каждый элемент может содержать произвольное количество элементов любого типа, в том числе и другие словари.\nДоступ к элементам словаря происходит по имени элемента, которое записывается через точку от имени переменной, либо по целочисленному индексу. Индекс начинается с 0 и как у тензоров, тоже может быть отрицательным (индекс элемента от “конца”).\n# Новый тип (класс) :NewClass :Dict := :Dictionary() { _ := 1; # У поля данных имя отсутствует two := 2; name := 3; }; dict := :Dict(); # Экземпляр класса (1, two=2, name=3,):Dict dict2 := :Dict(two=42); # Экземпляр класса (1, two=42, name=100,):Dict dict3 := dict2(99, name=0); # Копия объекта dict2 (99, two=42, name=0,):Dict В будущем можно будет добавить возможность указывать индексы элементов словаря с помощь диапазонов\n$dict = :Dict[10](first=1, 4..4 = 29, 2..3 = 15, , 2..3 = 15, 7..9..2 = 7); #(first=1, 0, 15, 15, 29, 0, 0, 7, 0, 7,) Словарь как литерал Литерал с типом «словарь» в тексте программы записывается в круглых скобках с обязательной завершающей запятой, т. е. (,) — пустой словарь, (1, 2= «2», name=3,). Для указания конкретного типа объекта у литерала, его необходимо указать после закрывающей скобки, т.е. (1, two= «2», name=3,):Dict.\nВажный момент! Хоть такой объект и будет иметь указанный тип, но он будет “неполноценным” и содержать только те данные, которые были явно указаны в скобках, что не гарантирует корректного создания реального объекта, т.к. для создания “правильного” объекта требуется вызвать его тип, т.е. :Dict();\nТакой способ создания литералов классов используется в основном в различных операциях сравнения типов и “утиной типизации”, т.к. не требует доступа к рантайму, да и сам класс может быть не определен.\nПеречисление, структура и объединение Существуют три отдельных типа данных, :Enum, :Struct и :Union — которые так же являются словарями, но на их элементы накладываются определённые ограничения. Каждый элемент должен иметь уникальное имя, а его тип данных должен быть простым, т.е. числом или строкой фиксированного размера. Эти типы данных одновременно относятся к группе нативных типов и могут быть представлены в двоичном виде в одной области машинной памяти.\n","categories":"","description":"","excerpt":"Объектно ориентированное программирование NewLang поддерживает …","ref":"/docs/types/dicts/","tags":["типы данных","ООП","коллекции"],"title":"Словари"},{"body":"Объектно ориентированное программирование NewLang поддерживает следующую концепцию объектно-ориентированного программирования:\nКаждый объект представляет собой отдельный тип данных, который наследуется от другого типа или от одного из его наследников (что очень похоже на концепцию объектов в языке Java), а экземпляр конкретного класса создается путем вызова его типа.\nНаследование поддерживается для типов словарь (:Dictionary) и класс (:Class) и всех их потомков.\nСловарь Словарь (:Dictionary) — набор данных произвольного типа с доступом к отдельным элементам по целочисленному индексу или по имени элемента при его наличии (это похоже и на tuple и на структуру одновременно). Словари отличаются от тензоров тем, что всегда имеют только одно измерение, но каждый элемент может содержать произвольное количество элементов любого типа, в том числе и другие словари.\nДоступ к элементам словаря происходит по имени элемента, которое записывается через точку от имени переменной, либо по целочисленному индексу. Индекс начинается с 0 и как у тензоров, тоже может быть отрицательным (индекс элемента от “конца”).\n# Новый тип (класс) :NewClass :Dict := :Dictionary() { _ := 1; # У поля данных имя отсутствует two := 2; name := 3; }; dict := :Dict(); # Экземпляр класса (1, two=2, name=3,):Dict dict2 := :Dict(two=42); # Экземпляр класса (1, two=42, name=100,):Dict dict3 := dict2(99, name=0); # Копия объекта dict2 (99, two=42, name=0,):Dict В будущем можно будет добавить возможность указывать индексы элементов словаря с помощь диапазонов\n$dict = :Dict[10](first=1, 4..4 = 29, 2..3 = 15, , 2..3 = 15, 7..9..2 = 7); #(first=1, 0, 15, 15, 29, 0, 0, 7, 0, 7,) Словарь как литерал Литерал с типом «словарь» в тексте программы записывается в круглых скобках с обязательной завершающей запятой, т. е. (,) — пустой словарь, (1, 2= «2», name=3,). Для указания конкретного типа объекта у литерала, его необходимо указать после закрывающей скобки, т.е. (1, two= «2», name=3,):Dict.\nВажный момент! Хоть такой объект и будет иметь указанный тип, но он будет “неполноценным” и содержать только те данные, которые были явно указаны в скобках, что не гарантирует корректного создания реального объекта, т.к. для создания “правильного” объекта требуется вызвать его тип, т.е. :Dict();\nТакой способ создания литералов классов используется в основном в различных операциях сравнения типов и “утиной типизации”, т.к. не требует доступа к рантайму, да и сам класс может быть не определен.\nПеречисление, структура и объединение Существуют три отдельных типа данных, :Enum, :Struct и :Union — которые так же являются словарями, но на их элементы накладываются определённые ограничения. Каждый элемент должен иметь уникальное имя, а его тип данных должен быть простым, т.е. числом или строкой фиксированного размера. Эти типы данных одновременно относятся к группе нативных типов и могут быть представлены в двоичном виде в одной области машинной памяти.\n","categories":"","description":"","excerpt":"Объектно ориентированное программирование NewLang поддерживает …","ref":"/ru/docs/types/dicts/","tags":["типы данных","ООП","коллекции"],"title":"Словари"},{"body":" Ответ прост: классы не строго необходимы для ООП. Знаю, это может шокировать.\nРазумеется, нам нужна возможность создания новых объектов, и языки на основе классов, очевидно, распространены сильнее. Однако это не единственный способ достижения цели.\nВ языках наподобие JavaScript (хотя ES6 добавил в язык классы6, 7) и Lua используется концепция ООП на основе прототипов или прототипного ООП. Вместо создания схемы для конструирования новых объектов мы используем существующий объект в качестве прототипа. Такой подход даже может иметь реальные преимущества, поскольку снижает сложность языка8.\nТип данных :Class аналогичен словарю, но все его поля обязаны иметь имена (хотя доступ к свойствам класса по индексу так же возможен). При создании экземпляра класса, создается новая переменная, для которой копируются свойства и методы всех родителей.\nСоздание нового сложного типа (класса), происходит согласно правилам синтаксиса как создание функции в пользовательском пространстве имен. Имя функции является именем нового класса, а сама функция будет выступает в роли конструктора экземпляров класса.\nСинтаксис создание класса выглядит следующим образом:\n# Новый тип (класс) :NewClass ns::NewClass() := :Class() { # Родительские класс или несколько классов через запятую # Конструктор класса - весь блок кода с определением полей и методов @::static := 1; # Поле класса (у всех объектов одно значение) static := 1; # Поле класса (у всех объектов одно значение) .field := 1; # Поле объекта func() := {}; # Метод класса всегда статический #.method() := {}; # Метод объекта (у каждого объекта свой) ~NewClass() ::= { # Деструктор класса }; }; obj := ns::NewClass(); # Экземпляр класса Так как NewLang реализует полный набор вариантов проверок при создании объектов, то переопределения наследуемых функций не требует никаких ключевых слов:\nNewClass2() := NewClass() { # Новый класс на базе существующего .field ::= 2; # Будет ошибка, т.к. поле field уже есть в базовом классе method() = {}; # Аналог override, т.к. method должен существовать в базовом классе }; Интерфейсы, именование методов классов и пространства имен Для создания уникальных идентификаторов на основе имен методов классов, NewLang использует подход, похожий на применяемый в языке Python. При создании метода класса, создается глобальная функция с именем класса и именем метода, объединенные через разделитель области имен. Например, в классе NewClass2 при создании метода method будет создана функция с именем ::NewClass2::method.\nТакая схема наименований методов полностью соответствует именованию функций в пространствах имен, и тем самым позволяет определять классы c чистыми виртуальными функциями (методами без реализации), а в последствии определять их в пространстве имен или указав полное имя в явном виде.\nns:: { NewClass3 := NewClass() { # Новый класс на базе существующего virtual() := _; # Виртуальный метод }; }; obj := ns::NewClass3(); # объект создать нельзя, будет ошибка # Определить функцию для виртуального метода ns::NewClass3::virtual() := {}; obj := ns::NewClass3(); # ОК Конструкторы, деструкторы и финализаторы у объектов ns::NewClass() := Class() { # Новый класс на базе существующего # Блок кода функции - конструктор объекта __NewClass__() = {...}; # Метод с системным именем типа - деструктор объекта (вызывается сразу после удаления) _NewClass() := {...}; # Скрытый метод с именем типа - защищенный конструктор объекта ????????????????? __NewClass() := {...}; # Скрытый метод с именем типа - приватный конструктор объекта ????????????????? :NewClass(type) ::= {...}:NewClass; # Функция для приведения типа объекта $type к типу :NewClass ~NewClass() = {...}; # Скрытый метод - финализатор (вызывается перед освобождением памяти) __equals__(obj):Bool = { __compare__($obj) == 0 }; __compare__(obj):Int8 = { :: __compare__(@this, $obj) }; _() := {...}; # ????????????????????????????????????? }; extension methods !\nПишу на С++ последние лет 20, до этого ещё Delphi лет 10. С годами полностью отошёл от ООП в сторону data-driven design. Классы — практически структуры, из методов как правило только декоративные геттеры. Всё остальное — это просто функции с понятными названиями, сигнатурами и операндами-объектами таких вот классов-носителей данных и состояния. Получается, очень легко дышится и чистенько — состояния изолированы в структуры, логика изолирована в функции. Конечно, в C++ всё довольно печально с ООП как таковым, поскольку нет механизма extension methods — это когда вы собираете методы в класс из разных единиц трансляции из-за этого, обычные функции C++ значительно удобнее методов класса\nОсновная мысль, которая почти всегда теряется при обсуждении ООП, это то, зачем он нужен и в чем его суть. Все сводится к инструментам, их правильном и неправильном использовании, практичных архитектурах и оверинженеринге.\nМне кажется самая главная мысль очень проста. Сложная программа это сложное состояние. Проблема в том, что сложно следить за всей возможной суперпозицией всех деталей состояния. Небольшое состояние гораздо проще валидировать и постоянно поддерживать целостным. Если ты собираешь сложное состояние из простых целостных состояний, то его тоже проще поддерживать целостным (потому что нужно следить только за высокоуровневым состоянием, но не за всеми деталями)\nСоответственно ООП - это способ описания программы как набора иерархии изолированных состояний, где операции по изменению состояний максимально приближены к состоянию.\nТочно так же как сложную функцию можно представить как последовательность простых, так и сложное состояние можно представить комбинацией простых состояний. Изоляция и контроль состояний и есть основная идея ООП.\nФП подходит с другой стороны - максимально старается избежать состояния и работать только с текущим контекстом. Подход не лишен логики, но любая программа - это прежде всего состояние.\nВсе остальное - лишь инструменты и особенности реализации. ООП может быть реализовано почти на любом языке самыми разными инструментами и не обязательно требует интерфейсов, классов, сообщений, инкапсуляции и т.д. Но разумеется современные ООП языки хорошо адаптированы для такого способа описания. В конечном итоге если подсказки или области видимости действительно не дают тебе менять состояние объекта - это и есть прямая польза на этапе понимания и доработки твоего кода. Тебе просто не нужно думать и знать о состоянии объекта, когда ты с ним не работаешь.\nГлавное в ООП - это то, что есть данные, и есть методы которые напрямую работают с этими данными. Это то, что можно засунуть в один объект. Другой объект, который хочет получить данные из первого объекта, обязан пользоваться публичными методами.\nЭто упрощает поддержку обратной совместимости, упрощает изоляцию объектов, упрощает версионирование в случае многократного использования одними объектами других объектов.\nИ опять таки, суть не в том, что это чем-то напоминает рест-апи или библиотеки, а в том, что это парадигма программирования, которая упрощает организацию разработки сложных проектов, в которых задействовано много разработчиков.\nВсе остальные штуки - наследование, интерфейсы и все другое - это не суть ООП, а различные варианты решения или оптимизации различных кейсов\n","categories":"","description":"","excerpt":" Ответ прост: классы не строго необходимы для ООП. Знаю, это может …","ref":"/docs/types/class/","tags":["типы данных","ООП","коллекции"],"title":"Классы"},{"body":" Ответ прост: классы не строго необходимы для ООП. Знаю, это может шокировать.\nРазумеется, нам нужна возможность создания новых объектов, и языки на основе классов, очевидно, распространены сильнее. Однако это не единственный способ достижения цели.\nВ языках наподобие JavaScript (хотя ES6 добавил в язык классы6, 7) и Lua используется концепция ООП на основе прототипов или прототипного ООП. Вместо создания схемы для конструирования новых объектов мы используем существующий объект в качестве прототипа. Такой подход даже может иметь реальные преимущества, поскольку снижает сложность языка8.\nТип данных :Class аналогичен словарю, но все его поля обязаны иметь имена (хотя доступ к свойствам класса по индексу так же возможен). При создании экземпляра класса, создается новая переменная, для которой копируются свойства и методы всех родителей.\nСоздание нового сложного типа (класса), происходит согласно правилам синтаксиса как создание функции в пользовательском пространстве имен. Имя функции является именем нового класса, а сама функция будет выступает в роли конструктора экземпляров класса.\nСинтаксис создание класса выглядит следующим образом:\n# Новый тип (класс) :NewClass ns::NewClass() := :Class() { # Родительские класс или несколько классов через запятую # Конструктор класса - весь блок кода с определением полей и методов @::static := 1; # Поле класса (у всех объектов одно значение) static := 1; # Поле класса (у всех объектов одно значение) .field := 1; # Поле объекта func() := {}; # Метод класса всегда статический #.method() := {}; # Метод объекта (у каждого объекта свой) ~NewClass() ::= { # Деструктор класса }; }; obj := ns::NewClass(); # Экземпляр класса Так как NewLang реализует полный набор вариантов проверок при создании объектов, то переопределения наследуемых функций не требует никаких ключевых слов:\nNewClass2() := NewClass() { # Новый класс на базе существующего .field ::= 2; # Будет ошибка, т.к. поле field уже есть в базовом классе method() = {}; # Аналог override, т.к. method должен существовать в базовом классе }; Интерфейсы, именование методов классов и пространства имен Для создания уникальных идентификаторов на основе имен методов классов, NewLang использует подход, похожий на применяемый в языке Python. При создании метода класса, создается глобальная функция с именем класса и именем метода, объединенные через разделитель области имен. Например, в классе NewClass2 при создании метода method будет создана функция с именем ::NewClass2::method.\nТакая схема наименований методов полностью соответствует именованию функций в пространствах имен, и тем самым позволяет определять классы c чистыми виртуальными функциями (методами без реализации), а в последствии определять их в пространстве имен или указав полное имя в явном виде.\nns:: { NewClass3 := NewClass() { # Новый класс на базе существующего virtual() := _; # Виртуальный метод }; }; obj := ns::NewClass3(); # объект создать нельзя, будет ошибка # Определить функцию для виртуального метода ns::NewClass3::virtual() := {}; obj := ns::NewClass3(); # ОК Конструкторы, деструкторы и финализаторы у объектов ns::NewClass() := Class() { # Новый класс на базе существующего # Блок кода функции - конструктор объекта __NewClass__() = {...}; # Метод с системным именем типа - деструктор объекта (вызывается сразу после удаления) _NewClass() := {...}; # Скрытый метод с именем типа - защищенный конструктор объекта ????????????????? __NewClass() := {...}; # Скрытый метод с именем типа - приватный конструктор объекта ????????????????? :NewClass(type) ::= {...}:NewClass; # Функция для приведения типа объекта $type к типу :NewClass ~NewClass() = {...}; # Скрытый метод - финализатор (вызывается перед освобождением памяти) __equals__(obj):Bool = { __compare__($obj) == 0 }; __compare__(obj):Int8 = { :: __compare__(@this, $obj) }; _() := {...}; # ????????????????????????????????????? }; extension methods !\nПишу на С++ последние лет 20, до этого ещё Delphi лет 10. С годами полностью отошёл от ООП в сторону data-driven design. Классы — практически структуры, из методов как правило только декоративные геттеры. Всё остальное — это просто функции с понятными названиями, сигнатурами и операндами-объектами таких вот классов-носителей данных и состояния. Получается, очень легко дышится и чистенько — состояния изолированы в структуры, логика изолирована в функции. Конечно, в C++ всё довольно печально с ООП как таковым, поскольку нет механизма extension methods — это когда вы собираете методы в класс из разных единиц трансляции из-за этого, обычные функции C++ значительно удобнее методов класса\nОсновная мысль, которая почти всегда теряется при обсуждении ООП, это то, зачем он нужен и в чем его суть. Все сводится к инструментам, их правильном и неправильном использовании, практичных архитектурах и оверинженеринге.\nМне кажется самая главная мысль очень проста. Сложная программа это сложное состояние. Проблема в том, что сложно следить за всей возможной суперпозицией всех деталей состояния. Небольшое состояние гораздо проще валидировать и постоянно поддерживать целостным. Если ты собираешь сложное состояние из простых целостных состояний, то его тоже проще поддерживать целостным (потому что нужно следить только за высокоуровневым состоянием, но не за всеми деталями)\nСоответственно ООП - это способ описания программы как набора иерархии изолированных состояний, где операции по изменению состояний максимально приближены к состоянию.\nТочно так же как сложную функцию можно представить как последовательность простых, так и сложное состояние можно представить комбинацией простых состояний. Изоляция и контроль состояний и есть основная идея ООП.\nФП подходит с другой стороны - максимально старается избежать состояния и работать только с текущим контекстом. Подход не лишен логики, но любая программа - это прежде всего состояние.\nВсе остальное - лишь инструменты и особенности реализации. ООП может быть реализовано почти на любом языке самыми разными инструментами и не обязательно требует интерфейсов, классов, сообщений, инкапсуляции и т.д. Но разумеется современные ООП языки хорошо адаптированы для такого способа описания. В конечном итоге если подсказки или области видимости действительно не дают тебе менять состояние объекта - это и есть прямая польза на этапе понимания и доработки твоего кода. Тебе просто не нужно думать и знать о состоянии объекта, когда ты с ним не работаешь.\nГлавное в ООП - это то, что есть данные, и есть методы которые напрямую работают с этими данными. Это то, что можно засунуть в один объект. Другой объект, который хочет получить данные из первого объекта, обязан пользоваться публичными методами.\nЭто упрощает поддержку обратной совместимости, упрощает изоляцию объектов, упрощает версионирование в случае многократного использования одними объектами других объектов.\nИ опять таки, суть не в том, что это чем-то напоминает рест-апи или библиотеки, а в том, что это парадигма программирования, которая упрощает организацию разработки сложных проектов, в которых задействовано много разработчиков.\nВсе остальные штуки - наследование, интерфейсы и все другое - это не суть ООП, а различные варианты решения или оптимизации различных кейсов\n","categories":"","description":"","excerpt":" Ответ прост: классы не строго необходимы для ООП. Знаю, это может …","ref":"/ru/docs/types/class/","tags":["типы данных","ООП","коллекции"],"title":"Классы"},{"body":"https://habr.com/companies/otus/articles/763810/ https://habr.com/articles/764420/\nПоследовательная согласованность отсутствует (отсутствуют атомарныти типы) Любой язык программирования так или иначе вынужден управлять оперативной памятью. В NewLang реализовано автоматическое управление памятью без сборщика мусора.\nЗа основу была взята модель “владения” из языка Rust, но она переработана под концепцию сильных и слабых указателей (аналоги shared_ptr и weak_ptr из С++), где каждое значение в памяти может иметь только одну переменную-владельца с сильным указателем.\nИ когда такая переменная-владелец уходит из области видимости, счетчик ссылок уменьшается и при достжении нуля память освобождается.\nФактически, это автоматическое управление памятью с помощью подсчёта ссылок на этапе компиляции и без использования сборщика мусора.\nСуществование ссылок на объекты предполагает и возможность одновременного доступа к данным из нескольких потоков выполнения. Из-за чего управление памятью включает в себя и элементы межпотокового взаимодействия, так как совместное владение ссылками по любому будет требовать каких либо механизмов синхронизации доступа к разеделяемой памяти объектов.\nПоэтому, при определении объекта указывается, какие типы ссылок допускается создавать на него, а так-же какая используется модель совместного доступа к переменной.\nВесь механизм подсчета ссылок и проверки их корректности реализован на уровне синтаксиса. В рантайме выполняется только контроль идентификатора потока для однопоточных ссылок, а все остальные проверки выполняются во время компиляции.\nУправление памятью и терминология Врчную выделить или освобондить память нельзя\nЛюбой объект - это ссылка на область памяти с данным. Память выделяется и освобожадется автоматически при создании/удалении объектов\nСсылки на объекты, с точки зрения владения, могут быть:\nСильные/Владеющие ссылки (аналог shared_ptr из С++), а фактические, это переменная которая хранит значение объекта. Слабые/Не владеющие ссылки (аналог weak_ptr из С++) - указатели на другим объекты которые перед использованием требуют обязательного захвата (т.е. преобразования в сильную ссылку). Ссылки на объекты, с точки зрения совместного доступа, могут быть:\nЛегкие - ссылки без объекта синхронизации Тяжелые - ссылки с объектом синхронизации совметсного доступа (мьютексом). Переменные - владельцы объектов (в них хранятся ссылки) могут быть двух видов:\nлокальные (контролируемые) - область жизни локальных переменных строго ограничена и определяется правилами синтаксиса языка (аргументы и локальные переменные функций, потоков и т.д.). не контролируемые - глобальные или статические переменные, динамически создаваемые объекты, время жизни которых компилятор не контролирует. Когда локальная переменная удаляется - уменьшается счетчик ссылок, а при достижении нуля - объект освобождается.\nКаждый объект может иметь только одну не контролируемую переменную с сильной ссылкой и произвольное количество любых дргуих типов ссылок в локальных (контролируемых) переменных.\nДля не контролируемых переменных разрешается делать только слабые ссылки, которые перед использованием требуется захватить, например в локальную (контролируемую) переменную.\nУправление временем жизни объекта включает в себя не только управлением памятью, но и при необходимости, создаются механизмы синхронизации доступа к ней. Для этого при определении переменной, описываются возможные типы ссылок, которые разрешено на неё получать:\nбез создания ссылок, т.е. компилятор не даст создать ссылку на данную переменную, а совместный доступ к такой переменой будет не возможен возможно создание легкой ссылки (\"\u0026\"). Компилятору при генерации машинного кода не нужно создавать объект синхронизации доступа к переменной.\nСсылки для полей структур или объектов могут быть только легкими. разрешено создавать ссылки с монопольным доступом (\"\u0026\u0026\"). Компилятор автоматически создает не рекурсивный мьютекс для синхронизации доступа к переменной, т.е. ссылка у этой переменной будет тяжелой. разрешено создавать ссылки с рекурсивным доступом (\"\u0026*\"). Компилятор автоматически создает рекурсивный мьютекс (его можно захватывать несколько раз), а ссылка у этой переменной будет тяжелой. легкая ссылка может быть создана для совместного доступа (\"\u0026?\"), но её захват и синхронизация доступа к ней возможен только при групповом захвате ссылок. Все виды ссылок могут быть константными (\"\u0026^\", “\u0026\u0026^” или “\u0026*^”), т.е. только для чтения (и в случае константных объектов, таким ссылкам мьютекс не потребуется).\nЗахват слабой ссылки может быть индивидуальным или групповым с сохранением результата в локальную (контролируемую) переменную. Такое использование логики захвата объекта на уровне синтаксиса языка гарантирует последующее автоматическое освобождение временной переменной, что равнозначно невозможности создания циклических ссылок.\nПеременная со слабой/не владеющей ссылкой создается только тогда, когда в правой части операции присвоения присутствует любой из операторов получения ссылки (\u0026, \u0026\u0026, \u0026* или \u0026^, \u0026\u0026^, \u0026*^).\nВо всех остальных случаях создается переменная владелец с сильной/владеющей ссылкой (если это разрешено).\nЗахват ссылки и значение переменной Захват ссылки - это преобразование слабой ссылки в сильную с её сохранением в контролируемую переменую с инкрементом счетчика ссылок и возможностью доступа к значению объекта. Это очень похоже на заимствование (Borrowing) в Rust, так как тоже позволяет использовать данные, находящиеся во владении другой переменной, но без перехода владения. Для захвата ссылок используются операторы:\n‘*’ или ‘*( … )’ - автоматический выбор типа доступа (чтения/запись или только чтение) ‘*^’ или ‘*^( … )’ - захват доступа только для чтения ‘**( … )’ - групповой захват ссылок в локальные (контролируемые) переменные () после имени переменной - создание копии значения переменной (глубокое клонирование) ??????????????????????????????????? Упрощенный условный пример:\nref := \u0026 owner; # переменная ref - слабая ссылка на owner ref_ro := \u0026^ owner; # слабая ссылка на owner только для чтения val := * ref; # Автоматический захват только для чтения *ref = val; # Автоматический захват для чтения/записи val := *^ ref; # Захват только для чтения val := *^ ref_ro; val := * ref_ro; # Автоматический захват только для чтения *ref_ro = val; # Ошибка - ссылка только для чтения !!! *^ ref_ro = val; # Ошибка - недопустима конструкция (захват lval - только для чтения) Слабую ссылку можно захватить (превратить в сильную) сохранив результат в локальной переменной, после чего работать с локальной переменной “по значению” без необходимости захватытвать ссылку при каждом обращении к переменной. Значения переменных со слабыми ссылками можно копировать в другие переменные без ограничений. Значение переменной с сильной ссылкой нельзя скопировать в другую переменную или поле объекта, но можно клонировать данные или обменяться значениями “:=:” с другой переменной с сильной ссылкой (swap). Примеры владения:\nowner := \"string\"; other := \"string 2\"; owner = other; # Ошибка - нельзя копировать! owner = other(); # Глубокое клонирование данных owner :=: other; # Обмен значениями (swap) other = _; # Очистка данных объекта Переменную, содержащую ссылку на ссылку создать нельзя, но можно создать ссылочный тип и после этого создать переменную-ссылку на этот тип данных. Упрощенный условный пример:\nvalue := 123; :RefInt := \u0026 Integer; ref_int :RefInt := \u0026 value; ref_ref := \u0026 ref_int; Если переменная владелец разрешает создавать ссылки на объект, тогда при обращении к такой переменой требуется выполнять захват объекта для обеспечения работы механизма совместного доступа. Ссылки и совместный доступ Управление временем жизни переменной включает в себя не только управление памятью, но и механизм синхронизации для монопольного/раздельного доступа к объектам из разных потоков.\nПримеры ссылок:\n\u0026 local := 123; # Разрешено создание ссылок только в текущем потоке \u0026\u0026 thread := 456; # Разрешено создание ссылок с монопольным доступом в любом потоке ref := \u0026 local; # Создание слабой ссылки на local ref2 := \u0026\u0026 local; # Ошибка! многопоточные ссылки не разрешены ref_th := \u0026\u0026 thread; # Создание слабой ссылки на thread # c монопольной блокировкой доступа local += 1; # ОК thread += 1; # Ошибка, требуется захват объекта с разеляемым доступом *local += 1; # ОК, оператор захвата игнорируется *thread += 1; # Захват объекта (как захват слабой ссылки) ref += 1; # Ошибка, требуется захват слабой ссылки ref_th += 1; # Ошибка, требуется захват слабой ссылки *ref += 1; *ref_th += 1; Операторы захвата ссылки и синхронизации доступа к объекту выполняются только для одного действия над переменной. Но захват объекта синхронизации, это относительно медленная операция и выполнять её для каждого действия над переменной не рационально.\nДля того, чтобы однократно захватить объект(ы) синхронизации для выполнения сразу нескольких действий над переменными можно захватить объект в локальную переменую или использовать менеджер контекста.\nПример программы rand():Int32 ::= %rand...; # Создание объекта @( rand():Int32 ); # Предварительное объявление (объект должен быть создан в другом месте) rand():Int32 = ...; usleep(usec:DWord64):None := %usleep...; printf(format:FmtChar, ...):Int32 := %printf...; func(count:Integer, target:String) := { $iter := @iter( 1..$count ); # Итератор для диапазона от 1 до $count @while( @curr($iter) ) { # Цикл, пока итератор валидный $step := @next($iter); # Получить текущий и перейти на следующий элемент итератора printf('Number %d from %s!', $step, $target); usleep( rand() % 1000 ); # Случайная задержка } } thread = :Thread(func, 5, 'thread'); thread.start(); func(5, 'main'); thread.join(); Number 1 from the thread! Number 1 from the main! Number 2 from the thread! Number 2 from the main! Number 3 from the thread! Number 4 from the thread! Number 3 from the main! Number 4 from the main! Number 5 from the main! Number 5 from the thread! Примеры ссылок:\n\u0026 $local := 123; # Разрешено получение легких ссылок \u0026\u0026 $thread := 456; # Доступ к переменной требует захвата тяжелой ссылки $ref := \u0026 $local; # получение слабой ссылки на local $ref2 := \u0026\u0026 $local; # Ошибка! Тяжелой многопоточные ссылки не разрешены $ref_th := \u0026\u0026 $thread; # Получение слабой ссылки на thread # c монопольной блокировкой доступа $local += 1; # ОК (для легких ссылок блокировка объекта не требуется) $thread += 1; # ОК (захват объекта происходит автоматически) $ref += 1; # Ошибка, требуется захват легкой слабой ссылки $ref_th += 1; # Ошибка, требуется захват тяжолой слабой ссылки *$local += 1; # ОК *$thread += 1; # ОК *$ref += 1; # ОК (только захват ссылки, блокировка игнорируется) *$ref_th += 1; # ОК (захват ссылки и блокироваки доступа) Менеджер контекста Операторы захвата ссылки и синхронизации доступа к объекту выполняются только для одного действия над переменной. Но захват объекта синхронизации, это относительно медленная операция и выполнять её для каждого действия над переменной не рационально.\nДля того, чтобы однократно захватить объект(ы) синхронизации для выполнения сразу нескольких действий над переменными используется менеджер контекста.\n","categories":"","description":"","excerpt":"https://habr.com/companies/otus/articles/763810/ …","ref":"/docs/syntax/memory/","tags":"","title":"Управление памятью, ссылки и совместный доступ"},{"body":"https://habr.com/ru/companies/otus/articles/763810/ https://habr.com/ru/articles/764420/\nПоследовательная согласованность отсутствует (отсутствуют атомарныти типы) Любой язык программирования так или иначе вынужден управлять оперативной памятью. В NewLang реализовано автоматическое управление памятью без сборщика мусора.\nЗа основу была взята модель “владения” из языка Rust, но она переработана под концепцию сильных и слабых указателей (аналоги shared_ptr и weak_ptr из С++), где каждое значение в памяти может иметь только одну переменную-владельца с сильным указателем.\nИ когда такая переменная-владелец уходит из области видимости, счетчик ссылок уменьшается и при достжении нуля память освобождается.\nФактически, это автоматическое управление памятью с помощью подсчёта ссылок на этапе компиляции и без использования сборщика мусора.\nСуществование ссылок на объекты предполагает и возможность одновременного доступа к данным из нескольких потоков выполнения. Из-за чего управление памятью включает в себя и элементы межпотокового взаимодействия, так как совместное владение ссылками по любому будет требовать каких либо механизмов синхронизации доступа к разеделяемой памяти объектов.\nПоэтому, при определении объекта указывается, какие типы ссылок допускается создавать на него, а так-же какая используется модель совместного доступа к переменной.\nВесь механизм подсчета ссылок и проверки их корректности реализован на уровне синтаксиса. В рантайме выполняется только контроль идентификатора потока для однопоточных ссылок, а все остальные проверки выполняются во время компиляции.\nУправление памятью и терминология Врчную выделить или освобондить память нельзя\nЛюбой объект - это ссылка на область памяти с данным. Память выделяется и освобожадется автоматически при создании/удалении объектов\nСсылки на объекты, с точки зрения владения, могут быть:\nСильные/Владеющие ссылки (аналог shared_ptr из С++), а фактические, это переменная которая хранит значение объекта. Слабые/Не владеющие ссылки (аналог weak_ptr из С++) - указатели на другим объекты которые перед использованием требуют обязательного захвата (т.е. преобразования в сильную ссылку). Ссылки на объекты, с точки зрения совместного доступа, могут быть:\nЛегкие - ссылки без объекта синхронизации Тяжелые - ссылки с объектом синхронизации совметсного доступа (мьютексом). Переменные - владельцы объектов (в них хранятся ссылки) могут быть двух видов:\nлокальные (контролируемые) - область жизни локальных переменных строго ограничена и определяется правилами синтаксиса языка (аргументы и локальные переменные функций, потоков и т.д.). не контролируемые - глобальные или статические переменные, динамически создаваемые объекты, время жизни которых компилятор не контролирует. Когда локальная переменная удаляется - уменьшается счетчик ссылок, а при достижении нуля - объект освобождается.\nКаждый объект может иметь только одну не контролируемую переменную с сильной ссылкой и произвольное количество любых дргуих типов ссылок в локальных (контролируемых) переменных.\nДля не контролируемых переменных разрешается делать только слабые ссылки, которые перед использованием требуется захватить, например в локальную (контролируемую) переменную.\nУправление временем жизни объекта включает в себя не только управлением памятью, но и при необходимости, создаются механизмы синхронизации доступа к ней. Для этого при определении переменной, описываются возможные типы ссылок, которые разрешено на неё получать:\nбез создания ссылок, т.е. компилятор не даст создать ссылку на данную переменную, а совместный доступ к такой переменой будет не возможен возможно создание легкой ссылки (\"\u0026\"). Компилятору при генерации машинного кода не нужно создавать объект синхронизации доступа к переменной.\nСсылки для полей структур или объектов могут быть только легкими. разрешено создавать ссылки с монопольным доступом (\"\u0026\u0026\"). Компилятор автоматически создает не рекурсивный мьютекс для синхронизации доступа к переменной, т.е. ссылка у этой переменной будет тяжелой. разрешено создавать ссылки с рекурсивным доступом (\"\u0026*\"). Компилятор автоматически создает рекурсивный мьютекс (его можно захватывать несколько раз), а ссылка у этой переменной будет тяжелой. легкая ссылка может быть создана для совместного доступа (\"\u0026?\"), но её захват и синхронизация доступа к ней возможен только при групповом захвате ссылок. Все виды ссылок могут быть константными (\"\u0026^\", “\u0026\u0026^” или “\u0026*^”), т.е. только для чтения (и в случае константных объектов, таким ссылкам мьютекс не потребуется).\nЗахват слабой ссылки может быть индивидуальным или групповым с сохранением результата в локальную (контролируемую) переменную. Такое использование логики захвата объекта на уровне синтаксиса языка гарантирует последующее автоматическое освобождение временной переменной, что равнозначно невозможности создания циклических ссылок.\nПеременная со слабой/не владеющей ссылкой создается только тогда, когда в правой части операции присвоения присутствует любой из операторов получения ссылки (\u0026, \u0026\u0026, \u0026* или \u0026^, \u0026\u0026^, \u0026*^).\nВо всех остальных случаях создается переменная владелец с сильной/владеющей ссылкой (если это разрешено).\nЗахват ссылки и значение переменной Захват ссылки - это преобразование слабой ссылки в сильную с её сохранением в контролируемую переменую с инкрементом счетчика ссылок и возможностью доступа к значению объекта. Это очень похоже на заимствование (Borrowing) в Rust, так как тоже позволяет использовать данные, находящиеся во владении другой переменной, но без перехода владения. Для захвата ссылок используются операторы:\n‘*’ или ‘*( … )’ - автоматический выбор типа доступа (чтения/запись или только чтение) ‘*^’ или ‘*^( … )’ - захват доступа только для чтения ‘**( … )’ - групповой захват ссылок в локальные (контролируемые) переменные () после имени переменной - создание копии значения переменной (глубокое клонирование) ??????????????????????????????????? Упрощенный условный пример:\nref := \u0026 owner; # переменная ref - слабая ссылка на owner ref_ro := \u0026^ owner; # слабая ссылка на owner только для чтения val := * ref; # Автоматический захват только для чтения *ref = val; # Автоматический захват для чтения/записи val := *^ ref; # Захват только для чтения val := *^ ref_ro; val := * ref_ro; # Автоматический захват только для чтения *ref_ro = val; # Ошибка - ссылка только для чтения !!! *^ ref_ro = val; # Ошибка - недопустима конструкция (захват lval - только для чтения) Слабую ссылку можно захватить (превратить в сильную) сохранив результат в локальной переменной, после чего работать с локальной переменной “по значению” без необходимости захватытвать ссылку при каждом обращении к переменной. Значения переменных со слабыми ссылками можно копировать в другие переменные без ограничений. Значение переменной с сильной ссылкой нельзя скопировать в другую переменную или поле объекта, но можно клонировать данные или обменяться значениями “:=:” с другой переменной с сильной ссылкой (swap). Примеры владения:\nowner := \"string\"; other := \"string 2\"; owner = other; # Ошибка - нельзя копировать! owner = other(); # Глубокое клонирование данных owner :=: other; # Обмен значениями (swap) other = _; # Очистка данных объекта Переменную, содержащую ссылку на ссылку создать нельзя, но можно создать ссылочный тип и после этого создать переменную-ссылку на этот тип данных. Упрощенный условный пример:\nvalue := 123; :RefInt := \u0026 Integer; ref_int :RefInt := \u0026 value; ref_ref := \u0026 ref_int; Если переменная владелец разрешает создавать ссылки на объект, тогда при обращении к такой переменой требуется выполнять захват объекта для обеспечения работы механизма совместного доступа. Ссылки и совместный доступ Управление временем жизни переменной включает в себя не только управление памятью, но и механизм синхронизации для монопольного/раздельного доступа к объектам из разных потоков.\nПримеры ссылок:\n\u0026 local := 123; # Разрешено создание ссылок только в текущем потоке \u0026\u0026 thread := 456; # Разрешено создание ссылок с монопольным доступом в любом потоке ref := \u0026 local; # Создание слабой ссылки на local ref2 := \u0026\u0026 local; # Ошибка! многопоточные ссылки не разрешены ref_th := \u0026\u0026 thread; # Создание слабой ссылки на thread # c монопольной блокировкой доступа local += 1; # ОК thread += 1; # Ошибка, требуется захват объекта с разеляемым доступом *local += 1; # ОК, оператор захвата игнорируется *thread += 1; # Захват объекта (как захват слабой ссылки) ref += 1; # Ошибка, требуется захват слабой ссылки ref_th += 1; # Ошибка, требуется захват слабой ссылки *ref += 1; *ref_th += 1; Операторы захвата ссылки и синхронизации доступа к объекту выполняются только для одного действия над переменной. Но захват объекта синхронизации, это относительно медленная операция и выполнять её для каждого действия над переменной не рационально.\nДля того, чтобы однократно захватить объект(ы) синхронизации для выполнения сразу нескольких действий над переменными можно захватить объект в локальную переменую или использовать менеджер контекста.\nПример программы rand():Int32 ::= %rand...; # Создание объекта @( rand():Int32 ); # Предварительное объявление (объект должен быть создан в другом месте) rand():Int32 = ...; usleep(usec:DWord64):None := %usleep...; printf(format:FmtChar, ...):Int32 := %printf...; func(count:Integer, target:String) := { $iter := @iter( 1..$count ); # Итератор для диапазона от 1 до $count @while( @curr($iter) ) { # Цикл, пока итератор валидный $step := @next($iter); # Получить текущий и перейти на следующий элемент итератора printf('Number %d from %s!', $step, $target); usleep( rand() % 1000 ); # Случайная задержка } } thread = :Thread(func, 5, 'thread'); thread.start(); func(5, 'main'); thread.join(); Number 1 from the thread! Number 1 from the main! Number 2 from the thread! Number 2 from the main! Number 3 from the thread! Number 4 from the thread! Number 3 from the main! Number 4 from the main! Number 5 from the main! Number 5 from the thread! Примеры ссылок:\n\u0026 $local := 123; # Разрешено получение легких ссылок \u0026\u0026 $thread := 456; # Доступ к переменной требует захвата тяжелой ссылки $ref := \u0026 $local; # получение слабой ссылки на local $ref2 := \u0026\u0026 $local; # Ошибка! Тяжелой многопоточные ссылки не разрешены $ref_th := \u0026\u0026 $thread; # Получение слабой ссылки на thread # c монопольной блокировкой доступа $local += 1; # ОК (для легких ссылок блокировка объекта не требуется) $thread += 1; # ОК (захват объекта происходит автоматически) $ref += 1; # Ошибка, требуется захват легкой слабой ссылки $ref_th += 1; # Ошибка, требуется захват тяжолой слабой ссылки *$local += 1; # ОК *$thread += 1; # ОК *$ref += 1; # ОК (только захват ссылки, блокировка игнорируется) *$ref_th += 1; # ОК (захват ссылки и блокироваки доступа) Менеджер контекста Операторы захвата ссылки и синхронизации доступа к объекту выполняются только для одного действия над переменной. Но захват объекта синхронизации, это относительно медленная операция и выполнять её для каждого действия над переменной не рационально.\nДля того, чтобы однократно захватить объект(ы) синхронизации для выполнения сразу нескольких действий над переменными используется менеджер контекста.\n","categories":"","description":"","excerpt":"https://habr.com/ru/companies/otus/articles/763810/ …","ref":"/ru/docs/syntax/memory/","tags":"","title":"Управление памятью, ссылки и совместный доступ"},{"body":"Определение функции происходит с помощью операторов создания объектов, имя функции должно соответствовать правилам именования, после которого указываются круглые скобки. В настоящий момент поддерживается создание функций только в качестве статических объектов с однократной инициализацией с помощью оператора ‘::=’;\nТелом функции должен быть блок кода, который располагается в пространстве имен определения этой функции.\nФункции поддерживают аргументы по умолчанию, а сами аргументы указываются как в Python, т.е. вначале идут обязательные, далее идут аргументы со значениями по умолчанию, где его имя отделяется от дефолтного значения знаком равно “=”.\nЕсли функция допускает обработку произвольного количества аргументов, то последним в списке параметров должно быть указано многоточие “…”.\nУ аргументов функции может быть указан допустимый тип данных. Тип возвращаемого значения указывается после закрывающей скобки.\nУ аргументов и у типа возвращаемого значения можно указать сразу несколько допустимых типов данных.\nДля этого их необходимо перечислить через запятую и заключить в угловые скобки, т.е.*\nfunc(arg:\u003c:Int8, :Int16, :Int32\u003e): \u003c:Int8, :Int16, :Int32\u003e ::= {$arg*$arg}; *) Данная функциональность запланирована, но пока не реализована\nДля создания функций используются те же правила синтаксиса и операторы, что и для создания переменных, только после имени функции обязательно должны быть указаны круглые скобки.\nСинтаксис NewLang поддерживает два типа функций: обычные и чистые функции.\nОбычные функции Обычная функция — такие функции являются именно обычными функциями в понимании С/С++. Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д. ?????????????????????????????\nhello(str) ::= { $printf ::= :Pointer('printf(format:FmtChar, ...):Int32'); $printf('call: %s', $str); $str; }; hello('Привет, мир!'); Чистые функции Чистая функция — это тоже обычная функция, только в том смысле, какой в него вкладывает функциональное программирование.\nУ чистой функции отсутствует доступ к контексту и глобальным переменным, поэтому она может обрабатывать только те данные, которые были ей переданы в качестве аргументов.\nСоздание чистой функции происходит с помощью операторов :- или ::-, а сам оператор заимствован из языка Пролог. ???????????????????????????????? Чистые фунции, так же как и обычные, тоже могут быть только статическими объектами, поэтому их нельзя определять с именами лоакльных объектов.\nSum2(arg1, arg2) ::- {$arg1+$arg2;}; # Тоже самое, но если функция с таким именем уже существует, то будет ошибка ??????????????????????????????????????????????????? Sum1(arg1, arg2) :- {$arg1+$arg2;}; # Создать или переопределить простую функцию, которая возвращает сумму аргументов Лямбда функции Лямбда функции, это анонимная функция без указания имени, т.е. вместо имени функции стоит подчерк, и её нельзя вызвать по имени. Но зато лямбда функцию можно передавать как аругмент в другие функции, например при создании итератора.\n_()::={ ... }; Корутины Любую функцию можно определить как корутину (сопрограмма, Coroutine) - функция, выполнение которой можно прерываться явно методами языка программирования. В отличие от прерывания выполнения потока (thread), который реализован средствами ОС и его переключение происходит неявно и в произвольный момент времени.\nfunc() ::= (){ ... }; Переопределение функций Перегрузка функций по типам аргументов NewLang отсуствует, поэтому нельзя создать несколько функций с однинаковым именем, но разными типами аругментов. Но можно переопределить функцию с помощью оператора “[]=”, а в теле новой функции обратиться к первоначальной функции по системному имени “$$”.\n«Требование от субтипов: пусть φ(x) — свойство, доказуемое относительно объектов x типа T. Тогда φ(y) должно быть истинно для объектов y типа S, где S — субтип T»12.\nЭто называется принципом подстановки Лисков. Я не буду вдаваться в подробности, но основной смысл в том, что любое предусловие (для типов, данных или состояния) параметров не может быть строже, чем для супертипа, а любое постусловие не может быть слабее, чем у супертипа13. Эта формулировка связана с методологией контрактного программирования, зародившегося примерно в то же время.\nНовая функция должна иметь аргументы, совместимые с типом аргумента первоначальной функцией.\nfunc(arg:Int8):Int8 ::= ... ; func(arg:Int16):Int16 = ... ; # ОК Int8 -\u003e Int16 func(arg:String):Int16 = ... ; # Ошибка String -\u003e Int16 func(arg:Int16, arg2:Int16):Int16 = ... ; func(arg:Integer, ...):Integer = ... ; # ОК обобщенные тип ","categories":"","description":"","excerpt":"Определение функции происходит с помощью операторов создания объектов, …","ref":"/docs/types/funcs/","tags":["типы данных","функции"],"title":"Функции"},{"body":"Определение функции происходит с помощью операторов создания объектов, имя функции должно соответствовать правилам именования, после которого указываются круглые скобки. В настоящий момент поддерживается создание функций только в качестве статических объектов с однократной инициализацией с помощью оператора ‘::=’;\nТелом функции должен быть блок кода, который располагается в пространстве имен определения этой функции.\nФункции поддерживают аргументы по умолчанию, а сами аргументы указываются как в Python, т.е. вначале идут обязательные, далее идут аргументы со значениями по умолчанию, где его имя отделяется от дефолтного значения знаком равно “=”.\nЕсли функция допускает обработку произвольного количества аргументов, то последним в списке параметров должно быть указано многоточие “…”.\nУ аргументов функции может быть указан допустимый тип данных. Тип возвращаемого значения указывается после закрывающей скобки.\nУ аргументов и у типа возвращаемого значения можно указать сразу несколько допустимых типов данных.\nДля этого их необходимо перечислить через запятую и заключить в угловые скобки, т.е.*\nfunc(arg:\u003c:Int8, :Int16, :Int32\u003e): \u003c:Int8, :Int16, :Int32\u003e ::= {$arg*$arg}; *) Данная функциональность запланирована, но пока не реализована\nДля создания функций используются те же правила синтаксиса и операторы, что и для создания переменных, только после имени функции обязательно должны быть указаны круглые скобки.\nСинтаксис NewLang поддерживает два типа функций: обычные и чистые функции.\nОбычные функции Обычная функция — такие функции являются именно обычными функциями в понимании С/С++. Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д. ?????????????????????????????\nhello(str) ::= { $printf ::= :Pointer('printf(format:FmtChar, ...):Int32'); $printf('call: %s', $str); $str; }; hello('Привет, мир!'); Чистые функции Чистая функция — это тоже обычная функция, только в том смысле, какой в него вкладывает функциональное программирование.\nУ чистой функции отсутствует доступ к контексту и глобальным переменным, поэтому она может обрабатывать только те данные, которые были ей переданы в качестве аргументов.\nСоздание чистой функции происходит с помощью операторов :- или ::-, а сам оператор заимствован из языка Пролог. ???????????????????????????????? Чистые фунции, так же как и обычные, тоже могут быть только статическими объектами, поэтому их нельзя определять с именами лоакльных объектов.\nSum2(arg1, arg2) ::- {$arg1+$arg2;}; # Тоже самое, но если функция с таким именем уже существует, то будет ошибка ??????????????????????????????????????????????????? Sum1(arg1, arg2) :- {$arg1+$arg2;}; # Создать или переопределить простую функцию, которая возвращает сумму аргументов Лямбда функции Лямбда функции, это анонимная функция без указания имени, т.е. вместо имени функции стоит подчерк, и её нельзя вызвать по имени. Но зато лямбда функцию можно передавать как аругмент в другие функции, например при создании итератора.\n_()::={ ... }; Корутины Любую функцию можно определить как корутину (сопрограмма, Coroutine) - функция, выполнение которой можно прерываться явно методами языка программирования. В отличие от прерывания выполнения потока (thread), который реализован средствами ОС и его переключение происходит неявно и в произвольный момент времени.\nfunc() ::= (){ ... }; Переопределение функций Перегрузка функций по типам аргументов NewLang отсуствует, поэтому нельзя создать несколько функций с однинаковым именем, но разными типами аругментов. Но можно переопределить функцию с помощью оператора “[]=”, а в теле новой функции обратиться к первоначальной функции по системному имени “$$”.\n«Требование от субтипов: пусть φ(x) — свойство, доказуемое относительно объектов x типа T. Тогда φ(y) должно быть истинно для объектов y типа S, где S — субтип T»12.\nЭто называется принципом подстановки Лисков. Я не буду вдаваться в подробности, но основной смысл в том, что любое предусловие (для типов, данных или состояния) параметров не может быть строже, чем для супертипа, а любое постусловие не может быть слабее, чем у супертипа13. Эта формулировка связана с методологией контрактного программирования, зародившегося примерно в то же время.\nНовая функция должна иметь аргументы, совместимые с типом аргумента первоначальной функцией.\nfunc(arg:Int8):Int8 ::= ... ; func(arg:Int16):Int16 = ... ; # ОК Int8 -\u003e Int16 func(arg:String):Int16 = ... ; # Ошибка String -\u003e Int16 func(arg:Int16, arg2:Int16):Int16 = ... ; func(arg:Integer, ...):Integer = ... ; # ОК обобщенные тип ","categories":"","description":"","excerpt":"Определение функции происходит с помощью операторов создания объектов, …","ref":"/ru/docs/types/funcs/","tags":["типы данных","функции"],"title":"Функции"},{"body":"Macros are also used to transform the original code of NewLang into a more familiar syntax based on keywords, as such text is much easier to understand when reading the original code later.\nIn NewLang, macros are one or more consecutive terms that are replaced with another term or a whole syntactic construction (a sequence of lexemes).\nMacros are processed during the operation of the lexer, i.e., before passing the sequence of lexemes to the parser, allowing fragments of the language syntax to be modified using macros, for example, when implementing custom DSL dialects.\nDefining Macros The definition of macros is similar to the definition of other objects and consists of three parts \u003ccreation/assignment operator\u003e and ends with a semicolon “;”, i.e., normal operators ::=(::-), =, or :=(:-) are used to create a new or redefine an existing object, and the macro name is indicated between two symbols \"@@\" and can contain one or more lexemes (terms).\nAll macros belong to the global namespace, so the first term in the macro name must be unique, otherwise it will override local and global variables during name lookup if they are written in the program text without qualifiers (sigils).\nUsing the operators ::- and :- creates pure (hygienic) macros, arguments and variables in which are guaranteed not to intersect with the program’s namespace.\nThe body of a macro can be a valid language expression, a sequence of lexemes (enclosed in double at symbols \"@@\", i.e. @@ lexeme1 lexeme2 @@), or a regular text string (which should be specified between triple at symbols \"@@@\", i.e. @@@ text string @@@).\nIn the macro name after the first term, one or more templates may be present. A template is a term that, when matching a sequence of lexemes with the macro identifier, can be replaced by any other single term (effectively, this is pattern/template matching).\nTo create a template term, a dollar sign should be placed at the beginning of its identifier (which corresponds to a qualifier of a local variable), i.e. the macro name @@ FUNC $name @@ will correspond to the sequence of lexemes as FUNC my_func_name as well as FUNC other_name_func.\nTo remove a macro, a special syntax is used: @@@@ name @@@@; or @@@@ two terms @@@@;, i.e. you need to specify the macro identifier between four characters \"@@@@\".\n# Macro body from a text string (as in C/C++ preprocessor) @@macro_str@@ := @@@ string - macro body @@@; # String for the lexer # Removing macro @macro_str @@@@ macro_str @@@@; Macro Arguments and Expansion Macros can be defined with arguments (parameters in parentheses) or without them. If a macro was defined with arguments, their validation will be performed by the macro processor during definition and expansion of the macro. If a macro was defined without arguments, the presence of arguments will be ignored by the macro processor.\nThe macroprocessor considers macros with and without arguments identical, so it is not possible to create two macros with the same name, one with arguments (in parentheses) and the other without.\nTherefore, if you need to use a macro in two different ways (with arguments and without), you should define the macro without arguments, and in this case, the parameter control will be done by the compiler.\n@@ macro @@ := term; # Macro without arguments macro(args); # OK -\u003e term(args); macro; # OK -\u003e term; # But @@ call() @@ := term(); call(); # OK -\u003e term(); call; # Error (@call is defined with arguments) If arguments are specified when defining a macro, the place for their insertion in the body of the macro is written as the name of a local variable with the symbol \"@\" added before it, i.e. @$arg.\nThe place for inserting the number of actual arguments passed is marked by the lexeme \"@$#\". If it is necessary to insert the passed arguments as a dictionary, the place for insertion is marked by the lexeme \"@$*\".\nIf the macro takes an arbitrary number of arguments (the macro arguments are terminated by an ellipsis), the place for their insertion in the body of the macro is marked by the lexeme \"@$…\".\nAnalogous to the C/C++ preprocessor, to concatenate two lexemes into one, the operator \"@##\" is used in the body of the macro, and to convert a lexeme into a text string, the operators @#, @#\", or @#’ are applied, for example, @@macro($arg)@@ := @@ func_ @## @$arg( @#\" arg ) @;, then the call macro(name); will be transformed into func_name (\"name\");\nExamples of using macros:\n# Ordinary macros (the body of the macro is a correct expression) @@ macro @@ := replace(); @@ macro2(arg) @@ := { call(@$arg); call()}; # The body of the macros from a sequence of tokens @@ if(...) @@ := @@ [ @$... ]--\u003e @@; # The expression may not be complete @@ elif(...) @@ := @@ ,[ @$... ]--\u003e @@; @@ else @@ := @@ ,[...]--\u003e @@; # Writing a conditional statement using # the macros defined above @if( condition ){ ... } @elif( condition2 ) { ... } @else { ... }; For example, a loop up to 5:\ncount := 1; [ 1 ] \u003c-\u003e { [ count \u003e 5 ] --\u003e { -- 42 --; }; count+=1; }; This will look more familiar:\ncount := 1; @while( true ) { @if( count \u003e 5 ) { @return 42; }; count += 1; }; ","categories":"","description":"","excerpt":"Macros are also used to transform the original code of NewLang into a …","ref":"/docs/syntax/macros/","tags":"","title":"Macros"},{"body":"Итераторы в NewLang, как и в остальных языках программирования, предназначены для перебора элементов. Но, в отличии от итераторов в С++, итераторы NewLang являются самостоятельными объектами, а не указателями на отдельные элементы объекта-контейнера. Итераторы NewLang поддерживают фильтрацию элементов по имени за счет использования функций обратного вызова.\nДля работы с итераторами используется следующий синтаксис:\n? или ?( текст ) - создание итератора без фильтра или с regex фильтрацией по имени поля ?( func, args… ) - создание итератора с использованием лямбда функции или функции обратного вызова ! или !( количество возвращаемых элементов ) - перебор элементов итератора ?! или !? - получить текущий элемент без перемещение курсора !! - сбросить указатель итератора в начальное состояние (на первый элемент) ?? - создать итератор и сразу его выполнить, возвращая все значения в виде элементов словаря максимально возможного размера. Это своего рода синтаксический сахар для краткой записи последовательности команд ?; !(9223372036854775807);, что удобно использовать при отладке для вывода значений переменных. Для работы с итераторами можно использовании DSL операторы:\niter() - Создать итератор (?) next() - перебор элементов итератора (! или !( количество возвращаемых элементов )) curr() - Получить текущий элемент без перемещение курсора (?! или !?) first() - Сбросить указатель итератора на первый элемент (!!) all() - Создать итератор и сразу его выполнить (??) Примеры создания итераторов с разными фильтрами отбора данных:\niter := dict ? (\"name\"); # Создание итератора для значений с указанным именем iter := dict ? (\"regex.\"); # Создание итератора для полей с префиксом \"regex\" # Чистая функция для фильтрации по значению filter(value) :- { $value \u0026\u0026 $value \u003c 10; }; iter := dict ? (filter); # Создание итератора для значений меньше 10 equal(value, arg) := { $value == arg }; # Обычная функция iter := dict ? (equal, 100); # Создать итератор только для значений 100 Оператор перебора элементов итератора ! возвращает текущий элемент и сдвигает указатель на следующий. Точнее, на количество считанных элементов, так как прочитать элементы из итератора можно не только по одному, а и заданными порциями, например по 10 за один раз, iter ! (10);.\nЕсли указать количество считываемых элементов !(0), то будет возвращен сам элемент, но для значений отличных от нуля будет возвращаться не элемент данных, а словарь с данными, считанными из итератора. Из-за этого операторы ! и !(0) НЕ эквивалентны, т.к. по разному обрабатывают конец данных.\nЛучше всего это показать на примерах для словаря с пятью элементами:\ndict := (1,2,3,4,5,)?; # Создать итератор для словаря dict!; # -\u003e 1 dict!; # -\u003e 2 dict!; # -\u003e 3 dict!; # -\u003e 4 dict!; # -\u003e 5 dict!; # -\u003e будет исключение \"конец итератора\" # Но dict !(0); # -\u003e (1,) dict !(0); # -\u003e (2,) dict !(0); # -\u003e (3,) dict !(0); # -\u003e (4,) dict !(0); # -\u003e (5,) dict !(0); # -\u003e (,) - вернется пустой словарь Так же для чтения итератора можно указывать и отрицательное количество элементов. В этом случае будет возвращаться словарь всегда указанного размера, но элементы в словаре будут присутствовать только в случае чтения реальных данных из итератора:\ndict := (1,2,3,4,5,) ?; # Итератор для словаря с пятью элементами dict !(3); # -\u003e (1,2,3,) dict !(3); # -\u003e (4,5,) dict !(3); # -\u003e (,) # Но dict !(-3); # -\u003e (1,2,3,) dict !(-3); # -\u003e (4,5, :IteratorEnd) dict !(-3); # -\u003e (:IteratorEnd, :IteratorEnd, :IteratorEnd) ","categories":"","description":"","excerpt":"Итераторы в NewLang, как и в остальных языках программирования, …","ref":"/docs/types/iter/","tags":["типы данных","итераторы"],"title":"Итераторы"},{"body":"Итераторы в NewLang, как и в остальных языках программирования, предназначены для перебора элементов. Но, в отличии от итераторов в С++, итераторы NewLang являются самостоятельными объектами, а не указателями на отдельные элементы объекта-контейнера. Итераторы NewLang поддерживают фильтрацию элементов по имени за счет использования функций обратного вызова.\nДля работы с итераторами используется следующий синтаксис:\n? или ?( текст ) - создание итератора без фильтра или с regex фильтрацией по имени поля ?( func, args… ) - создание итератора с использованием лямбда функции или функции обратного вызова ! или !( количество возвращаемых элементов ) - перебор элементов итератора ?! или !? - получить текущий элемент без перемещение курсора !! - сбросить указатель итератора в начальное состояние (на первый элемент) ?? - создать итератор и сразу его выполнить, возвращая все значения в виде элементов словаря максимально возможного размера. Это своего рода синтаксический сахар для краткой записи последовательности команд ?; !(9223372036854775807);, что удобно использовать при отладке для вывода значений переменных. Для работы с итераторами можно использовании DSL операторы:\niter() - Создать итератор (?) next() - перебор элементов итератора (! или !( количество возвращаемых элементов )) curr() - Получить текущий элемент без перемещение курсора (?! или !?) first() - Сбросить указатель итератора на первый элемент (!!) all() - Создать итератор и сразу его выполнить (??) Примеры создания итераторов с разными фильтрами отбора данных:\niter := dict ? (\"name\"); # Создание итератора для значений с указанным именем iter := dict ? (\"regex.\"); # Создание итератора для полей с префиксом \"regex\" # Чистая функция для фильтрации по значению filter(value) :- { $value \u0026\u0026 $value \u003c 10; }; iter := dict ? (filter); # Создание итератора для значений меньше 10 equal(value, arg) := { $value == arg }; # Обычная функция iter := dict ? (equal, 100); # Создать итератор только для значений 100 Оператор перебора элементов итератора ! возвращает текущий элемент и сдвигает указатель на следующий. Точнее, на количество считанных элементов, так как прочитать элементы из итератора можно не только по одному, а и заданными порциями, например по 10 за один раз, iter ! (10);.\nЕсли указать количество считываемых элементов !(0), то будет возвращен сам элемент, но для значений отличных от нуля будет возвращаться не элемент данных, а словарь с данными, считанными из итератора. Из-за этого операторы ! и !(0) НЕ эквивалентны, т.к. по разному обрабатывают конец данных.\nЛучше всего это показать на примерах для словаря с пятью элементами:\ndict := (1,2,3,4,5,)?; # Создать итератор для словаря dict!; # -\u003e 1 dict!; # -\u003e 2 dict!; # -\u003e 3 dict!; # -\u003e 4 dict!; # -\u003e 5 dict!; # -\u003e будет исключение \"конец итератора\" # Но dict !(0); # -\u003e (1,) dict !(0); # -\u003e (2,) dict !(0); # -\u003e (3,) dict !(0); # -\u003e (4,) dict !(0); # -\u003e (5,) dict !(0); # -\u003e (,) - вернется пустой словарь Так же для чтения итератора можно указывать и отрицательное количество элементов. В этом случае будет возвращаться словарь всегда указанного размера, но элементы в словаре будут присутствовать только в случае чтения реальных данных из итератора:\ndict := (1,2,3,4,5,) ?; # Итератор для словаря с пятью элементами dict !(3); # -\u003e (1,2,3,) dict !(3); # -\u003e (4,5,) dict !(3); # -\u003e (,) # Но dict !(-3); # -\u003e (1,2,3,) dict !(-3); # -\u003e (4,5, :IteratorEnd) dict !(-3); # -\u003e (:IteratorEnd, :IteratorEnd, :IteratorEnd) ","categories":"","description":"","excerpt":"Итераторы в NewLang, как и в остальных языках программирования, …","ref":"/ru/docs/types/iter/","tags":["типы данных","итераторы"],"title":"Итераторы"},{"body":"Макросы используются и для превращеня исходного кода NewLang в более привычный синтаксис на основе ключевых слов, так как такой тест гораздо легче воспринимается при последующем чтении исходного кода.\nМакросы в NewLang, это один или несколько последовательных терминов, которые заменяются на другой термин или на целую синтаксическую конструкцию (последовательность лексем).\nМакросы обработываются во время работы лексера, т.е. перед передачей последовательности лексем в парсер, что позволяет с помощью маросов изменять фрагменты синтаксиса языка, например, при реализации собственных диалектов DSL.\nОпределение макросов Определение макросов аналогично определению других объектов и состоит из трех частей \u003cимя макроса\u003e \u003cоператор создания/присвоения\u003e \u003cтело макроса\u003e и завершающая точка с запятой “;”, т.е. применяются обычные операторы ::=(::-), = или :=(:-) для создания нового или переопределения уже существующего объекта, а имя макроса указывается между двумя символами \"@@\" и может содержать одну или нескольких лексем (терминов).\nВсе макросы относятся к глобальному пространству имен, поэтому первый термин в имени макроса должен быть уникальным, иначе он будет прекрывать локальные и глобальные переменные при разрешении имен, если они записаны в тексте программы без квалификаторов (сигилов).\nС помощью операторов ::- и :- создаются чистые (гигиеничные) макросы, аргументы и переменные в которых гарантированно не пересекаются с пространством имен программы.\nТелом макроса могут быть корректное выражение языка, последовательность лексем (которые заключается в двойные собачки \"@@\", т.е. @@ лексема1 лексема1 @@) или обычная текстовая строка (которую нужно указать между тройными собачками \"@@@\", т.е. @@@ текстовая строка @@@).\nВ имени макроса после первого термина могут присутствовать один или несколько шаблонов. Шаблон — это термин, который при сопоставлении последовательности лексем с идентификатором макроса может заменяться любым другим одиночным термином (т.е. фактически это сопоставление по образцу/шаблону).\nДля создания термина-шаблона в начале его идентификатора нужно поставить знак доллара (что соответствует квалификатору локальной переменой), т.е. имя макроса @@ FUNC $name @@ будет соответствовать последовательности лексем как FUNC my_func_name, так и FUNC other_name_func.\nДля удаления макроса используется специальный синтаксис: @@@@ name @@@@; или @@@@ два термина @@@@;, т.е. необходимо указать идентификатор макроса между четырмя символами \"@@@@\".\n# Тело макроса из текстовой строки (как в препроцессоре С/С++) @@macro_str@@ := @@@ строка - тело макроса @@@; # Строка для лексера # Удаления макроса @macro_str @@@@ macro_str @@@@; Аргументы макросов и их раскрытие Макросы можно определять как с аргументами (параметрами в скобках), так и без них. Если макрос был определен с аргументами, то их проверка будет выполнятся макропроцессором при определении и раскрытии макроса. Если макрос был определен без аргументов, то их наличие макропроцессором игнорируется.\nМакропроцессор считает макросы с аргументами и без оных идентичными, то нельзя создать два макроса с одинаковыми именами, один из которых будет с аргументами (скобками), а другой без них.\nПоэтому, если требуется использовать макрос в двух разных вариантах (с аргументами и без оных), следует определять макрос без аргументов и в этом случае контроль параметров будет выполнятся компилятором.\n@@ macro @@ := term; # Макрос без аргументов macro(args); # ОК -\u003e term(args); macro; # ОК -\u003e term; # Но @@ call() @@ := term(); call(); # ОК -\u003e term(); call; # Ошибка (@call определен с аргументами) Если при определении макроса указаны аргументы, то место для их вставки в теле макроса записывается как имя локальной переменой, перед которой добавлен символ \"@\", т.е. @$arg.\nМесто для вставки числа реально переданных аргументов отмечается лексемой \"@$#\". Если требуется вставить переданные аргументы в виде словаря, то место для вставки отмечается лексемой \"@$*\".\nЕсли макрос принимае произвольное количество аргументов (аргуметы макроса завершает многоточие), то место их вставки в тело макроса отмечается лексемой \"@$…\".\nПо аналогии с препроцессором С/С++, для соединения двух лексем в одну, в теле макроса используется оператор \"@##\", а для преобразование лексемы в текстову строку применяется операторы @#, @#\" или @#’, например, @@macro($arg)@@ := @@ func_ @## @$arg( @#\" arg ) @;, тогда вызов macro(name); будет преобразован в func_name (\"name\");\nПримеры использования макросов:\n# Обычные макросы (тело макроса корректное выражение) @@ macro @@ := replace(); @@ macro2(arg) @@ := { call(@$arg); call()}; # Тело макросов из последовательности лексем @@ if(...) @@ := @@ [ @$... ]--\u003e @@; # Выражение может быть не полным @@ elif(...) @@ := @@ ,[ @$... ]--\u003e @@; @@ else @@ := @@ ,[...]--\u003e @@; # Запись условного оператора с использованием # определенных выше макросов @if( condition ){ ... } @elif( condition2 ) { ... } @else { ... }; Например цикл до 5:\ncount := 1; [ 1 ] \u003c-\u003e { [ count \u003e 5 ] --\u003e { -- 42 --; }; count+=1; }; Будет выглядеть более привычно:\ncount := 1; @while( true ) { @if( count \u003e 5 ) { @return 42; }; count += 1; }; Далее идеи на будущее Символьное программирование Символьное программирование, часто называемое декларативным программированием, представляет собой парадигму программирования, которая использует математическую логику, отношения и символы для представления знаний и помощи в решении проблем. Вместо того, чтобы сосредотачиваться на описании последовательности операций, необходимых для выполнения вычислений, как в императивном программировании, символическое программирование делает упор на выражении отношений и ограничений между структурами данных, уделяя особое внимание «что», а не «как».\nВ контексте парадигм программирования символическое программирование часто противопоставляется процедурному или императивному программированию, где программы определяют пошаговые процедуры для достижения своих целей. В то время как императивное программирование фокусируется на описании потока управления с использованием таких конструкций, как циклы и условные выражения, для управления выполнением, символическое программирование сосредоточено на выражении фактов о проблеме и позволяет выполнению естественным образом выводить последующие последствия из предоставленной информации.\nОдним из основных преимуществ символьного программирования является его способность обеспечивать более высокий уровень абстракции, что упрощает анализ кода и снижает вероятность ошибок. Непосредственно выражая отношения и ограничения, символическое программирование позволяет разработчикам сосредоточиться на моделировании и спецификации проблем, позволяя базовой системе управлять реализацией и выполнением алгоритмов.\nСуществует несколько языков программирования и сред, использующих парадигму символьного программирования, например Prolog, Lisp и Haskell. Например, Пролог — это язык логического программирования, который позволяет разработчикам выражать взаимосвязи и факты о проблемных областях, в то время как выполнение автоматически обосновывает и извлекает новые факты на основе исходной информации. В том же духе Лисп, функциональный язык программирования, использует символьные вычисления для манипулирования структурами данных и выполнения сложных операций над ними, используя краткий и математически обоснованный синтаксис. Haskell, еще один функциональный язык программирования, использует строгую типизацию и ленивые вычисления, чтобы обеспечить символическое рассуждение и облегчить эффективное создание программ.\nСимвольное программирование может быть полезным в широком спектре проблемных областей, включая искусственный интеллект, экспертные системы, программирование логики ограничений и символьную математику, среди других. Более высокий уровень абстракции, обеспечиваемый декларативными языками программирования, облегчает разработку сложных систем, сводя к минимуму вероятность ошибки и улучшая удобство обслуживания. В частности, использование символьного программирования в искусственном интеллекте позволяет разработчикам создавать системы представления знаний и механизмы рассуждения, которые можно применять для обработки естественного языка, машинного обучения и автоматического доказательства теорем.\nРазличие между символьным программированием и препроцессором\nЗадача препроцессора - раскрыть(расширить) макрос, тогда как при символьном программировании нужно сокращать (сворачивать) выражения Препроцессор обрабатывает последовательности лексем (плоские данные), тогда как символьное программирование оперирует выражениями (деревом лексем) Макрос у препроцессора идентифицируется первым термином, и если макрос не может быть раскрыт, то возникает ошибка. В символьном программировани требуется точное соответствие всего выражения и только в этом случае производится сокращение выражения. Предпосылки для реализации символьного программирования Компилятор - интерепретатор с REPL и обработка AST как во время компиляции, так и во время выполнения. Необходимо добавить конструкции для определения правил символьного программрования (чистые функции?) Необходимо добавить конструкцию для вычисления выражений в символьном программировании.\nWolfram https://habr.com/ru/articles/772984/\ndiffRules = { Sin[x] -\u003e Cos[x], Cos[x] -\u003e -Sin[x], x^2 -\u003e 2*x, x -\u003e 1, Log[x] -\u003e 1/x }; diffRules := ( Sin(x) @-\u003e Cos(x), Cos(x) @-\u003e -Sin(x), x^2 @-\u003e 2*x, x @-\u003e 1, Log(x) @-\u003e 1\\x, ); expr @-\u003e Sin(x) - x^2 + Log(x); # И применим к нему правила дифференцирования #expr /. diffRules #(* 1/x - 2 x + Cos[x] *) sym := SymEval(expr, diffRules); res := Eval(sym, x=0.123); expr = a^2 + 3 * b^3 - c^4 + 2 * x^2 - x + 4*c + 3 И я хочу это выражение линеаризовать, т.е. отбросить все степени выше первой. Я могу сделать это напрямую, как в примерах выше: expr /. { a^2 -\u003e 0, b^3 -\u003e 0, c^4 -\u003e 0, x^2 -\u003e 0 } (* 3 + 4 c - x *) Но это слишком неудобно. Что если я не знаю ни точную степень, ни имя переменной? Как просто указать, что нужно заменить все места, где встречается возведение в степень на ноль? Это можно сделать при помощи шаблонов вот так: expr /. Power[_, _] -\u003e 0 (* 3 + 4 c - x *) Либо вот так: expr /. _ ^ _ -\u003e 0 (* 3 + 4 c - x *) :diffRules() := { {@ Sin(x) @} ::- {@ Cos(x) @}; Cos(x) @-\u003e -Sin(x), x^2 @-\u003e 2*x, x @-\u003e 1, Log(x) @-\u003e 1\\x, }; expr @-\u003e Sin(x) - x^2 + Log(x); # И применим к нему правила дифференцирования #expr /. diffRules #(* 1/x - 2 x + Cos[x] *) sym := SymEval(expr, diffRules); res := Eval(sym, x=0.123); ","categories":"","description":"","excerpt":"Макросы используются и для превращеня исходного кода NewLang в более …","ref":"/ru/docs/syntax/macros/","tags":"","title":"Макросы"},{"body":"Пусто (:None) :None (пусто) — не содержит значения (точнее имеет одно значение :None). Указывается в тексте программы как один подчерк «_». Значение None имеют не инициализированные переменные и при попытке чтения из такой переменной возникает ошибка.\nТип переменной может быть явно указан или выведен автоматически из присваиваемого значения. Присвоить новое значение уже инициализированной переменной можно только для совместимого типа, так как неявное преобразование типов не допускаются.\n$var := _; # Создать не инициализированную переменную $var2 := var; # Ошибка!!! Нельзя прочитать не инициализированную переменную var $var = 1000; # У переменной будет тип Short (минимальный размер для хранения значения) $var = 0,5; # Ошибка!!! Short ← Float не совместимы $var = _; # Очистить значение переменной $var = 0,5; # Теперь можно, т. к. None совместим с любым типом Диапазон (:Range) Диапазон — специальный тип данных, являющейся приблизительным аналогом типа «генератор» в Python. К диапазону можно обращаться как к итератору и он будет поочередно выдавать элементы в указанном интервале с заданным шагом. Диапазон в тексте программы указывается как два или три элемента через две точки, например 1..5 — диапазон от единицы до пяти с шагом по умолчанию 1. В качестве параметров диапазона можно указывать не только литералы, но и имена переменных и даже рациональные числа. Например, 0,1..$stop..0,1 — диапазон от 0,1 до значения, указанного в переменной $stop с шагом 0,1 или 0..1\\10 - диапазон рациональных числе от 0 до 10.\nДиапазон целых чисел можно использовать в качестве индекса у тензоров (точнее, у любых объектов, которые допускают доступ к своим элементам по индексу, т.е. тензоры, словари и текстовые строки). Фактический, это поведение аналогично slice в языке Python и array[1:5] в Python означает тоже самое, что и array[1..5] в NewLang.\nВ качестве индекса у тензоров еще можно указать произвольное количество измерений с помощью многоточия, т.е.\n$tensor[…, 0] = 0; # Обнулить все первые элементы в каждом измерении. В будущем можно будет добавить возможность указывать индексы элементов с помощь диапазонов\n$tensor = :Tensor[12](4..4 = 29, 2..3 = 15, , 7..9..2 = 7, 10 ...); # [0, 0, 15, 15, 29, 0, 0, 7, 0, 7, 10, 10,] Поток (:Thread) Поток — специальный тип данных, который запускает функцию в отдельном потоке, который выполнтеся паралельно основному потоку приложения. Поток созадется в остановленном виде и для его запуска необходимо вызвать метод start(), а чтобы дождаться завершения потока вызывается метод join().\nrand():Int32 := %rand; usleep(usec:DWord64):None := %usleep; printf(format:FmtChar, ...):Int32 := %printf; func(count:Integer, target:String) := { $iter := 1..$count?; # Итератор для диапазона от 1 до $count [ $iter ?! ] \u003c-\u003e { # Цикл, пока итератор валидный $step := $iter!; # Получить текущий и перейти на следующий элемент итератора printf('Number %d from %s!', $step, $target); usleep( rand() % 1000 ); # Случайная задержка } } thread = :Thread(func, 5, 'thread'); thread.start(); func(5, 'main'); thread.join(); Number 1 from the thread! Number 1 from the main! Number 2 from the thread! Number 2 from the main! Number 3 from the thread! Number 4 from the thread! Number 3 from the main! Number 4 from the main! Number 5 from the main! Number 5 from the thread!\nУсловные переменные (condvars). Сходны с событиями, но не являются объектами, занимающими память — используется только адрес переменной, понятие «содержимое переменной» не существует, в качестве условной переменной может использоваться адрес произвольного объекта. В отличие от событий, установка условной переменной в просигнализированное состояние не влечёт за собой никаких последствий в случае, если на данный момент нет потоков, ожидающих на переменной. Установка события в аналогичном случае влечёт за собой запоминание состояния «просигнализировано» внутри самого события, после чего следующие потоки, желающие ожидать события, продолжают исполнение немедленно без остановки. Для полноценного использования такого объекта необходима также операция «освободить mutex и ожидать условную переменную атомарно». Активно используются в UNIX-подобных ОС. Дискуссии о преимуществах и недостатках событий и условных переменных являются заметной частью дискуссий о преимуществах и недостатках Windows и UNIX.\nERESOURCE. Мьютекс, поддерживающий рекурсивный захват, с семантикой разделяемого или эксклюзивного захвата. Семантика: объект может быть либо свободен, либо захвачен произвольным числом потоков разделяемым образом, либо захвачен всего одним потоком эксклюзивным образом. Любые попытки осуществить захваты, нарушающее это правило, приводят к блокировке потока до тех пор, пока объект не освободится так, чтобы сделать захват разрешённым. Также есть операции вида TryToAcquire — никогда не блокирует поток, либо захватывает, либо (если нужна блокировка) возвращает FALSE, ничего не делая. Используется в ядре Windows, особенно в файловых системах — так, например, любому кем-то открытому дисковому файлу соответствует структура FCB, в которой есть 2 таких объекта для синхронизации доступа к размеру файла. Один из них — paging IO resource — захватывается эксклюзивно только в пути обрезания файла, и гарантирует, что в момент обрезания на файле нет активного ввода-вывода от кэша и от отображения в память.\nИнтерфейс операционной системы (:System) Для доступа к различным функциям операционной системы NewLang предоставляет специальный тип данных :System. Он позволяет запускать системные команды и переопределять для них параметры системного окружения.\nВыполнение команды происходит при вызове метода run(), которому нужно передать имя системной команды и при необходимости дополнительные аргументы командной строки.\nРезультат выполнения команды (текстовый вывод, код завершения и т.д.) доступен как отдельные свойства объекта.\nПример:\n:System().run(\"echo\", \"Hello from the other side!\"); os := :System(); home_dir := os.run(\"cd\", \"~\"); printf(\"`cd ~` ran with exit code %d\", os.exitcode()); unknown_dir := os.run(\"cd\", \"doesnotexist\"); printf(\"`cd doesnotexis` ran with exit code %d\", os.exitcode()); Первая строка делает запускает команду echo.\nПотом создается объект :System и далее мы создаем две переменные, в которых хранятся результаты этой выполнения команды cd, которые изменяют каталог на домашнюю папку и на несуществующую папку.\nЗапустив этот файл, мы увидим:\nHello from the other side! `cd ~` ran with exit code 0 sh: line 0: cd: doesnotexist: No such file or directory `cd doesnotexist` ran with exit code 256 Первая строка - результат выполнения команды echo.\nДалее команда cd выполняется успешно и изменяет каталог на домашний. Следовательно, код возврата ноль, который получаем с помощью вызова метода exitcode().\nПоследняя команда cd выполняется с ошибкой, так как пытается изменить каталог на несуществующую папку.\nПростой варинат выполнение системной команды Есть упрощенный вариант выполнения системной команды с помощью заключения строки выполнения в обратные кавычки (как в bash).\n`echo Hello from the other side!`; В этом случае системная команда :System.run() сразу выполняется, а её текстовый вывод сохраняется в текстовую строку с широкими символами (:StrWide).\nЧтобы получить код возврата (например, чтобы проверить результат завершения на ошибки), можно обратится к результату выполнения последней команды $^.exitcode() или сохранить результат выполнения предыдущей команды в отдельную переменню, которая будет иметь тип :System.\n`echo Hello from the other side!`; res := $^; printf(\"`cd doesnotexis` ran with exit code %d\", res.exitcode()); В дальнейшем планируется расширить возможности интерфейса с операционной системой фоновое выполнение программ (useless_cat_call = subprocess.run([“cat”], stdout=subprocess.PIPE, text=True, input=“Hello from the other side”)) переназначение ввода/вывода (list_dir = subprocess.Popen([“ls”, “-l”]); list_dir.wait()) чтение/изменние перемнных окржения Еще пример возможностей для расширения os.name - имя операционной системы. Доступные варианты: ‘posix’, ’nt’, ‘mac’, ‘os2’, ‘ce’, ‘java’. os.environ - словарь переменных окружения. Изменяемый (можно добавлять и удалять переменные окружения). os.getlogin() - имя пользователя, вошедшего в терминал (Unix). os.getpid() - текущий id процесса. os.uname() - информация об ОС. возвращает объект с атрибутами: sysname - имя операционной системы, nodename - имя машины в сети (определяется реализацией), release - релиз, version - версия, machine - идентификатор машины. os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True) - проверка доступа к объекту у текущего пользователя. Флаги: os.F_OK - объект существует, os.R_OK - доступен на чтение, os.W_OK - доступен на запись, os.X_OK - доступен на исполнение. os.chdir(path) - смена текущей директории. os.chmod(path, mode, *, dir_fd=None, follow_symlinks=True) - смена прав доступа к объекту (mode - восьмеричное число). os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True) - меняет id владельца и группы (Unix). os.getcwd() - текущая рабочая директория. os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True) - создаёт жёсткую ссылку. os.listdir(path=\".\") - список файлов и директорий в папке. os.mkdir(path, mode=0o777, *, dir_fd=None) - создаёт директорию. OSError, если директория существует. os.makedirs(path, mode=0o777, exist_ok=False) - создаёт директорию, создавая при этом промежуточные директории. os.remove(path, *, dir_fd=None) - удаляет путь к файлу. os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None) - переименовывает файл или директорию из src в dst. os.renames(old, new) - переименовывает old в new, создавая промежуточные директории. os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None) - переименовывает из src в dst с принудительной заменой. os.rmdir(path, *, dir_fd=None) - удаляет пустую директорию. os.removedirs(path) - удаляет директорию, затем пытается удалить родительские директории, и удаляет их рекурсивно, пока они пусты. os.symlink(source, link_name, target_is_directory=False, *, dir_fd=None) - создаёт символическую ссылку на объект. os.sync() - записывает все данные на диск (Unix). os.truncate(path, length) - обрезает файл до длины length. os.utime(path, times=None, *, ns=None, dir_fd=None, follow_symlinks=True) - модификация времени последнего доступа и изменения файла. Либо times - кортеж (время доступа в секундах, время изменения в секундах), либо ns - кортеж (время доступа в наносекундах, время изменения в наносекундах). os.walk(top, topdown=True, onerror=None, followlinks=False) - генерация имён файлов в дереве каталогов, сверху вниз (если topdown равен True), либо снизу вверх (если False). Для каждого каталога функция walk возвращает кортеж (путь к каталогу, список каталогов, список файлов). os.system(command) - исполняет системную команду, возвращает код её завершения (в случае успеха 0). os.urandom(n) - n случайных байт. Возможно использование этой функции в криптографических целях. ","categories":"","description":"","excerpt":"Пусто (:None) :None (пусто) — не содержит значения (точнее имеет одно …","ref":"/docs/types/other/","tags":["типы данных"],"title":"Другие типы данных"},{"body":"Пусто (:None) :None (пусто) — не содержит значения (точнее имеет одно значение :None). Указывается в тексте программы как один подчерк «_». Значение None имеют не инициализированные переменные и при попытке чтения из такой переменной возникает ошибка.\nТип переменной может быть явно указан или выведен автоматически из присваиваемого значения. Присвоить новое значение уже инициализированной переменной можно только для совместимого типа, так как неявное преобразование типов не допускаются.\n$var := _; # Создать не инициализированную переменную $var2 := var; # Ошибка!!! Нельзя прочитать не инициализированную переменную var $var = 1000; # У переменной будет тип Short (минимальный размер для хранения значения) $var = 0,5; # Ошибка!!! Short ← Float не совместимы $var = _; # Очистить значение переменной $var = 0,5; # Теперь можно, т. к. None совместим с любым типом Диапазон (:Range) Диапазон — специальный тип данных, являющейся приблизительным аналогом типа «генератор» в Python. К диапазону можно обращаться как к итератору и он будет поочередно выдавать элементы в указанном интервале с заданным шагом. Диапазон в тексте программы указывается как два или три элемента через две точки, например 1..5 — диапазон от единицы до пяти с шагом по умолчанию 1. В качестве параметров диапазона можно указывать не только литералы, но и имена переменных и даже рациональные числа. Например, 0,1..$stop..0,1 — диапазон от 0,1 до значения, указанного в переменной $stop с шагом 0,1 или 0..1\\10 - диапазон рациональных числе от 0 до 10.\nДиапазон целых чисел можно использовать в качестве индекса у тензоров (точнее, у любых объектов, которые допускают доступ к своим элементам по индексу, т.е. тензоры, словари и текстовые строки). Фактический, это поведение аналогично slice в языке Python и array[1:5] в Python означает тоже самое, что и array[1..5] в NewLang.\nВ качестве индекса у тензоров еще можно указать произвольное количество измерений с помощью многоточия, т.е.\n$tensor[…, 0] = 0; # Обнулить все первые элементы в каждом измерении. В будущем можно будет добавить возможность указывать индексы элементов с помощь диапазонов\n$tensor = :Tensor[12](4..4 = 29, 2..3 = 15, , 7..9..2 = 7, 10 ...); # [0, 0, 15, 15, 29, 0, 0, 7, 0, 7, 10, 10,] Поток (:Thread) Поток — специальный тип данных, который запускает функцию в отдельном потоке, который выполнтеся паралельно основному потоку приложения. Поток созадется в остановленном виде и для его запуска необходимо вызвать метод start(), а чтобы дождаться завершения потока вызывается метод join().\nrand():Int32 := %rand; usleep(usec:DWord64):None := %usleep; printf(format:FmtChar, ...):Int32 := %printf; func(count:Integer, target:String) := { $iter := 1..$count?; # Итератор для диапазона от 1 до $count [ $iter ?! ] \u003c-\u003e { # Цикл, пока итератор валидный $step := $iter!; # Получить текущий и перейти на следующий элемент итератора printf('Number %d from %s!', $step, $target); usleep( rand() % 1000 ); # Случайная задержка } } thread = :Thread(func, 5, 'thread'); thread.start(); func(5, 'main'); thread.join(); Number 1 from the thread! Number 1 from the main! Number 2 from the thread! Number 2 from the main! Number 3 from the thread! Number 4 from the thread! Number 3 from the main! Number 4 from the main! Number 5 from the main! Number 5 from the thread!\nУсловные переменные (condvars). Сходны с событиями, но не являются объектами, занимающими память — используется только адрес переменной, понятие «содержимое переменной» не существует, в качестве условной переменной может использоваться адрес произвольного объекта. В отличие от событий, установка условной переменной в просигнализированное состояние не влечёт за собой никаких последствий в случае, если на данный момент нет потоков, ожидающих на переменной. Установка события в аналогичном случае влечёт за собой запоминание состояния «просигнализировано» внутри самого события, после чего следующие потоки, желающие ожидать события, продолжают исполнение немедленно без остановки. Для полноценного использования такого объекта необходима также операция «освободить mutex и ожидать условную переменную атомарно». Активно используются в UNIX-подобных ОС. Дискуссии о преимуществах и недостатках событий и условных переменных являются заметной частью дискуссий о преимуществах и недостатках Windows и UNIX.\nERESOURCE. Мьютекс, поддерживающий рекурсивный захват, с семантикой разделяемого или эксклюзивного захвата. Семантика: объект может быть либо свободен, либо захвачен произвольным числом потоков разделяемым образом, либо захвачен всего одним потоком эксклюзивным образом. Любые попытки осуществить захваты, нарушающее это правило, приводят к блокировке потока до тех пор, пока объект не освободится так, чтобы сделать захват разрешённым. Также есть операции вида TryToAcquire — никогда не блокирует поток, либо захватывает, либо (если нужна блокировка) возвращает FALSE, ничего не делая. Используется в ядре Windows, особенно в файловых системах — так, например, любому кем-то открытому дисковому файлу соответствует структура FCB, в которой есть 2 таких объекта для синхронизации доступа к размеру файла. Один из них — paging IO resource — захватывается эксклюзивно только в пути обрезания файла, и гарантирует, что в момент обрезания на файле нет активного ввода-вывода от кэша и от отображения в память.\nИнтерфейс операционной системы (:System) Для доступа к различным функциям операционной системы NewLang предоставляет специальный тип данных :System. Он позволяет запускать системные команды и переопределять для них параметры системного окружения.\nВыполнение команды происходит при вызове метода run(), которому нужно передать имя системной команды и при необходимости дополнительные аргументы командной строки.\nРезультат выполнения команды (текстовый вывод, код завершения и т.д.) доступен как отдельные свойства объекта.\nПример:\n:System().run(\"echo\", \"Hello from the other side!\"); os := :System(); home_dir := os.run(\"cd\", \"~\"); printf(\"`cd ~` ran with exit code %d\", os.exitcode()); unknown_dir := os.run(\"cd\", \"doesnotexist\"); printf(\"`cd doesnotexis` ran with exit code %d\", os.exitcode()); Первая строка делает запускает команду echo.\nПотом создается объект :System и далее мы создаем две переменные, в которых хранятся результаты этой выполнения команды cd, которые изменяют каталог на домашнюю папку и на несуществующую папку.\nЗапустив этот файл, мы увидим:\nHello from the other side! `cd ~` ran with exit code 0 sh: line 0: cd: doesnotexist: No such file or directory `cd doesnotexist` ran with exit code 256 Первая строка - результат выполнения команды echo.\nДалее команда cd выполняется успешно и изменяет каталог на домашний. Следовательно, код возврата ноль, который получаем с помощью вызова метода exitcode().\nПоследняя команда cd выполняется с ошибкой, так как пытается изменить каталог на несуществующую папку.\nПростой варинат выполнение системной команды Есть упрощенный вариант выполнения системной команды с помощью заключения строки выполнения в обратные кавычки (как в bash).\n`echo Hello from the other side!`; В этом случае системная команда :System.run() сразу выполняется, а её текстовый вывод сохраняется в текстовую строку с широкими символами (:StrWide).\nЧтобы получить код возврата (например, чтобы проверить результат завершения на ошибки), можно обратится к результату выполнения последней команды $^.exitcode() или сохранить результат выполнения предыдущей команды в отдельную переменню, которая будет иметь тип :System.\n`echo Hello from the other side!`; res := $^; printf(\"`cd doesnotexis` ran with exit code %d\", res.exitcode()); В дальнейшем планируется расширить возможности интерфейса с операционной системой фоновое выполнение программ (useless_cat_call = subprocess.run([“cat”], stdout=subprocess.PIPE, text=True, input=“Hello from the other side”)) переназначение ввода/вывода (list_dir = subprocess.Popen([“ls”, “-l”]); list_dir.wait()) чтение/изменние перемнных окржения Еще пример возможностей для расширения os.name - имя операционной системы. Доступные варианты: ‘posix’, ’nt’, ‘mac’, ‘os2’, ‘ce’, ‘java’. os.environ - словарь переменных окружения. Изменяемый (можно добавлять и удалять переменные окружения). os.getlogin() - имя пользователя, вошедшего в терминал (Unix). os.getpid() - текущий id процесса. os.uname() - информация об ОС. возвращает объект с атрибутами: sysname - имя операционной системы, nodename - имя машины в сети (определяется реализацией), release - релиз, version - версия, machine - идентификатор машины. os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True) - проверка доступа к объекту у текущего пользователя. Флаги: os.F_OK - объект существует, os.R_OK - доступен на чтение, os.W_OK - доступен на запись, os.X_OK - доступен на исполнение. os.chdir(path) - смена текущей директории. os.chmod(path, mode, *, dir_fd=None, follow_symlinks=True) - смена прав доступа к объекту (mode - восьмеричное число). os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True) - меняет id владельца и группы (Unix). os.getcwd() - текущая рабочая директория. os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True) - создаёт жёсткую ссылку. os.listdir(path=\".\") - список файлов и директорий в папке. os.mkdir(path, mode=0o777, *, dir_fd=None) - создаёт директорию. OSError, если директория существует. os.makedirs(path, mode=0o777, exist_ok=False) - создаёт директорию, создавая при этом промежуточные директории. os.remove(path, *, dir_fd=None) - удаляет путь к файлу. os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None) - переименовывает файл или директорию из src в dst. os.renames(old, new) - переименовывает old в new, создавая промежуточные директории. os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None) - переименовывает из src в dst с принудительной заменой. os.rmdir(path, *, dir_fd=None) - удаляет пустую директорию. os.removedirs(path) - удаляет директорию, затем пытается удалить родительские директории, и удаляет их рекурсивно, пока они пусты. os.symlink(source, link_name, target_is_directory=False, *, dir_fd=None) - создаёт символическую ссылку на объект. os.sync() - записывает все данные на диск (Unix). os.truncate(path, length) - обрезает файл до длины length. os.utime(path, times=None, *, ns=None, dir_fd=None, follow_symlinks=True) - модификация времени последнего доступа и изменения файла. Либо times - кортеж (время доступа в секундах, время изменения в секундах), либо ns - кортеж (время доступа в наносекундах, время изменения в наносекундах). os.walk(top, topdown=True, onerror=None, followlinks=False) - генерация имён файлов в дереве каталогов, сверху вниз (если topdown равен True), либо снизу вверх (если False). Для каждого каталога функция walk возвращает кортеж (путь к каталогу, список каталогов, список файлов). os.system(command) - исполняет системную команду, возвращает код её завершения (в случае успеха 0). os.urandom(n) - n случайных байт. Возможно использование этой функции в криптографических целях. ","categories":"","description":"","excerpt":"Пусто (:None) :None (пусто) — не содержит значения (точнее имеет одно …","ref":"/ru/docs/types/other/","tags":["типы данных"],"title":"Другие типы данных"},{"body":"Native (machine) data can be variables or functions, and the names of native objects start with the percent symbol “%”.\nIn the case of variables, these are binary data located in a single continuous area of machine memory at a specific address and have a strictly defined format.\nTo use existing libraries, you need to import the native object, thereby creating an object NewLang, but with an implementation in another language, for example, in C/C++.\nThe syntax for importing native objects is the same as for creating regular language objects, only the name of the native object needs to be specified as the right operand in the creation operator.\nWhen importing a native object, it is necessary to always specify the variable types, as well as the types of arguments and return values for functions.\nIf the data types of the created object and the native object match (i.e., no type conversion is required), then the native object name can be specified with an ellipsis, which means that the data types will replicate those specified at the left operand.\n:FILE ::= :Plain; fopen(filename:StrChar, modes:StrChar):FILE ::= %fopen...; fclose(f:FILE):Int32 ::= %fclose...; fflush(f:FILE):Int32 ::= %fflush...; fprintf(f:FILE, format:FmtChar, ...):Int32 ::= %fprintf...; fremove(filename:String):Int32 ::= %remove...; frename(old:String, new:String):Int32 ::= %rename...; The following description is under development.\n","categories":"","description":"","excerpt":"Native (machine) data can be variables or functions, and the names of …","ref":"/docs/types/native/","tags":["типы данных","системые типы","коллекции"],"title":"Native Data Types"},{"body":"Нативные типы данных Нативными (машинные) данными могут быть как переменные, так и функции, а имя нативных объектов начинается на символ процента “%”.\nВ случае переменных, это двоичные данные, которые располагаются в одной неразрывной области машинной памяти по определенному адресу и имеют строго определенный формат.\nЧтобы использовать уже существующие библиотеки, нужно импортировать нативный объект, тем самым создав объкт NewLang, но с реализацией на другом языке, например на С/С++.\nСинтаксис импорта нативных объектов такой же, как и для создания обычных объектов языка, только в качестве правого операнда в операторе создания требуется указать имя нативнного объекта.\nПри импорте нативного объекта необходимо всегда указывать типы переменных, а также типы аргументов и возвращаемых значений для функций.\nЕсли типы данных у создаваемого и нативного объекта совпадают (т.е. не требуется преобразование типов), то нативное имя объекта можно указать с многоточием, которое означает, что типы данных будут повторять заданные у левого операнда.\n:FILE ::= :Plain; fopen(filename:StrChar, modes:StrChar):FILE ::= %fopen...; fclose(f:FILE):Int32 ::= %fclose...; fflush(f:FILE):Int32 ::= %fflush...; fprintf(f:FILE, format:FmtChar, ...):Int32 ::= %fprintf...; fremove(filename:String):Int32 ::= %remove...; frename(old:String, new:String):Int32 ::= %rename...; Последующее описание находится в процессе разработки.\n:Pointer — указатель на системную область памяти или нативную функцию Так как любой программе приходится взаимодействовать с внешним миром, то по неволе приходится закладывать возможность использования других библиотек и системы типов данных, и для этих целей служит тип :Pointer. Он создается при импорте функций из внешних библиотек и вручную его создать нельзя. Но можно вывести его значение, например для отладки.\n:Plain — указатель на представление данных в бинарном виде Для взаимодействия с внешними библиотеками требуется еще и обмен данными. И для этих целей служит тип данных :Plain — который также является указателем, но на двоичное представление данных в области памяти. Конечно, если их можно представить в виде одного фрагмента.\nПеречисление, структура и объединение :Enum, :Struct и :Union — это такие же словари, только на их элементы накладываются определённые ограничения. Каждый элемент должен иметь уникальное имя, а его тип данных должен быть простым, т.е. числом или строкой фиксированного размера. Эти типы данных так же относятся к группе :Plain и могут быть представлены в двоичном виде в одной области машинной памяти.\n","categories":"","description":"","excerpt":"Нативные типы данных Нативными (машинные) данными могут быть как …","ref":"/ru/docs/types/native/","tags":["типы данных","системые типы","коллекции"],"title":"Нативные типы"},{"body":"Несмотря на динамическую типизацию языка, если тип переменной указан явно, то автоматическое приведение типов не выполняется, и чтобы присвоить переменой значение не совместимого типа, требуется его явное преобразование.\nТак как символьные названия типов относятся к деталям реализации, то явное преобразование в конкретный тип данных производится с помощью вызова функции с именем типа, т.е. :Bool(), :StrWide(), :Int64() и т.д.\nПримеры:\nСтроки и тензоры # Создать тензор из строки широких символов с автоматическим выводом типа #(тип Int32 будет на системах с Linux, а под Windows тип тензора будет Int16) \u003e tstr := :Tensor(\"Тест\"); [1058, 1077, 1089, 1090,]:Int32 # Тоже самое, но тензор заданной размерности \u003e t2 := :Tensor[2,2](\"Тест\"); [ [1058, 1077,], [1089, 1090,], ]:Int32 # Создать символьную строку из тензора \u003e :StrWide(tstr) Тест # Изменить тип данных тензора без изменения размерности \u003e :Float64(t2) [ [1058, 1077,], [1089, 1090,], ]:Float64 # Изменить размерность тензора и его тип # (в данном случае с частичной потерей данных) \u003e t3 := :Int8[4]( t2 ) [34, 53, 65, 66,]:Int8 Словари # Создать тензор из словаря \u003e:Tensor( (1,2,3,) ); [1, 2, 3,]:Int8 # Преобразовать байтовую строку в тензор \u003e:Tensor( 'first second' ) [102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Int8 # Получаем тензор из словаря с такими же данными \u003e:Tensor( ('first', space=32, second='second',) ) [102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Int8 ","categories":"","description":"","excerpt":"Несмотря на динамическую типизацию языка, если тип переменной указан …","ref":"/docs/types/convert/","tags":["типы данных"],"title":"Преобразование типов"},{"body":"Несмотря на динамическую типизацию языка, если тип переменной указан явно, то автоматическое приведение типов не выполняется, и чтобы присвоить переменой значение не совместимого типа, требуется его явное преобразование.\nТак как символьные названия типов относятся к деталям реализации, то явное преобразование в конкретный тип данных производится с помощью вызова функции с именем типа, т.е. :Bool(), :StrWide(), :Int64() и т.д.\nПримеры:\nСтроки и тензоры # Создать тензор из строки широких символов с автоматическим выводом размера и типа данных #(тип Int32 будет на системах с Linux, а под Windows тип тензора будет Int16) \u003e tstr := :Tensor[...](\"Тест\"); [1058, 1077, 1089, 1090,]:Int32 # Тоже самое, но тензор заданной размерности \u003e t2 := :Tensor[2,2](\"Тест\"); [ [1058, 1077,], [1089, 1090,], ]:Int32 # Создать символьную строку из тензора \u003e :StrWide(tstr) Тест # Изменить тип данных тензора без изменения размерности \u003e :Float64[...](t2) [ [1058, 1077,], [1089, 1090,], ]:Float64 # Изменить размерность тензора и его тип # (в данном случае с частичной потерей данных) \u003e t3 := :Int8[4]( t2 ) [34, 53, 65, 66,]:Int8 # Логическое значение - скаляр \u003e:Bool( [0, 53, 65, 66,] ); 1:Bool # Или так (тензор нулевой размерности) \u003e:Bool[0]( [0, 53, 65, 66,] ); 1:Bool # Тензор логических значений без изменения размера \u003e:Bool[_]( [0, 53, 65, 66,] ); [0, 1, 1, 1,]:Bool Словари # Создать тензор из словаря с автоматическим выводом размера \u003e:Tensor[...]( (1,2,3,) ); [1, 2, 3,]:Int8 # Преобразовать байтовую строку в одномерный тензор \u003e:Tensor[_]( 'first second' ) [102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Int8 # Получаем тензор из словаря с такими же данными \u003e:Tensor[...]( ('first', space=32, second='second',) ) [102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Int8 # Логическое значение - скаляр \u003e:Bool( (0,1,2,3,) ); 1:Bool # Тензор логических значений \u003e:Bool[...]( (0,1,2,3,) ); [0, 1, 1, 1]:Bool # Различия между \"...\" и \"_\" # Автоматический вывод размеров измерений \u003e:Tensor[...]( ((1,2,3,), (4,5,6,), (7,8,9,),) ); [ [1, 2, 3,], [4, 5, 6,], [7, 8, 9,] ]:Int8 # Одномерный тензор с произвольным размером \u003e:Tensor[_]( ((1,2,3,), (4,5,6,), (7,8,9,),) ); [ 1, 2, 3, 4, 5, 6, 7, 8, 9,]:Int8 ","categories":"","description":"","excerpt":"Несмотря на динамическую типизацию языка, если тип переменной указан …","ref":"/ru/docs/types/convert/","tags":["типы данных"],"title":"Преобразование типов"},{"body":"Системные свойства Несмотря на то, что не все объекты NewLang являются классами с точки зрения реализованной концепции ООП, тем не менее, каждый объект имеет системные свойства, которые можно считать во время выполнения как обычные свойства объекта:\nУ всех переменных (объектов) есть системные свойства __name__ - краткое имя переменной (объекта)\n__full_name__ - полное имя переменной, включая имя модуля и пространство имен\n__type__ - текущий тип переменной. Может изменится при некоторых операциях\n__type_fixed__ - тип переменной (объекта) который не может измениться (ограничитель)\n__module__ - имя модуля в котором определена переменная (объект)\n__class__ - имя класса переменной или пусто, если объект не является классом\n__base__ - словарь со списком базовых классов или пусто, если объект не является классом\n__size__ - количество элементов у объекта, если применимо или :None\n__doc__ - документация по текущему объекту (если есть, иначе пустая строка)\n__str__ - строковое представление объекта для дампа\n__source__ - исходный текст модуля или функции\nСистемные свойства у модулей __file__ - полный путь к файлу модуля (соответствует С/С++ макросу __FILE__) __timestamp__ - дата и время последней модификации файла модуля (соответствует макросу С/С++ __TIMESTAMP__) __md5__ - хеш исходных данных модуля (соответствует макросу __MD5__) DSL Особенности ассоциативной памяти Синтаксис языка NewLang основан на строгих правилах без использования ключевых слов, и как бы он не выглядел логичным, ассоциация по ключевым словам вспоминается гораздо легче, например if, чем комбинация минус минус правая угловая скобка –\u003e. Из-за этого имеет смысл использовать не “чистый” базовый синтаксис, а более привычный диалект с использованием ключевых слов.\nСинтаксис на ключевых словах В файле dsl.nlp находится набор макросов, которые расширяют базовый синтаксис NewLang, основанный на правилах, набором предопределенных ключевых слов как в классических языках программирования. А при необходимости, их можно адаптировать или дополнить под собственную предметную область.\nКонстанты Логические true - 1 yes - 1 false - 0 no - 0 Системные имена this - Текущий объект ($0) parent - Родительский объект ($$) last - Результат выполнения последнего оператора ($^) !!!!!!!!- args - Все аргументы функции ($*)\n!!!!!!!!- sys - Системный контекст запущенной программы (@@) !!!!!!!!- current - Текущий модуль (@$) !!!!!!!!- cmd - Все аргументы выполняющегося приложения из командной строки (@*)\n!!!!!!!!!!1### Типовые функции и проверки !!!!!!!!!!- run(‘filename’) - Выполнить указанный файл (@@(‘filename’)) !!!!!!!!!!- ifmain - Проверка, если текущий модуль основной ([@$.$0] –\u003e { … }) !!!!!!!!!!- ifload - Проверка, если текущий модуль загружается впервые ([@$.load] –\u003e { … })\nОператоры match(cond) - Оператор оценки выражения\nif(…) - Первый условный оператор ([$*]–\u003e { … })\nelif(…) - Второй и все последующие (,[$*]–\u003e { … })\nelse - Оператор иначе (,[_]–\u003e { … })\nwhile(cond) - Оператор цикла с предусловием ([@$cond] \u003c-\u003e { … } )\ndowhile(cond) - Оператор цикла с постусловием ({ … } \u003c-\u003e[@$cond])\niter(obj, … ) - Создание итератора ( @$obj ? (@$*) )\nnext(obj, … ) - Следующий элемент итератора ( @$obj ! ($*) )\ncurr(obj, … ) - Текущий элемент итератора ( @$obj !? ($*) )\nfirst(obj) - Перейти на первый элемент итератора ( @$obj !! )\nall(obj) - Получить сразу все элементы итератора ( @$obj ??)\nПрерывания return - Положительное прерывание (++)\nreturn(…)- Положительное прерывание с возвратом значения (++ @$value ++)\nerror - Отрицательное прерывание (--)\nerror(…) - Отрицательное прерывание с возвратом значения (-- @$value --)\nbreak+ и break- - Выход из цикла:\nwhile(...) {+ ++ :Break ++ +} while(...) {- -- :Break -- -} continue+ и continue- - В начало цикла: while(...) {+ ++ :Continue ++ +} while(...) {- -- :Continue -- -} obj { .field = 1; .prop(); };\n#Python\n1) without using with statement file = open(‘file_path’, ‘w’) file.write(‘hello world !’) file.close()\n2) without using with statement file = open(‘file_path’, ‘w’) try: file.write(‘hello world’) finally: file.close()\nopen(‘file_path’, ‘w’) { .write(‘hello world !’); .close(); }\nPython3\nusing with statement with open(‘file_path’, ‘w’) as file: file.write(‘hello world !’)\na simple file writer object class MessageWriter(object): def init(self, file_name): self.file_name = file_name\ndef __enter__(self): self.file = open(self.file_name, 'w') return self.file def __exit__(self, *args): self.file.close() using with statement with MessageWriter with MessageWriter(‘my_file.txt’) as xfile: xfile.write(‘hello world’)\na simple file writer object :MessageWriter { def init(self, file_name): self.file_name = file_name\ndef __enter__(self): self.file = open(self.file_name, 'w') return self.file def __exit__(self, *args): self.file.close() }\nusing with statement with MessageWriter MessageWriter(‘my_file.txt’) { .write(‘hello world’); };\nfrom contextlib import contextmanager\nclass MessageWriter(object): def init(self, filename): self.file_name = filename\n@contextmanager def open_file(self): try: file = open(self.file_name, 'w') yield file finally: file.close() usage message_writer = MessageWriter(‘hello.txt’) with message_writer.open_file() as my_file: my_file.write(‘hello world’)\n:MessageWriter(object) { def init(self, filename): self.file_name = filename\n@contextmanager def open_file(self): try: file = open(self.file_name, 'w') yield file finally: file.close() }\nusage message_writer = MessageWriter(‘hello.txt’) with message_writer.open_file() as my_file: my_file.write(‘hello world’)\nПриложения Предопределенные макросы При работе парсера NewLang автоматически формируются несколько зарезервированных макросов, часть из которых соответствуют макросам препроцессора у С/С++. Данные предопределенные макросы можно использовать как обычные константы.\n__FILE__ или __FILE_NAME__ - имя и полный путь текущего файла\n__LINE__ или __FILE_LINE__ - содержит номер текущей строки в файле\n__FILE_TIMESTAMP__ - дату и время последней модификации текущего файла в строковом представлении\n__FILE_MD5__ - md5 хеш текущего файла в строковом виде\n__COUNTER__ - целочисленный счетчик, который увеличивает свое значение при каждом обращении\n__DATE__ - дата начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIME__ - время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIMESTAMP__ - дату и время начала запуска компилятора (например: “Fri 19 Aug 13:32:58 2016”)\n__TIMESTAMP_ISO__ - дату и время начала запуска компилятора в формате ISO (например: “2013-07-06T00:50:06Z”)\n__NLC_VER__ - Страшая и младшая версия компилятора NewLang (8 битное число, по 4 бита на цифру)\n__NLC_DATE_BUILD__ - текстовая строка с датой сборки компилятора NewLang (например, “23.06.04 20:51:39”)\n__NLC_SOURCE_GIT__ - текстовая строка с идентификатором исходных файлов NewLang git репозитория, использованных при сборке компилятора (например, “v0.3.0-fef8c371”)\n__NLC_SOURCE_BUILD__ - дата сборки и git идентификатор исходных файлов NewLang одной текстовой строкой (например, “v0.3.0-fef8c371 23.06.04 20:51:39”)\n","categories":"","description":"","excerpt":"Системные свойства Несмотря на то, что не все объекты NewLang являются …","ref":"/docs/syntax/sysprop/","tags":"","title":"Системные свойства"},{"body":"Системные свойства Несмотря на то, что не все объекты NewLang являются классами с точки зрения реализованной концепции ООП, тем не менее, каждый объект имеет системные свойства, которые можно считать во время выполнения как обычные свойства объекта:\nУ всех переменных (объектов) есть системные свойства __name__ - краткое имя переменной (объекта)\n__full_name__ - полное имя переменной, включая имя модуля и пространство имен\n__type__ - текущий тип переменной. Может изменится при некоторых операциях\n__type_fixed__ - тип переменной (объекта) который не может измениться (ограничитель)\n__module__ - имя модуля в котором определена переменная (объект)\n__class__ - имя класса переменной или пусто, если объект не является классом\n__base__ - словарь со списком базовых классов или пусто, если объект не является классом\n__size__ - количество элементов у объекта, если применимо или :None\n__doc__ - документация по текущему объекту (если есть, иначе пустая строка)\n__str__ - строковое представление объекта для дампа\n__source__ - исходный текст модуля или функции\nСистемные свойства у модулей __file__ - полный путь к файлу модуля (соответствует С/С++ макросу __FILE__) __timestamp__ - дата и время последней модификации файла модуля (соответствует макросу С/С++ __TIMESTAMP__) __md5__ - хеш исходных данных модуля (соответствует макросу __MD5__) DSL Особенности ассоциативной памяти Синтаксис языка NewLang основан на строгих правилах без использования ключевых слов, и как бы он не выглядел логичным, ассоциация по ключевым словам вспоминается гораздо легче, например if, чем комбинация минус минус правая угловая скобка –\u003e. Из-за этого имеет смысл использовать не “чистый” базовый синтаксис, а более привычный диалект с использованием ключевых слов.\nСинтаксис на ключевых словах В файле dsl.nlp находится набор макросов, которые расширяют базовый синтаксис NewLang, основанный на правилах, набором предопределенных ключевых слов как в классических языках программирования. А при необходимости, их можно адаптировать или дополнить под собственную предметную область.\nКонстанты Логические true - 1 yes - 1 false - 0 no - 0 Системные имена this - Текущий объект ($0) parent - Родительский объект ($$) last - Результат выполнения последнего оператора ($^) !!!!!!!!- args - Все аргументы функции ($*)\n!!!!!!!!- sys - Системный контекст запущенной программы (@@) !!!!!!!!- current - Текущий модуль (@$) !!!!!!!!- cmd - Все аргументы выполняющегося приложения из командной строки (@*)\n!!!!!!!!!!1### Типовые функции и проверки !!!!!!!!!!- run(‘filename’) - Выполнить указанный файл (@@(‘filename’)) !!!!!!!!!!- ifmain - Проверка, если текущий модуль основной ([@$.$0] –\u003e { … }) !!!!!!!!!!- ifload - Проверка, если текущий модуль загружается впервые ([@$.load] –\u003e { … })\nОператоры match(cond) - Оператор оценки выражения\nif(…) - Первый условный оператор ([$*]–\u003e { … })\nelif(…) - Второй и все последующие (,[$*]–\u003e { … })\nelse - Оператор иначе (,[_]–\u003e { … })\nwhile(cond) - Оператор цикла с предусловием ([@$cond] \u003c-\u003e { … } )\ndowhile(cond) - Оператор цикла с постусловием ({ … } \u003c-\u003e[@$cond])\niter(obj, … ) - Создание итератора ( @$obj ? (@$*) )\nnext(obj, … ) - Следующий элемент итератора ( @$obj ! ($*) )\ncurr(obj, … ) - Текущий элемент итератора ( @$obj !? ($*) )\nfirst(obj) - Перейти на первый элемент итератора ( @$obj !! )\nall(obj) - Получить сразу все элементы итератора ( @$obj ??)\nПрерывания return - Положительное прерывание (++)\nreturn(…)- Положительное прерывание с возвратом значения (++ @$value ++)\nerror - Отрицательное прерывание (--)\nerror(…) - Отрицательное прерывание с возвратом значения (-- @$value --)\nbreak+ и break- - Выход из цикла:\nwhile(...) {+ ++ :Break ++ +} while(...) {- -- :Break -- -} continue+ и continue- - В начало цикла: while(...) {+ ++ :Continue ++ +} while(...) {- -- :Continue -- -} obj { .field = 1; .prop(); };\n#Python\n1) without using with statement file = open(‘file_path’, ‘w’) file.write(‘hello world !’) file.close()\n2) without using with statement file = open(‘file_path’, ‘w’) try: file.write(‘hello world’) finally: file.close()\nopen(‘file_path’, ‘w’) { .write(‘hello world !’); .close(); }\nPython3\nusing with statement with open(‘file_path’, ‘w’) as file: file.write(‘hello world !’)\na simple file writer object class MessageWriter(object): def init(self, file_name): self.file_name = file_name\ndef __enter__(self): self.file = open(self.file_name, 'w') return self.file def __exit__(self, *args): self.file.close() using with statement with MessageWriter with MessageWriter(‘my_file.txt’) as xfile: xfile.write(‘hello world’)\na simple file writer object :MessageWriter { def init(self, file_name): self.file_name = file_name\ndef __enter__(self): self.file = open(self.file_name, 'w') return self.file def __exit__(self, *args): self.file.close() }\nusing with statement with MessageWriter MessageWriter(‘my_file.txt’) { .write(‘hello world’); };\nfrom contextlib import contextmanager\nclass MessageWriter(object): def init(self, filename): self.file_name = filename\n@contextmanager def open_file(self): try: file = open(self.file_name, 'w') yield file finally: file.close() usage message_writer = MessageWriter(‘hello.txt’) with message_writer.open_file() as my_file: my_file.write(‘hello world’)\n:MessageWriter(object) { def init(self, filename): self.file_name = filename\n@contextmanager def open_file(self): try: file = open(self.file_name, 'w') yield file finally: file.close() }\nusage message_writer = MessageWriter(‘hello.txt’) with message_writer.open_file() as my_file: my_file.write(‘hello world’)\nПриложения Предопределенные макросы При работе парсера NewLang автоматически формируются несколько зарезервированных макросов, часть из которых соответствуют макросам препроцессора у С/С++. Данные предопределенные макросы можно использовать как обычные константы.\n__FILE__ или __FILE_NAME__ - имя и полный путь текущего файла\n__LINE__ или __FILE_LINE__ - содержит номер текущей строки в файле\n__FILE_TIMESTAMP__ - дату и время последней модификации текущего файла в строковом представлении\n__FILE_MD5__ - md5 хеш текущего файла в строковом виде\n__COUNTER__ - целочисленный счетчик, который увеличивает свое значение при каждом обращении\n__DATE__ - дата начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIME__ - время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIMESTAMP__ - дату и время начала запуска компилятора (например: “Fri 19 Aug 13:32:58 2016”)\n__TIMESTAMP_ISO__ - дату и время начала запуска компилятора в формате ISO (например: “2013-07-06T00:50:06Z”)\n__NLC_VER__ - Страшая и младшая версия компилятора NewLang (8 битное число, по 4 бита на цифру)\n__NLC_DATE_BUILD__ - текстовая строка с датой сборки компилятора NewLang (например, “23.06.04 20:51:39”)\n__NLC_SOURCE_GIT__ - текстовая строка с идентификатором исходных файлов NewLang git репозитория, использованных при сборке компилятора (например, “v0.3.0-fef8c371”)\n__NLC_SOURCE_BUILD__ - дата сборки и git идентификатор исходных файлов NewLang одной текстовой строкой (например, “v0.3.0-fef8c371 23.06.04 20:51:39”)\n","categories":"","description":"","excerpt":"Системные свойства Несмотря на то, что не все объекты NewLang являются …","ref":"/ru/docs/syntax/sysprop/","tags":"","title":"Системные свойства"},{"body":"В качестве оператора проверки условия используется синтаксическая конструкция, которая соответствует по смыслу термину «следует», т.е. два тире и угловая скобка --\u003e. Такая запись условного оператора очень похожа на математическую и легко объединяется в последовательности для проверки множественных условий вида «else if».\nВ общем случае условный оператор имеет вид: [ условие ] --\u003e { действие }; или с условием иначе [ условие ] --\u003e { действие }, […] --\u003e { действие иначе };\nДля наглядности записанный с отступами:\n[ условие1 ] --\u003e { действие1 }, [ условие2 ] --\u003e действие2, [ условие3 ] --\u003e действие3, [...] --\u003e {действие_иначе}; Или тоже самое, но с использованием макросов DSL.:\n@if( условие1 ) { действие1 } @elif( условие2 ) действие2 @elif( условие3 ) действие3 @else { действие_иначе }; ","categories":"","description":"","excerpt":"В качестве оператора проверки условия используется синтаксическая …","ref":"/docs/ops/if/","tags":"","title":"Условный оператор"},{"body":"В качестве оператора проверки условия используется синтаксическая конструкция, которая соответствует по смыслу термину «следует», т.е. два тире и угловая скобка --\u003e. Такая запись условного оператора очень похожа на математическую и легко объединяется в последовательности для проверки множественных условий вида «else if».\nВ общем случае условный оператор имеет вид: [ условие ] --\u003e { действие }; или с условием иначе [ условие ] --\u003e { действие }, […] --\u003e { действие иначе };\nДля наглядности записанный с отступами:\n[ условие1 ] --\u003e { действие1 }, [ условие2 ] --\u003e действие2, [ условие3 ] --\u003e действие3, [...] --\u003e {действие_иначе}; Или тоже самое, но с использованием макросов DSL.:\n@if( условие1 ) { действие1 } @elif( условие2 ) действие2 @elif( условие3 ) действие3 @else { действие_иначе }; ","categories":"","description":"","excerpt":"В качестве оператора проверки условия используется синтаксическая …","ref":"/ru/docs/ops/if/","tags":"","title":"Условный оператор"},{"body":"Прагмы Предварительное объевления объектов @__PRAGMA_DECLARE__\n@__PRAGMA_DECLARE__( func(arg) ); Импорт нативной функции / переменной @__PRAGMA_NATIVE__\n// import native int printf(char *format, ...) @__PRAGMA_NATIVE__( printf(format:FmtChar, ...):Int32 ); Управление диагностикой компилятора @__PRAGMA_DIAG__ -\n@__PRAGMA_DIAG__(push) @__PRAGMA_DIAG__(ignored, \"-Wundef\") @__PRAGMA_DIAG__(warning, \"-Wformat\" , \"-Wundef\", \"-Wuninitialized\") @__PRAGMA_DIAG__(error, \"-Wuninitialized\") @__PRAGMA_DIAG__(pop) @__PRAGMA_MESSAGE__\n#pragma message \"Compiling \" __FILE__ \"...\" @__PRAGMA_MESSAGE__(\"Compiling \", __FILE__, \"...\") #define DO_PRAGMA(x) _Pragma (#x) #define TODO(x) DO_PRAGMA(message (\"TODO - \" #x)) @@TODO( ... )@@ := @__PRAGMA_MESSAGE__(\"TODO - \", @#...) @TODO(Remember to fix this) # note: TODO - Remember to fix this @__PRAGMA_WARNING__ @__PRAGMA_ERROR__\n@__PRAGMA_LOCATION__ // #line 303 \"location.hh\" // Prototype - @__PRAGMA_LOCATION__( pop ) // Prototype - @__PRAGMA_LOCATION__( push ) or @__PRAGMA_LOCATION__( push, 'filename') or @__PRAGMA_LOCATION__( push, 'filename', line) // Prototype - @__PRAGMA_LOCATION__( line ) or @__PRAGMA_LOCATION__( line, 'filename') Управление макросами @__PRAGMA_EXPECTED__ - Следующий символ должен быть одним из списка\n@__PRAGMA_EXPECTED__( @\\ {, @\\ {*, @\\ {+ ) { } @__PRAGMA_EXPECTED__( @\\ {, @\\ {*, @\\ {+) {+ +} @__PRAGMA_UNEXPECTED__ - Запретить использование перечисленных символов\n@__PRAGMA_UNEXPECTED__( @\\{, @\\{*, @\\{+) {- -} @__PRAGMA_UNEXPECTED__( @\\{*, @\\{+) { } @__PRAGMA_NO_MACRO__ - Следующий символ не макрос\nАннотации @__ANNOTATION_SET__\n@__ANNOTATION_SET__(name) @__ANNOTATION_SET__(name, \"value\") @__ANNOTATION_SET__(name, 1) @__ANNOTATION_IIF__\nНе используется (заготовки на будущее) @__PRAGMA_IGNORE__\nstatic const char * ignore_space = \"space\"; static const char * ignore_indent = \"indent\"; static const char * ignore_comment = \"comment\"; static const char * ignore_crlf = \"crlf\"; @__PRAGMA_INDENT_BLOCK__\n@__PRAGMA_MACRO__ -\n@__PRAGMA_MACRO_COND__\n@__PRAGMA_FINALIZE__\n","categories":"","description":"","excerpt":"Прагмы Предварительное объевления объектов @__PRAGMA_DECLARE__ …","ref":"/docs/syntax/pragmas/","tags":"","title":"Опции и настройки компилятора"},{"body":"Прагмы Предварительное объевления объектов @__PRAGMA_DECLARE__\n@__PRAGMA_DECLARE__( func(arg) ); Импорт нативной функции / переменной @__PRAGMA_NATIVE__\n// import native int printf(char *format, ...) @__PRAGMA_NATIVE__( printf(format:FmtChar, ...):Int32 ); Управление диагностикой компилятора @__PRAGMA_DIAG__ -\n@__PRAGMA_DIAG__(push) @__PRAGMA_DIAG__(ignored, \"-Wundef\") @__PRAGMA_DIAG__(warning, \"-Wformat\" , \"-Wundef\", \"-Wuninitialized\") @__PRAGMA_DIAG__(error, \"-Wuninitialized\") @__PRAGMA_DIAG__(pop) @__PRAGMA_MESSAGE__\n#pragma message \"Compiling \" __FILE__ \"...\" @__PRAGMA_MESSAGE__(\"Compiling \", __FILE__, \"...\") #define DO_PRAGMA(x) _Pragma (#x) #define TODO(x) DO_PRAGMA(message (\"TODO - \" #x)) @@TODO( ... )@@ := @__PRAGMA_MESSAGE__(\"TODO - \", @#...) @TODO(Remember to fix this) # note: TODO - Remember to fix this @__PRAGMA_WARNING__ @__PRAGMA_ERROR__\n@__PRAGMA_LOCATION__ // #line 303 \"location.hh\" // Prototype - @__PRAGMA_LOCATION__( pop ) // Prototype - @__PRAGMA_LOCATION__( push ) or @__PRAGMA_LOCATION__( push, 'filename') or @__PRAGMA_LOCATION__( push, 'filename', line) // Prototype - @__PRAGMA_LOCATION__( line ) or @__PRAGMA_LOCATION__( line, 'filename') Управление макросами @__PRAGMA_EXPECTED__ - Следующий символ должен быть одним из списка\n@__PRAGMA_EXPECTED__( @\\ {, @\\ {*, @\\ {+ ) { } @__PRAGMA_EXPECTED__( @\\ {, @\\ {*, @\\ {+) {+ +} @__PRAGMA_UNEXPECTED__ - Запретить использование перечисленных символов\n@__PRAGMA_UNEXPECTED__( @\\{, @\\{*, @\\{+) {- -} @__PRAGMA_UNEXPECTED__( @\\{*, @\\{+) { } @__PRAGMA_NO_MACRO__ - Следующий символ не макрос\nАннотации @__ANNOTATION_SET__\n@__ANNOTATION_SET__(name) @__ANNOTATION_SET__(name, \"value\") @__ANNOTATION_SET__(name, 1) @__ANNOTATION_IIF__\nНе используется (заготовки на будущее) @__PRAGMA_IGNORE__\nstatic const char * ignore_space = \"space\"; static const char * ignore_indent = \"indent\"; static const char * ignore_comment = \"comment\"; static const char * ignore_crlf = \"crlf\"; @__PRAGMA_INDENT_BLOCK__\n@__PRAGMA_MACRO__ -\n@__PRAGMA_MACRO_COND__\n@__PRAGMA_FINALIZE__\n","categories":"","description":"","excerpt":"Прагмы Предварительное объевления объектов @__PRAGMA_DECLARE__ …","ref":"/ru/docs/syntax/pragmas/","tags":"","title":"Опции и настройки компилятора"},{"body":"DSL Особенности ассоциативной памяти Синтаксис языка NewLang основан на строгих правилах без использования ключевых слов, и как бы он не выглядел логичным, ассоциация по ключевым словам вспоминается гораздо легче, например if, чем комбинация минус минус правая угловая скобка –\u003e. Из-за этого имеет смысл использовать не “чистый” базовый синтаксис, а более привычный диалект с использованием ключевых слов.\nСинтаксис на ключевых словах В файле dsl.nlp находится набор макросов, которые расширяют базовый синтаксис NewLang, основанный на правилах, набором предопределенных ключевых слов как в классических языках программирования. А при необходимости, их можно адаптировать или дополнить под собственную предметную область.\nКонстанты Логические true - 1 yes - 1 false - 0 no - 0 Системные имена this - Текущий объект ($0) parent - Родительский объект ($$) last - Результат выполнения последнего оператора ($^) !!!!!!!!- args - Все аргументы функции ($*)\n!!!!!!!!- sys - Системный контекст запущенной программы (@@) !!!!!!!!- current - Текущий модуль (@$) !!!!!!!!- cmd - Все аргументы выполняющегося приложения из командной строки (@*)\n!!!!!!!!!!1### Типовые функции и проверки !!!!!!!!!!- run(‘filename’) - Выполнить указанный файл (@@(‘filename’)) !!!!!!!!!!- ifmain - Проверка, если текущий модуль основной ([@$.$0] –\u003e { … }) !!!!!!!!!!- ifload - Проверка, если текущий модуль загружается впервые ([@$.load] –\u003e { … })\nОператоры match(cond) - Оператор оценки выражения\nif(…) - Первый условный оператор ([$*]–\u003e { … })\nelif(…) - Второй и все последующие (,[$*]–\u003e { … })\nelse - Оператор иначе (,[_]–\u003e { … })\nwhile(cond) - Оператор цикла с предусловием ([@$cond] \u003c-\u003e { … } )\ndowhile(cond) - Оператор цикла с постусловием ({ … } \u003c-\u003e[@$cond])\niter(obj, … ) - Создание итератора ( @$obj ? (@$*) )\nnext(obj, … ) - Следующий элемент итератора ( @$obj ! ($*) )\ncurr(obj, … ) - Текущий элемент итератора ( @$obj !? ($*) )\nfirst(obj) - Перейти на первый элемент итератора ( @$obj !! )\nall(obj) - Получить сразу все элементы итератора ( @$obj ??)\nПрерывания return - Положительное прерывание (++)\nreturn(…)- Положительное прерывание с возвратом значения (++ @$value ++)\nerror - Отрицательное прерывание (--)\nerror(…) - Отрицательное прерывание с возвратом значения (-- @$value --)\nbreak+ и break- - Выход из цикла:\nwhile(...) {+ ++ :Break ++ +} while(...) {- -- :Break -- -} continue+ и continue- - В начало цикла: while(...) {+ ++ :Continue ++ +} while(...) {- -- :Continue -- -} obj { .field = 1; .prop(); };\n#Python\n1) without using with statement file = open(‘file_path’, ‘w’) file.write(‘hello world !’) file.close()\n2) without using with statement file = open(‘file_path’, ‘w’) try: file.write(‘hello world’) finally: file.close()\nopen(‘file_path’, ‘w’) { .write(‘hello world !’); .close(); }\nPython3\nusing with statement with open(‘file_path’, ‘w’) as file: file.write(‘hello world !’)\na simple file writer object class MessageWriter(object): def init(self, file_name): self.file_name = file_name\ndef __enter__(self): self.file = open(self.file_name, 'w') return self.file def __exit__(self, *args): self.file.close() using with statement with MessageWriter with MessageWriter(‘my_file.txt’) as xfile: xfile.write(‘hello world’)\na simple file writer object :MessageWriter { def init(self, file_name): self.file_name = file_name\ndef __enter__(self): self.file = open(self.file_name, 'w') return self.file def __exit__(self, *args): self.file.close() }\nusing with statement with MessageWriter MessageWriter(‘my_file.txt’) { .write(‘hello world’); };\nfrom contextlib import contextmanager\nclass MessageWriter(object): def init(self, filename): self.file_name = filename\n@contextmanager def open_file(self): try: file = open(self.file_name, 'w') yield file finally: file.close() usage message_writer = MessageWriter(‘hello.txt’) with message_writer.open_file() as my_file: my_file.write(‘hello world’)\n:MessageWriter(object) { def init(self, filename): self.file_name = filename\n@contextmanager def open_file(self): try: file = open(self.file_name, 'w') yield file finally: file.close() }\nusage message_writer = MessageWriter(‘hello.txt’) with message_writer.open_file() as my_file: my_file.write(‘hello world’)\nПриложения Предопределенные макросы При работе парсера NewLang автоматически формируются несколько зарезервированных макросов, часть из которых соответствуют макросам препроцессора у С/С++. Данные предопределенные макросы можно использовать как обычные константы.\n__FILE__ или __FILE_NAME__ - имя и полный путь текущего файла\n__LINE__ или __FILE_LINE__ - содержит номер текущей строки в файле\n__FILE_TIMESTAMP__ - дату и время последней модификации текущего файла в строковом представлении\n__FILE_MD5__ - md5 хеш текущего файла в строковом виде\n__COUNTER__ - целочисленный счетчик, который увеличивает свое значение при каждом обращении\n__DATE__ - дата начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIME__ - время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIMESTAMP__ - дату и время начала запуска компилятора (например: “Fri 19 Aug 13:32:58 2016”)\n__TIMESTAMP_ISO__ - дату и время начала запуска компилятора в формате ISO (например: “2013-07-06T00:50:06Z”)\n__NLC_VER__ - Страшая и младшая версия компилятора NewLang (8 битное число, по 4 бита на цифру)\n__NLC_DATE_BUILD__ - текстовая строка с датой сборки компилятора NewLang (например, “23.06.04 20:51:39”)\n__NLC_SOURCE_GIT__ - текстовая строка с идентификатором исходных файлов NewLang git репозитория, использованных при сборке компилятора (например, “v0.3.0-fef8c371”)\n__NLC_SOURCE_BUILD__ - дата сборки и git идентификатор исходных файлов NewLang одной текстовой строкой (например, “v0.3.0-fef8c371 23.06.04 20:51:39”)\n","categories":"","description":"","excerpt":"DSL Особенности ассоциативной памяти Синтаксис языка NewLang основан …","ref":"/docs/syntax/sysmacro/","tags":"","title":"Системные макросы"},{"body":"DSL Особенности ассоциативной памяти Синтаксис языка NewLang основан на строгих правилах без использования ключевых слов, и как бы он не выглядел логичным, ассоциация по ключевым словам вспоминается гораздо легче, например if, чем комбинация минус минус правая угловая скобка –\u003e. Из-за этого имеет смысл использовать не “чистый” базовый синтаксис, а более привычный диалект с использованием ключевых слов.\nСинтаксис на ключевых словах В файле dsl.nlp находится набор макросов, которые расширяют базовый синтаксис NewLang, основанный на правилах, набором предопределенных ключевых слов как в классических языках программирования. А при необходимости, их можно адаптировать или дополнить под собственную предметную область.\nКонстанты Логические true - 1 yes - 1 false - 0 no - 0 Системные имена this - Текущий объект ($0) parent - Родительский объект ($$) last - Результат выполнения последнего оператора ($^) !!!!!!!!- args - Все аргументы функции ($*)\n!!!!!!!!- sys - Системный контекст запущенной программы (@@) !!!!!!!!- current - Текущий модуль (@$) !!!!!!!!- cmd - Все аргументы выполняющегося приложения из командной строки (@*)\n!!!!!!!!!!1### Типовые функции и проверки !!!!!!!!!!- run(‘filename’) - Выполнить указанный файл (@@(‘filename’)) !!!!!!!!!!- ifmain - Проверка, если текущий модуль основной ([@$.$0] –\u003e { … }) !!!!!!!!!!- ifload - Проверка, если текущий модуль загружается впервые ([@$.load] –\u003e { … })\nОператоры match(cond) - Оператор оценки выражения\nif(…) - Первый условный оператор ([$*]–\u003e { … })\nelif(…) - Второй и все последующие (,[$*]–\u003e { … })\nelse - Оператор иначе (,[_]–\u003e { … })\nwhile(cond) - Оператор цикла с предусловием ([@$cond] \u003c-\u003e { … } )\ndowhile(cond) - Оператор цикла с постусловием ({ … } \u003c-\u003e[@$cond])\niter(obj, … ) - Создание итератора ( @$obj ? (@$*) )\nnext(obj, … ) - Следующий элемент итератора ( @$obj ! ($*) )\ncurr(obj, … ) - Текущий элемент итератора ( @$obj !? ($*) )\nfirst(obj) - Перейти на первый элемент итератора ( @$obj !! )\nall(obj) - Получить сразу все элементы итератора ( @$obj ??)\nПрерывания return - Положительное прерывание (++)\nreturn(…)- Положительное прерывание с возвратом значения (++ @$value ++)\nerror - Отрицательное прерывание (--)\nerror(…) - Отрицательное прерывание с возвратом значения (-- @$value --)\nbreak+ и break- - Выход из цикла:\nwhile(...) {+ ++ :Break ++ +} while(...) {- -- :Break -- -} continue+ и continue- - В начало цикла: while(...) {+ ++ :Continue ++ +} while(...) {- -- :Continue -- -} obj { .field = 1; .prop(); };\n#Python\n1) without using with statement file = open(‘file_path’, ‘w’) file.write(‘hello world !’) file.close()\n2) without using with statement file = open(‘file_path’, ‘w’) try: file.write(‘hello world’) finally: file.close()\nopen(‘file_path’, ‘w’) { .write(‘hello world !’); .close(); }\nPython3\nusing with statement with open(‘file_path’, ‘w’) as file: file.write(‘hello world !’)\na simple file writer object class MessageWriter(object): def init(self, file_name): self.file_name = file_name\ndef __enter__(self): self.file = open(self.file_name, 'w') return self.file def __exit__(self, *args): self.file.close() using with statement with MessageWriter with MessageWriter(‘my_file.txt’) as xfile: xfile.write(‘hello world’)\na simple file writer object :MessageWriter { def init(self, file_name): self.file_name = file_name\ndef __enter__(self): self.file = open(self.file_name, 'w') return self.file def __exit__(self, *args): self.file.close() }\nusing with statement with MessageWriter MessageWriter(‘my_file.txt’) { .write(‘hello world’); };\nfrom contextlib import contextmanager\nclass MessageWriter(object): def init(self, filename): self.file_name = filename\n@contextmanager def open_file(self): try: file = open(self.file_name, 'w') yield file finally: file.close() usage message_writer = MessageWriter(‘hello.txt’) with message_writer.open_file() as my_file: my_file.write(‘hello world’)\n:MessageWriter(object) { def init(self, filename): self.file_name = filename\n@contextmanager def open_file(self): try: file = open(self.file_name, 'w') yield file finally: file.close() }\nusage message_writer = MessageWriter(‘hello.txt’) with message_writer.open_file() as my_file: my_file.write(‘hello world’)\nПриложения Предопределенные макросы При работе парсера NewLang автоматически формируются несколько зарезервированных макросов, часть из которых соответствуют макросам препроцессора у С/С++. Данные предопределенные макросы можно использовать как обычные константы.\n__FILE__ или __FILE_NAME__ - имя и полный путь текущего файла\n__LINE__ или __FILE_LINE__ - содержит номер текущей строки в файле\n__FILE_TIMESTAMP__ - дату и время последней модификации текущего файла в строковом представлении\n__FILE_MD5__ - md5 хеш текущего файла в строковом виде\n__COUNTER__ - целочисленный счетчик, который увеличивает свое значение при каждом обращении\n__DATE__ - дата начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIME__ - время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIMESTAMP__ - дату и время начала запуска компилятора (например: “Fri 19 Aug 13:32:58 2016”)\n__TIMESTAMP_ISO__ - дату и время начала запуска компилятора в формате ISO (например: “2013-07-06T00:50:06Z”)\n__NLC_VER__ - Страшая и младшая версия компилятора NewLang (8 битное число, по 4 бита на цифру)\n__NLC_DATE_BUILD__ - текстовая строка с датой сборки компилятора NewLang (например, “23.06.04 20:51:39”)\n__NLC_SOURCE_GIT__ - текстовая строка с идентификатором исходных файлов NewLang git репозитория, использованных при сборке компилятора (например, “v0.3.0-fef8c371”)\n__NLC_SOURCE_BUILD__ - дата сборки и git идентификатор исходных файлов NewLang одной текстовой строкой (например, “v0.3.0-fef8c371 23.06.04 20:51:39”)\n","categories":"","description":"","excerpt":"DSL Особенности ассоциативной памяти Синтаксис языка NewLang основан …","ref":"/ru/docs/syntax/sysmacro/","tags":"","title":"Системные макросы"},{"body":"Features of associative memory The syntax of the NewLang language is based on strict rules without the use of keywords, and no matter how logical it may seem, association by keywords is much easier to remember, for example, if, than the combination minus minus right angle bracket –\u003e. Because of this, it makes sense to use not a “pure” basic syntax, but a more familiar dialect with the use of keywords.\nNewLang already contains a set of macros that extend the basic rule-based syntax of NewLang, a set of predefined keywords as in classical programming languages, which can be adapted or supplemented to suit your own subject area.\nConstants @true - 1\n@yes - 1\n@false - 0\n@no - 0\n@this или @self - Current object\n@super - Parent object\n@latter or @last- Result of the last operation\nLogical operators @and - Logical AND @or - Logical OR @xor - Logical Exclusive OR @not(value) - Logical negation Operators @if(…) - First conditional statement\n@elif(…) - Second and all subsequent conditional statements\n@else - Operator otherwise\n@while(…) - Loop operator with precondition\n@dowhile(…) - Loop operator with postcondition\n@loop - Infinite loop operator\n@break $label - Operator to break out of a named named block of code\n@continue $label - Jump operator to the beginning of a named block of code\n@return( result ) - Operator for returning a value and exiting a function\n@throw( error ) - Operator for creating an exception and returning an error\n@match( … ) - Expression evaluation operator\n@case( … ) - Pattern comparison operator\n@default - Selection operator\n@iter(obj, … ) - Creating an iterator\n@next(obj, … ) - Get the next element of the iterator\n@curr(obj, … ) - Get the current iterator element\n@first(obj) - Go to the first element of the iterator\n@all(obj) - Get all elements of the iterator at once\nPredefined macros When the NewLang parser is running, several reserved macros are automatically generated, some of which correspond to preprocessor macros in C/C++. These predefined macros can be used as regular constants.\n__FILE__ or __FILE_NAME__ - name and full path of the current file\n__LINE__ or __FILE_LINE__ - contains the number of the current line in the file\n__FILE_TIMESTAMP__ - date and time of the last modification of the current file in string representation\n__FILE_MD5__ - md5 hash of the current file in string form\n__COUNTER__ - an integer counter that increases its value with each access\n__DATE__ - start date of the compiler launch (has the same value for all processed files)\n__TIME__ - start time of the compiler launch (has the same value for all processed files)\n__TIMESTAMP__ - date and time when the compiler started running (for example: “Fri 19 Aug 13:32:58 2016”)\n__TIMESTAMP_ISO__ - date and time when the compiler started running in ISO format (for example: “2013-07-06T00:50:06Z”)\n__NLC_VER__ - Older and younger version of the NewLang compiler (8-bit number, 4 bits per digit)\n__NLC_DATE_BUILD__ - text string with the build date of the NewLang compiler (for example, “06/23/04 20:51:39”)\n__NLC_SOURCE_GIT__ - text string with the identifier of the NewLang git repository source files used to build the compiler (for example, “v0.3.0-fef8c371”)\n__NLC_SOURCE_BUILD__ - build date and git identifier of NewLang source files in one text line (for example, “v0.3.0-fef8c371 06/23/04 20:51:39”)\n","categories":"","description":"","excerpt":"Features of associative memory The syntax of the NewLang language is …","ref":"/docs/syntax/dsl/","tags":"","title":"Keyword syntax (DSL)"},{"body":"Особенности ассоциативной памяти Синтаксис языка NewLang основан на строгих правилах без использования ключевых слов, и как бы он не выглядел логичным, ассоциация по ключевым словам вспоминается гораздо легче, например if, чем комбинация минус минус правая угловая скобка –\u003e. Из-за этого имеет смысл использовать не “чистый” базовый синтаксис, а более привычный диалект с использованием ключевых слов.\nNewLang уже содержит набор макросов, которые расширяют базовый синтаксис NewLang, основанный на правилах, набором предопределенных ключевых слов как в классических языках программирования, которые можно адаптировать или дополнить под собственную предметную область.\nКонстанты @true - 1\n@yes - 1\n@false - 0\n@no - 0\n@this или @self - Текущий объект\n@super - Родительский объект\n@latter или @last- Результат выполенения последнего оператора Result of the last operation\nЛогические операторы @and - Логическое И @or - Логическое ИЛИ @xor - Логическое Исключающее ИЛИ @not(value) - Логическое отрицание Операторы @if(…) - Первый условный оператор\n@elif(…) - Второй и все последующие условные операторы\n@else - Оператор иначе\n@while(…) - Оператор цикла с предусловием\n@dowhile(…) - Оператор цикла с постусловием\n@loop - Оператор безконечного цикла\n@break $label - Оператор выхода из именованного именованного блока кода\n@continue $label - Оператор прехода на начало именованного блока кода\n@return( result ) - Оператор возврата значения и выхода из функции\n@throw( error ) - Оператор создания исключения и возврата ошибки\n@match( … ) - Оператор оценки выражения\n@case( … ) - Оператор сравнения с образцом\n@default - Оператор выбора по улочанию\n@iter(obj, … ) - Создание итератора\n@next(obj, … ) - Получить следующий элемент итератора\n@curr(obj, … ) - Получить текущий элемент итератора\n@first(obj) - Перейти на первый элемент итератора\n@all(obj) - Получить сразу все элементы итератора\nПредопределенные макросы При работе парсера NewLang автоматически формируются несколько зарезервированных макросов, часть из которых соответствуют макросам препроцессора у С/С++. Данные предопределенные макросы можно использовать как обычные константы.\n__FILE__ или __FILE_NAME__ - имя и полный путь текущего файла\n__LINE__ или __FILE_LINE__ - содержит номер текущей строки в файле\n__FILE_TIMESTAMP__ - дату и время последней модификации текущего файла в строковом представлении\n__FILE_MD5__ - md5 хеш текущего файла в строковом виде\n__COUNTER__ - целочисленный счетчик, который увеличивает свое значение при каждом обращении\n__DATE__ - дата начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIME__ - время начала запуска компилятора (имеет одно и тоже значение для всех обрабатываемых файлов)\n__TIMESTAMP__ - дату и время начала запуска компилятора (например: “Fri 19 Aug 13:32:58 2016”)\n__TIMESTAMP_ISO__ - дату и время начала запуска компилятора в формате ISO (например: “2013-07-06T00:50:06Z”)\n__NLC_VER__ - Страшая и младшая версия компилятора NewLang (8 битное число, по 4 бита на цифру)\n__NLC_DATE_BUILD__ - текстовая строка с датой сборки компилятора NewLang (например, “23.06.04 20:51:39”)\n__NLC_SOURCE_GIT__ - текстовая строка с идентификатором исходных файлов NewLang git репозитория, использованных при сборке компилятора (например, “v0.3.0-fef8c371”)\n__NLC_SOURCE_BUILD__ - дата сборки и git идентификатор исходных файлов NewLang одной текстовой строкой (например, “v0.3.0-fef8c371 23.06.04 20:51:39”)\n","categories":"","description":"","excerpt":"Особенности ассоциативной памяти Синтаксис языка NewLang основан на …","ref":"/ru/docs/syntax/dsl/","tags":"","title":"Keyword syntax (DSL)"},{"body":"Синтаксическая конструкция с помощью которой реализуется примерный аналог оператора switch или match выглядит следующим образом:\n[ $var ] ==\u003e { [1] --\u003e { code }; # Выполнится проверка условия $var == 1 [1, 2] --\u003e { code }; # Выполнится проверка условия ($var == 1 || $var == 2) [...] --\u003e { code default }; # Ветка условия иначе }; Или тоже самое, но с использованием макросов из модуля dsl:\n@match( $var ) ==\u003e { @case( 1 ) { code }; @case( 1, 2 ) { code }; @default { code default }; }; Этот оператор очень похож на Pattern Matching, но все же не является сопоставлением с образцом, а скорее более краткая запись множественного оператора сравнения, так как в качестве оператора для оценки могут быть использован любые имеющиеся операторы сравнения на равенство:\n==\u003e — проверка на равенство с приведением типов; ===\u003e — проверка на точное равенство; ~\u003e — проверка типа (имени класса); ~~\u003e — утиная типизация; ~~~\u003e — строгая утиная типизация. Но если в качестве оператора сравнения использовать оператор утиной типизации, то оценка выражения превращается в классический Pattern Matching:\n$value := (f1=1, f2=\"2\",); @match( $value ) ~~\u003e { @case((f1=_, ), (f1=_, f2=0, )) { ... code ... }; # Поле f2 отсутствует или число @case((f1=_, f2=\"\",), (f1=_, f2='',)) { ... code ... }; # Поле f2 строка @default { ... code default ... }; # Код по умолчанию }; ","categories":"","description":"","excerpt":"Синтаксическая конструкция с помощью которой реализуется примерный …","ref":"/docs/ops/match/","tags":"","title":"Оценка выражения"},{"body":"Синтаксическая конструкция с помощью которой реализуется примерный аналог оператора switch или match выглядит следующим образом:\n[ $var ] ==\u003e { [1] --\u003e { code }; # Выполнится проверка условия $var == 1 [1, 2] --\u003e { code }; # Выполнится проверка условия ($var == 1 || $var == 2) [...] --\u003e { code default }; # Ветка условия иначе }; Или тоже самое, но с использованием макросов из модуля dsl:\n@match( $var ) ==\u003e { @case( 1 ) { code }; @case( 1, 2 ) { code }; @default { code default }; }; Этот оператор очень похож на Pattern Matching, но все же не является сопоставлением с образцом, а скорее более краткая запись множественного оператора сравнения, так как в качестве оператора для оценки могут быть использован любые имеющиеся операторы сравнения на равенство:\n==\u003e — проверка на равенство с приведением типов; ===\u003e — проверка на точное равенство; ~\u003e — проверка типа (имени класса); ~~\u003e — утиная типизация; ~~~\u003e — строгая утиная типизация. Но если в качестве оператора сравнения использовать оператор утиной типизации, то оценка выражения превращается в классический Pattern Matching:\n$value := (f1=1, f2=\"2\",); @match( $value ) ~~\u003e { @case((f1=_, ), (f1=_, f2=0, )) { ... code ... }; # Поле f2 отсутствует или число @case((f1=_, f2=\"\",), (f1=_, f2='',)) { ... code ... }; # Поле f2 строка @default { ... code default ... }; # Код по умолчанию }; ","categories":"","description":"","excerpt":"Синтаксическая конструкция с помощью которой реализуется примерный …","ref":"/ru/docs/ops/match/","tags":"","title":"Оценка выражения"},{"body":"Для записи циклов используются оператор \u003c-\u003e, который ставится между условием цикла (проверкой логического выражения) и телом цикла. Условие цикла записывается в квадратных скобках и в зависимости от взаимного расположения цикл может быть с предусловием (while) или постусловием (dowhile):\n[условие while] \u003c-\u003e { тело цикла while }; { тело цикла do while } \u003c-\u003e [условие do while]; Цикл с предусловием (while) поддерживает конструкцию else, которая выполняется, если условие входа в цикл не было выполнено.\nВнимание! Это поведение отличается от аналогичных конструкций в языке Python, у которого секция else выполняется всегда, кроме прерывания цикла по break.\nВетка else у оператора цикла записывается так же как и ветка иначе в условном операторе, т.е.\n[ cond ] \u003c-\u003e { ... },[...] --\u003e { ... }; Или тоже самое, но с использованием макросов из модуля dsl:\n@while(cond) { ... } @else { ... # Выполнится, только если cond будет false при входе в цикл }; Пример реализации цикла foreach для суммирования всех элементов словаря (или одномерного тензора) с использованием оператора раскрытия списка:\nsumma := 0; dict := (1,2,3,4,5,); [ dict ] \u003c-\u003e { # Условие цикла, пока есть данные # Результат оператора распаковка словаря - первый элемент перемещается в item item, dict := ... dict; summa += item; # Вычисление суммы всех элементов словаря }; ","categories":"","description":"","excerpt":"Для записи циклов используются оператор \u003c-\u003e, который ставится между …","ref":"/docs/ops/while/","tags":"","title":"Операторы циклов"},{"body":"Для записи циклов используются оператор \u003c-\u003e, который ставится между условием цикла (проверкой логического выражения) и телом цикла. Условие цикла записывается в квадратных скобках и в зависимости от взаимного расположения цикл может быть с предусловием (while) или постусловием (dowhile):\n[условие while] \u003c-\u003e { тело цикла while }; { тело цикла do while } \u003c-\u003e [условие do while]; Цикл с предусловием (while) поддерживает конструкцию else, которая выполняется, если условие входа в цикл не было выполнено.\nВнимание! Это поведение отличается от аналогичных конструкций в языке Python, у которого секция else выполняется всегда, кроме прерывания цикла по break.\nВетка else у оператора цикла записывается так же как и ветка иначе в условном операторе, т.е.\n[ cond ] \u003c-\u003e { ... },[...] --\u003e { ... }; Или тоже самое, но с использованием макросов из модуля dsl:\n@while(cond) { ... } @else { ... # Выполнится, только если cond будет false при входе в цикл }; Пример реализации цикла foreach для суммирования всех элементов словаря (или одномерного тензора) с использованием оператора раскрытия списка:\nsumma := 0; dict := (1,2,3,4,5,); [ dict ] \u003c-\u003e { # Условие цикла, пока есть данные # Результат оператора распаковка словаря - первый элемент перемещается в item item, dict := ... dict; summa += item; # Вычисление суммы всех элементов словаря }; ","categories":"","description":"","excerpt":"Для записи циклов используются оператор \u003c-\u003e, который ставится между …","ref":"/ru/docs/ops/while/","tags":"","title":"Операторы циклов"},{"body":"Одиночный оператор захвата ссылки и синхронизации доступа к объекту ‘*’ или ‘*(…)’ выполняется только для одной переменной при использовании в одном действии. Но захват ссылки и объекта синхронизации, это относительно медленная операция и выполнять её для каждого действия над переменной не рационально.\nДля того, чтобы захватить одновременно сразу несколько объектов синхронизации для выполнения группы последовательных действий используется менеджер контекста.\n**( val1 = *ref1, val2 = *ref2, __timeout__ = 10000 ){ ... }; **( ... ){ ... } , [...] { # Ветка else при ошибке захвата ссылки # Информация об ошибке в переменной $^ ... }; Или таже самая запись с использованием макросов DSL:\n@with( val1 = *ref1, val2 = *ref2, __timeout__ = 10000 ){ ... }; @with( ... ){ ... } @else { # Ветка else при ошибке захвата ссылки # Информация об ошибке в переменной $^ ... }; Захват легких ссылок совместного доступа При захвате обычной легкой ссылки всегда сравнивается идентификатор текущего потока с идентифкатором потока - владельца объекта. Использование обычных легких ссылок допускается только в рамках одного потока - владельца объекта.\nЧтобы можно было использовать ссылки на легкие объекты в других потоках, для них требуется создать легкие ссылки для совместного доступа (\"\u0026?\").\nЗахват легких ссылок для совместного доступа возможен только с помощью оператора группового захвата, при условии, что как миниму одна из первых ссылок будет тяжелой. т.е. с реализованным объектом синхронизации.\nПример реализации критической секции с помощью оператора группового захвата @with и статической переменной @::sync в качестве флага блокировки доступа:\n# Функция для вызова в разных потоках show( \u0026? win1, \u0026? win2) := { \u0026\u0026 @::sync := @false; # Global (static) synchronization object @with (*sync, w1 = *win1, w2 = *win2){ ... # Критическая секция } } Расширенный синтаксис определения ссылок При определении переменной, у которой допускается создание ссылок и синхронизация доступа, можно указать дополнительные параметры работы. Это делается с помощью указания системных параметров в типе разрешенных ссылок при определении объекта.\nУсловный пример:\n\u0026\u0026 sync; # Объект синхронизации \u0026\u0026(__timeout__=1000) sync_other; # Объект синхронизации c таймаутом на блокировку with(*sync_other) { # Блокировка с таймаутом ... } # Переменная value с конкретным объектом синхроинзации \u0026?(sync) value := 123; with(*sync, lock = *value) { # ОК ... } with(*sync_other, val = *value) { # Ошибка компиляции # для синхронизации должен использоваться sync ... } Автоматическое освобождение ресурсов Менеджер контекста, кроме захвата слабых ссылок в локальные переменные и блокировки доступа, одновременно с этим позволяет выделять и освобождать ресурсы, автоматически вызывая декструктор локального объекта при выходе из блока кода оператора.\nОсвобождение ресурсов (вызов деструктора у объекта) происходит до попадания в ветку else, если она присутствует.\nСамый популярный пример использования менеджера контекста - связанные операции открытия, чтения/записи и закрытия файла в одном блоке кода.\nНапример:\n# Фрагмент определения класса File File(name, mode) := :Class() { .file ::= fopen($name, $mode); # Handle file ~File() := { # Destructor of class @if(@this.file){ fclose(@this.file); @this.file := _; } } ... }; @with( file = :File('some_file', 'w') ) { file.write('Oppa!'); }; Код выше открывает файл, записывает в него данные и закрывает файл при выходе из блока кода.\nЭтот код эквивалентен следующему на Python:\nwith open('some_file', 'w') as file: file.write('Oppa!') # Или без менеджера контекста file = open('some_file', 'w') try: file.write('Oppa!') finally: file.close() Более сложный пример чтение файла с одновремнным захватом ссылки на буфер и обработкой ошибок:\n@with( file = :File('some_file', 'r'), buffer = *ref_buffer ) { file.read(buffer); } @else { @match(@latter){ @case( :ErrorLock ) { /* Ошибка захвата ссылки ref_buffer */ }; @case( :ErrorOpenFile ) { /* Ошибка открытия для записи файла some_file */ }; @case( :ErrorReadWrite ) { /* Ошибка чтения-записи в файл some_file */ }; @default @forward; /* Остальные ошибки пробросить дальше */ }; }; Использование менеджера контекста - это гарантия закрытия файла и освобождения буфера вне зависимости от того, как будет завершён вложенный код. Распространенный паттерн использования контекстных менеджеров - блокирование и разблокирование ресурсов при многопоточном доступе к объетам, а также закрытие открытых файлов или освобождение захваченных ресурсов.\nprintf(format:FmtChar, ...):Int32 := %printf...; \u0026\u0026 holder: Integer[] = [,]; # Empty tensor Runnable(cnt:Integer) := { $i := 1; @while( $i \u003c= $cnt ) { *holder []= $i; # Lock and add new value $i += 1; @if( $i % ($cnt // 10) == 0) { @with(*holder){ # Lock only printf(\".\"); } } } } $count = 10000; thread1 = :Thread(Runnable, $count); thread2 = :Thread(Runnable, $count); thread3 = :Thread(Runnable, $count); thread4 = :Thread(Runnable, $count); thread5 = :Thread(Runnable, $count); thread1.start(); thread2.start(); thread3.start(); thread4.start(); thread5.start(); thread1.join(); thread2.join(); thread3.join(); thread4.join(); thread5.join(); @assert(*holder.size() == 5*$count); printf(\"Complete %d!\\n\", *holder.size()); Вывод:\n\u003e.................................................. \u003eComplete 50000! \u003e_ ","categories":"","description":"","excerpt":"Одиночный оператор захвата ссылки и синхронизации доступа к объекту …","ref":"/docs/ops/with/","tags":"","title":"Менеджер контекста"},{"body":"Одиночный оператор захвата ссылки и синхронизации доступа к объекту ‘*’ или ‘*(…)’ выполняется только для одной переменной при использовании в одном действии. Но захват ссылки и объекта синхронизации, это относительно медленная операция и выполнять её для каждого действия над переменной не рационально.\nДля того, чтобы захватить одновременно сразу несколько объектов синхронизации для выполнения группы последовательных действий используется менеджер контекста.\n**( val1 = *ref1, val2 = *ref2, __timeout__ = 10000 ){ ... }; **( ... ){ ... } , [...] { # Ветка else при ошибке захвата ссылки # Информация об ошибке в переменной $^ ... }; Или таже самая запись с использованием макросов DSL:\n@with( val1 = *ref1, val2 = *ref2, __timeout__ = 10000 ){ ... }; @with( ... ){ ... } @else { # Ветка else при ошибке захвата ссылки # Информация об ошибке в переменной $^ ... }; Захват легких ссылок совместного доступа При захвате обычной легкой ссылки всегда сравнивается идентификатор текущего потока с идентифкатором потока - владельца объекта. Использование обычных легких ссылок допускается только в рамках одного потока - владельца объекта.\nЧтобы можно было использовать ссылки на легкие объекты в других потоках, для них требуется создать легкие ссылки для совместного доступа (\"\u0026?\").\nЗахват легких ссылок для совместного доступа возможен только с помощью оператора группового захвата, при условии, что как миниму одна из первых ссылок будет тяжелой. т.е. с реализованным объектом синхронизации.\nПример реализации критической секции с помощью оператора группового захвата @with и статической переменной @::sync в качестве флага блокировки доступа:\n# Функция для вызова в разных потоках show( \u0026? win1, \u0026? win2) := { \u0026\u0026 @::sync := @false; # Global (static) synchronization object @with (*sync, w1 = *win1, w2 = *win2){ ... # Критическая секция } } Расширенный синтаксис определения ссылок При определении переменной, у которой допускается создание ссылок и синхронизация доступа, можно указать дополнительные параметры работы. Это делается с помощью указания системных параметров в типе разрешенных ссылок при определении объекта.\nУсловный пример:\n\u0026\u0026 sync; # Объект синхронизации \u0026\u0026(__timeout__=1000) sync_other; # Объект синхронизации c таймаутом на блокировку with(*sync_other) { # Блокировка с таймаутом ... } # Переменная value с конкретным объектом синхроинзации \u0026?(sync) value := 123; with(*sync, lock = *value) { # ОК ... } with(*sync_other, val = *value) { # Ошибка компиляции # для синхронизации должен использоваться sync ... } Автоматическое освобождение ресурсов Менеджер контекста, кроме захвата слабых ссылок в локальные переменные и блокировки доступа, одновременно с этим позволяет выделять и освобождать ресурсы, автоматически вызывая декструктор локального объекта при выходе из блока кода оператора.\nОсвобождение ресурсов (вызов деструктора у объекта) происходит до попадания в ветку else, если она присутствует.\nСамый популярный пример использования менеджера контекста - связанные операции открытия, чтения/записи и закрытия файла в одном блоке кода.\nНапример:\n# Фрагмент определения класса File File(name, mode) := :Class() { .file ::= fopen($name, $mode); # Handle file ~File() := { # Destructor of class @if(@this.file){ fclose(@this.file); @this.file := _; } } ... }; @with( file = :File('some_file', 'w') ) { file.write('Oppa!'); }; Код выше открывает файл, записывает в него данные и закрывает файл при выходе из блока кода.\nЭтот код эквивалентен следующему на Python:\nwith open('some_file', 'w') as file: file.write('Oppa!') # Или без менеджера контекста file = open('some_file', 'w') try: file.write('Oppa!') finally: file.close() Более сложный пример чтение файла с одновремнным захватом ссылки на буфер и обработкой ошибок:\n@with( file = :File('some_file', 'r'), buffer = *ref_buffer ) { file.read(buffer); } @else { @match(@latter){ @case( :ErrorLock ) { /* Ошибка захвата ссылки ref_buffer */ }; @case( :ErrorOpenFile ) { /* Ошибка открытия для записи файла some_file */ }; @case( :ErrorReadWrite ) { /* Ошибка чтения-записи в файл some_file */ }; @default @forward; /* Остальные ошибки пробросить дальше */ }; }; Использование менеджера контекста - это гарантия закрытия файла и освобождения буфера вне зависимости от того, как будет завершён вложенный код. Распространенный паттерн использования контекстных менеджеров - блокирование и разблокирование ресурсов при многопоточном доступе к объетам, а также закрытие открытых файлов или освобождение захваченных ресурсов.\nprintf(format:FmtChar, ...):Int32 := %printf...; \u0026\u0026 holder: Integer[] = [,]; # Empty tensor Runnable(cnt:Integer) := { $i := 1; @while( $i \u003c= $cnt ) { *holder []= $i; # Lock and add new value $i += 1; @if( $i % ($cnt // 10) == 0) { @with(*holder){ # Lock only printf(\".\"); } } } } $count = 10000; thread1 = :Thread(Runnable, $count); thread2 = :Thread(Runnable, $count); thread3 = :Thread(Runnable, $count); thread4 = :Thread(Runnable, $count); thread5 = :Thread(Runnable, $count); thread1.start(); thread2.start(); thread3.start(); thread4.start(); thread5.start(); thread1.join(); thread2.join(); thread3.join(); thread4.join(); thread5.join(); @assert(*holder.size() == 5*$count); printf(\"Complete %d!\\n\", *holder.size()); Вывод:\n\u003e.................................................. \u003eComplete 50000! \u003e_ ","categories":"","description":"","excerpt":"Одиночный оператор захвата ссылки и синхронизации доступа к объекту …","ref":"/ru/docs/ops/with/","tags":"","title":"Менеджер контекста"},{"body":"Последовательность команд (блок кода) можно прервать в любом месте с помощью специальных операторов.\nДля этого используются две разные команды, которые условно можно назвать положительным и отрицательным прерыванием потока выполнения, что примерно соответствует семантике их записи. “Отрицательное” прерывание записывается в виде двух минусов, а “положительное” прерывание в виде двух плюсов, т.е. -- или ++.\nОператор прерывания не возвращает никакого значения (точнее, возвращает пустое значение). Чтобы прерывание вернуло другое значение, возвращаемые данные нужно записать между парой соответствующих символов, т.е. -- 100 --, что является примерным аналогом оператора return 100; в других языках программирования, а ++‘Строка’++ - аналогом return 'Строка';.\nЛокальный переход Именованные блоки кода могут выступать в качестве локальных меток для передачи потока выполнения. Если перед оператором прерывания указать пространство имен, то оператор прерывания станет именованным и будет действовать только для указанного блока кода.\nВ этом случае отрицательное прерывание будет работать как оператор continue, передавая поток выполнения на первую инструкцию блока кода, а положительное прерывание как оператор break, выходя из него.\nЛокальная передача потока управления работает с именованными блоками кода, поэтому переход в начало блока кода или выход из него, возможны в том числе и изнутри нескольких вложенных именнованных блоков кода.\nb1 := 1; # Бесконечный цикл с именованным блоком кода [1] \u003c-\u003e outer_loop:: { # Именованный блок кода outer_loop b2 := 1; [1] \u003c-\u003e inner_loop { # Именованный блок кода inner_loop printf(\"Values: b1=%d, b2=%d\", b1, b2); # Проверка условий [b1 == 2 \u0026\u0026 b2 == 2] --\u003e { outer_loop:: ++; # Прерываем outer_loop }, [b2 == 5] --\u003e { inner_loop:: ++; # Прерываем inner_loop } b2 += 1; } b1 += 1; } Тоже самое с использованием макросов DSL.:\nb1 := 1; @loop outer_loop:: { # @while(@true) b2 := 1; @loop inner_loop { printf(\"Values: b1=%d, b2=%d\", b1, b2); @if( b1 == 2 @and b2 == 2) { @break outer_loop; } @elif( b2 == 5 ) { @break inner_loop; } b2 += 1; } b1 += 1; } Возврат результата Для возврата результата из тела функции используется положительное прерывание из блока кода, меткой которого является полное имя функции, включая текущую область имен. Имя блока кода тела функции соответствует её имени.\nns:: { # Пространство имен ns func_name(val):Int32 ::= { # Блок кода тела функции ns::func_name:: ... # Возврат из функции func_name ++ 0 ++; # Или @return(0); с ипользованием DSL :: ++ 0 ++; # Завершение программы? exit(0) :: -- ; # Прерывание выполенения программы? abort() }; }; Для оператора прерывания выполенения можно указать и глобальную область видимости. Тогда при выполнении такого прерывания происходит выход из самого верхнеуровневого блока кода, что приводит к завершение работы приложения.\nАналогом такого поведения являются функции exit() для положительного прерывания и abort() для отрицательного, что отражено в DSL.\nПерехват прерывааний Именованные прерывания потока выполнения можно использовать только внутри именованных блоков кода, что контроллируется во время компиляции программы на уровне исходного кода.\nДля не именованных прерываний такое ограничение отсуствует, поэтому более точным аналогом не именованного прерывания будет не return или break, а throw, т.к. эти операторы не только прерывают выполнение последовательности команд в любом блоке кода и возвращают результат, но их еще и можно “ловить”.\nДля перехвата не именованных прерываний используются блоки кода с соответствующей семантикой, {+ … +} - блок кода, который перехватывает положительные прерывания и {- … -} - блок кода, который перехватывает отрицательные прерывания, созданные операторами --, и блок кода {* … *}, который перехватывает сразу оба типа прерываний.\nНапример, возврат из нескольких вложенных функций без необходимости обрабатывать результат возврата в каждой из них. В этом примере функция Test перехватывает “положительные” прерывания из вложенных функций:\nLevel2(arg) := { if($arg==2) { ++ \"Level - 2\" ++; }; \"Level2 - DONE\"; }; Level1(arg) := { if($arg==1) { ++ \"Level - 1\" ++; }; Level2($arg); }; Test(arg) := {+ if($arg \u003e= 0) { Level1($arg); } $arg; +}; Test(2); # Вернет \"Level — 2\" возврат из вложенной функции Level2 Test(1); # Вернет \"Level — 1\" возврат из вложенной функции Level1 Test(0); # Вернет \"Level2 - DONE\" возврат из вложенной функции Level2 Test(-2); # Вернет -2 — возврат из функции Test Обработка ошибок Оба варианта прерываний равнозначны и “отрицательное” прерывание для возврата ошибки используется только условно. Блоки кода с перехватом прерываний, совместно с оператором оценки выражения, можно использовать для обработки исключений в классическом стиле.\n[ {* # Перехват всех исключений на базовом синтаксисе op1; op2; ... *} ] ~\u003e { # Сопоставление по типу возвращенного значения [:ErrorType1] --\u003e { code }; [:ErrorType2, :ErrorType3] --\u003e { code }; [...] --\u003e { code default }; }; # Семантика с применением DSL @try { op1; op2; ... } @catch (...) { # Перехват всех исключений @case(:Error){ ... }; @default @forward; }; # Тоже самое, только для заданных типов @try { op1; op2; ... } @catch (:Type, :Type2, :Type3) { @case(:Type){ ... }; @case(:Type2, :Type3){ ... }; @default @forward; }; Расширенные варинаты прерывания выполнения Добавить реализациию для короутин после их полной реализации в clang (скорее всего на уровне аннотаций)\n@@ coroutine @@ ::= @@ __ANNOTATION_SET__(coroutine) @@; @@ co_yield(...) @@ ::= @@ __ANNOTATION_CHECK__(coroutine) @__FUNC_BLOCK__ :: -- @$... -- @@ co_await @@ ::= @@ __ANNOTATION_CHECK__(coroutine) @__FUNC_BLOCK__ :: +- @@ co_return(...) @@ ::= @@ __ANNOTATION_CHECK__(coroutine) @__FUNC_BLOCK__ :: ++ @$... ++ ns { @coroutine co_func(val):Int32 ::= { # Блок кода тела функции ... # Возврат и приостановка выполнения функции @__FUNC_BLOCK__ :: -- 0 --; # ns::co_func:: -- 0 --; # Или @co_yield(0); с ипользованием DSL # Приостановить и вернуть управление @__FUNC_BLOCK__ :: +-; # ns::co_func:: +-; # Или @co_await; с ипользованием DSL # Возврат и завершение функции @__FUNC_BLOCK__ :: ++ 0 ++; # ns::co_func:: ++ 0 ++; # Или @co_return(0); с ипользованием DSL }; }; Выражение co_yield возвращает значение вызывающей стороне и приостанавливает текущую сопрограмму: это общий строительный блок возобновляемых функций-генераторов.\nco_await +-\nУнарный оператор co_await приостанавливает сопрограмму и возвращает управление вызывающей стороне. Его операнд представляет собой выражение, которое либо (1) относится к типу класса, определяющему оператор-член co_await, либо может быть передано оператору, не являющемуся членом co_await, либо (2) может быть преобразовано в такой тип класса с помощью текущей сопрограммы.\nauto request = await socket.read(...); auto result = await db_client.do_query(prepare_request(request)); await socket.write(prepare_result(result)); socket.close(); request := (){ socket.read(...) }; auto result = (){ request, db_client.do_query(prepare_request(request)) }; (){ socket.write(prepare_result(result)) }; socket.close(); ","categories":"","description":"","excerpt":"Последовательность команд (блок кода) можно прервать в любом месте с …","ref":"/docs/ops/throw/","tags":"","title":"Ввозврат, прерывания и обработка ошибок"},{"body":"Последовательность команд (блок кода) можно прервать в любом месте с помощью специальных операторов.\nДля этого используются две разные команды, которые условно можно назвать положительным и отрицательным прерыванием потока выполнения, что примерно соответствует семантике их записи. “Отрицательное” прерывание записывается в виде двух минусов, а “положительное” прерывание в виде двух плюсов, т.е. -- или ++.\nОператор прерывания не возвращает никакого значения (точнее, возвращает пустое значение). Чтобы прерывание вернуло другое значение, возвращаемые данные нужно записать между парой соответствующих символов, т.е. -- 100 --, что является примерным аналогом оператора return 100; в других языках программирования, а ++‘Строка’++ - аналогом return 'Строка';.\nЛокальный переход Именованные блоки кода могут выступать в качестве локальных меток для передачи потока выполнения. Если перед оператором прерывания указать пространство имен, то оператор прерывания станет именованным и будет действовать только для указанного блока кода.\nВ этом случае отрицательное прерывание будет работать как оператор continue, передавая поток выполнения на первую инструкцию блока кода, а положительное прерывание как оператор break, выходя из него.\nЛокальная передача потока управления работает с именованными блоками кода, поэтому переход в начало блока кода или выход из него, возможны в том числе и изнутри нескольких вложенных именнованных блоков кода.\nb1 := 1; # Бесконечный цикл с именованным блоком кода [1] \u003c-\u003e outer_loop:: { # Именованный блок кода outer_loop b2 := 1; [1] \u003c-\u003e inner_loop { # Именованный блок кода inner_loop printf(\"Values: b1=%d, b2=%d\", b1, b2); # Проверка условий [b1 == 2 \u0026\u0026 b2 == 2] --\u003e { outer_loop:: ++; # Прерываем outer_loop }, [b2 == 5] --\u003e { inner_loop:: ++; # Прерываем inner_loop } b2 += 1; } b1 += 1; } Тоже самое с использованием макросов DSL.:\nb1 := 1; @loop outer_loop:: { # @while(@true) b2 := 1; @loop inner_loop { printf(\"Values: b1=%d, b2=%d\", b1, b2); @if( b1 == 2 @and b2 == 2) { @break outer_loop; } @elif( b2 == 5 ) { @break inner_loop; } b2 += 1; } b1 += 1; } Возврат результата Для возврата результата из тела функции используется положительное прерывание из блока кода, меткой которого является полное имя функции, включая текущую область имен.\nИменованный блок кода при перехвате прерываний возвращают объект, который передавался с помощью прервывания, либо пусто, если возвращаемое значение отсуствует.\nИмя блока кода тела функции соответствует её имени.\nns:: { # Пространство имен ns func_name(val):Int32 ::= { # Блок кода тела функции ns::func_name:: ... # Возврат из функции func_name ++ 0 ++; # Или @return(0); с ипользованием DSL :: ++ 0 ++; # Завершение программы? exit(0) :: -- ; # Прерывание выполенения программы? abort() }; }; Для оператора прерывания выполенения можно указать и глобальную область видимости. Тогда при выполнении такого прерывания происходит выход из самого верхнеуровневого блока кода, что приводит к завершение работы приложения.\nАналогом такого поведения являются функции exit() для положительного прерывания и abort() для отрицательного, что отражено в DSL.\nПерехват прерывааний Именованные прерывания потока выполнения можно использовать только внутри именованных блоков кода, что контроллируется во время компиляции программы на уровне исходного кода.\nДля не именованных прерываний такое ограничение отсуствует, поэтому более точным аналогом не именованного прерывания будет не return или break, а throw, т.к. эти операторы не только прерывают выполнение последовательности команд в любом блоке кода и возвращают результат, но их еще и можно “ловить”.\nДля перехвата не именованных прерываний используются блоки кода с соответствующей семантикой, {+ … +} - блок кода, который перехватывает положительные прерывания и {- … -} - блок кода, который перехватывает отрицательные прерывания, созданные операторами --, и блок кода {* … *}, который перехватывает сразу оба типа прерываний.\nПринципиальное отличие блоков кода для перехвата прерываний от именованных блоков кода состоит в типе возвращаемого значения. Если именованные блоки кода возвращают значение, то при перехвате прервывания, возвращается непосредственно само прерывание, а не возращаемое с его помощью значение.\nНапример, возврат из нескольких вложенных функций без необходимости обрабатывать результат возврата в каждой из них. В этом примере функция Test перехватывает “положительные” прерывания из вложенных функций:\nLevel2(arg) := { if($arg==2) { ++ \"Level - 2\" ++; }; \"Level2 - DONE\"; }; Level1(arg) := { if($arg==1) { ++ \"Level - 1\" ++; }; Level2($arg); }; Test(arg) := * {+ if($arg \u003e= 0) { Level1($arg); } $arg; +}; Test(2); # Вернет \"Level — 2\" возврат из вложенной функции Level2 Test(1); # Вернет \"Level — 1\" возврат из вложенной функции Level1 Test(0); # Вернет \"Level2 - DONE\" возврат из вложенной функции Level2 Test(-2); # Вернет -2 — возврат из функции Test Обработка ошибок Оба варианта прерываний равнозначны и “отрицательное” прерывание для возврата ошибки используется только условно. Блоки кода с перехватом прерываний, совместно с оператором оценки выражения, можно использовать для обработки исключений в классическом стиле.\n[ {* # Перехват всех исключений на базовом синтаксисе op1; op2; ... *} ] ~\u003e { # Сопоставление по типу возвращенного значения [:ErrorType1] --\u003e { code }; [:ErrorType2, :ErrorType3] --\u003e { code }; [...] --\u003e { code default }; }; # Семантика с применением DSL @try { op1; op2; ... } @catch (...) { # Перехват всех исключений @case(:Error){ ... }; @default @forward; }; # Тоже самое, только для заданных типов @try { op1; op2; ... } @catch (:Type, :Type2, :Type3) { @case(:Type){ ... }; @case(:Type2, :Type3){ ... }; @default @forward; }; Расширенные варинаты прерывания выполнения Добавить реализациию для короутин после их полной реализации в clang (скорее всего на уровне аннотаций)\n@@ coroutine @@ ::= @@ __ANNOTATION_SET__(coroutine) @@; @@ co_yield(...) @@ ::= @@ __ANNOTATION_CHECK__(coroutine) @__FUNC_BLOCK__ :: -- @$... -- @@ co_await @@ ::= @@ __ANNOTATION_CHECK__(coroutine) @__FUNC_BLOCK__ :: +- @@ co_return(...) @@ ::= @@ __ANNOTATION_CHECK__(coroutine) @__FUNC_BLOCK__ :: ++ @$... ++ ns { @coroutine co_func(val):Int32 ::= { # Блок кода тела функции ... # Возврат и приостановка выполнения функции @__FUNC_BLOCK__ :: -- 0 --; # ns::co_func:: -- 0 --; # Или @co_yield(0); с ипользованием DSL # Приостановить и вернуть управление @__FUNC_BLOCK__ :: +-; # ns::co_func:: +-; # Или @co_await; с ипользованием DSL # Возврат и завершение функции @__FUNC_BLOCK__ :: ++ 0 ++; # ns::co_func:: ++ 0 ++; # Или @co_return(0); с ипользованием DSL }; }; Выражение co_yield возвращает значение вызывающей стороне и приостанавливает текущую сопрограмму: это общий строительный блок возобновляемых функций-генераторов.\nco_await +-\nУнарный оператор co_await приостанавливает сопрограмму и возвращает управление вызывающей стороне. Его операнд представляет собой выражение, которое либо (1) относится к типу класса, определяющему оператор-член co_await, либо может быть передано оператору, не являющемуся членом co_await, либо (2) может быть преобразовано в такой тип класса с помощью текущей сопрограммы.\nauto request = await socket.read(...); auto result = await db_client.do_query(prepare_request(request)); await socket.write(prepare_result(result)); socket.close(); request := (){ socket.read(...) }; auto result = (){ request, db_client.do_query(prepare_request(request)) }; (){ socket.write(prepare_result(result)) }; socket.close(); ","categories":"","description":"","excerpt":"Последовательность команд (блок кода) можно прервать в любом месте с …","ref":"/ru/docs/ops/throw/","tags":"","title":"Ввозврат, прерывания и обработка ошибок"},{"body":"New features and changes in the syntax of NewLang Reworked the definition of object types using prefix naming (sigils) Interrupting the execution flow and returning can now be done for named code blocks. Simplified the syntax for importing native variables and functions (C/C++) Stabilized the syntax for initializing tensor, dictionary, and function argument values with initial data. Added built-in macros for writing code using keywords in a DSL style New compiler features (nlc) Completely redesigned the macroprocessor. Reworked the compiler architecture with division into parser, macroprocessor, syntax analyzer, interpreter, and code generator. Miscellaneous The documentation website has been translated to Hugo and made bilingual. Instead of binary builds, a section Playground and example code has been added to the website for small experiments. Transition to clang-16 has been completed (transition to clang-17 and newer is planned after full implementation of coroutines and support for extended floating-point number formats). The number of project contributors has increased to more than one! ","categories":"","description":"","excerpt":"New features and changes in the syntax of NewLang Reworked the …","ref":"/blog/release-v0.4/","tags":"","title":"Release of the programming language NewLang 0.4"},{"body":"Новые возможности и изменения в синтаксисе NewLang Переработано определение типов объектов с помощью префикса имен (сигила) Прерывание потока выполнения и возврат теперь может выполняться для именованных блоков кода. Упрощен синтаксис импорта нативных переменных и функций (С/С++) Стабилизирован синтаксис для заполнение начальными данными значений тензоров, словарей и аргументов при вызове функций. Появились встроенные макросы для написания кода с использованием ключевых слов в стиле DSL Новые возможности компилятора (nlc) Полностью переделан макропроцессор. Переработана архитектура компилятора с разделением на парсер, макропроцессор, синтаксический анализатор, интерпретатор и генератор кода. Разное Сайт с документацией переведен на Hugo и сделан двуязычным. Вместо бинарных сборок на сайт добавлен раздел Playground and example code для небольших экспериментов. Выполнен переход на clang-16 (переход на clang-17 и старше планируется после полной реализации корутин и поддержки расширенных форматов чисел с плавающей запятой). Количество контрибуторов проекта стало больше одного! ","categories":"","description":"","excerpt":"Новые возможности и изменения в синтаксисе NewLang Переработано …","ref":"/ru/blog/release-v0.4/","tags":"","title":"Релиз языка программирования NewLang 0.4"},{"body":"\nНедавно прочитал на Хабре статью Свой язык, или как я устал от ассемблера и С, и невольно взглядом зацепился за один абзац:\nЯ решил не сильно париться, поэтому использовал библиотеку parglare. Она очень легкая и удобная, всем рекомендую. Для описания синтаксиса парсер принимает строку в соответствующем формате, использует регулярные выражения (не надо осуждать регулярки, они всесильны!).\nВ результате решил опубликовать статью на основе своих старых записей еще с тех времен, когда идея NewLang до конца еще не выкристаллизовалась, но уже хотелось писать реальный код и тестировать разные концепции.\nВедь в жизни практически любого программиста может наступить момент, когда ему в голову приходит светлая идея - разработать свой собственный язык программирования. Может быть и не ради захвата мира, наравне с C/C++, Python или хотя бы PHP, а в качестве личного пет-проекта, с которым он, длинными зимними вечерами будет оттачивать собственное мастерство.\nА так как у любого языка (не только программирования), все начинается с анализа его грамматики, то самой первой задачей создателя будет выбор инструментов для синтаксического анализа исходного текста.\nЭто история — заметки на память о муках выбора связки лексер-парсер для разбора грамматики NewLang. А так же попытка описать и систематизировать выводы об особенностях разных анализаторов с которыми пришлось поработать при выборе парсера для разбора грамматики у своего языка программирования.\nИспользуемые термины. Чтобы было понятно, о чем в дальнейшем пойдет речь.\nЛексер — компьютерная программа или библиотека, в задачи которой входит разделить входной поток данных на отдельные, не связанные между собой отдельные фрагменты, которые принято называть токенами или лексемами.\nПарсер — на основе последовательности токенов выполняется синтаксический анализ, например строит абстрактное синтаксическое дерево (AST).\nЗаход № 1 - Flex + Bison GitHub - westes/flex: The Fast Lexical Analyzer - scanner generator for lexing in C and C++ Bison - GNU Project - Free Software Foundation\nПосле прочтения умных книжек я начал с классики Flex + Bison. Это старые и давно отработанные приложения с широчайшими возможностями по настройке с помощью которых можно описать синтаксис и получить исходные файлы лексера и парсера для языка практически с любой грамматикой.\nК сожалению, у этих старичков очень большой порог входа и тяжелая наследственность. Чего только стоит определение собственного класса лексера через #define, а так же отсутствие нормальной поддержки С++. Вынужденные танцы с бубном для пасинга отдельной строки, когда не требуется анализировать файл целиком и прочие не всегда очевидные проблемы и разные не понятные условности.\nДругими словами, через несколько недель безуспешных мучений я решил посмотреть альтернативы, а так как начальный файл лексики после экспериментов с Flex + Bison кое-как уже был сделан, то следующая связка была Flex + lemon.\nЗаход № 2 - Flex + Lemon The Lemon LALR(1) Parser Generator\nТут все оказалось до примитивности просто и понятно. Реально очень быстрый старт с боевыми примерами, очень наглядный и понятный способ записи правил (по сравнению с Bison). Все хорошо кроме одного, хорошее быстро заканчивается, если приходится анализировать более одной строки.\nПо сути, Lemon с Bison, это как Инь и Янь. Lemon простой и удобный для работы с одной строкой (для этого он и создавался), а Bison супер-пупер-мега комбайн для парсинга файлов любых размеров.\nПоэтому, поиски связки лексер + парсер продолжились и после прочтения очередной статьи, что парсеры языков можно делать на регулярках, решил посмотреть, что есть в этом направлении:\nЗаход № 3 парсер на регулярках re2c Из описания re2c:\nПо сути, на этой штуке можно писать лексические анализаторы прямо на коленке за несколько минут.\n/*!re2c re2c:define:YYPEEK = \"*cursor\"; re2c:define:YYSKIP = \"++cursor;\"; re2c:define:YYBACKUP = \"marker = cursor;\"; re2c:define:YYRESTORE = \"cursor = marker;\"; re2c:define:YYBACKUPCTX = \"ctxmarker = cursor;\"; re2c:define:YYRESTORECTX = \"cursor = ctxmarker;\"; re2c:define:YYRESTORETAG = \"cursor = ${tag};\"; re2c:define:YYLESSTHAN = \"limit - cursor \u003c @@{len}\"; re2c:define:YYSTAGP = \"@@{tag} = cursor;\"; re2c:define:YYSTAGN = \"@@{tag} = NULL;\"; re2c:define:YYSHIFT = \"cursor += @@{shift};\"; re2c:define:YYSHIFTSTAG = \"@@{tag} += @@{shift};\"; */ Показалось, что это самый удобный способ указания шаблонов для парсера! Достаточно описать в комментариях нужные шаблоны, напустить на исходный файл компилятор регулярок и все готово! Но нет, действительно, это только показалось.\nВедь для простеньких парсеров или регулярных выражений re2c может быть и действительно хорош, но отлаживать синтаксис большого языка на регулярках слишком хлопотное занятие.\nПосле этого решил с ним не заморачиваться и посмотреть альтернативы классическим лексерам и парсерам.\nЗаход № 4 - flex (flexcpp) + bisoncpp Тогда как у традиционных flex + bison поддержка С++ реализована через одно место на уровне - работает и не трогай, то решил посмотреть их альтернативную реализация flexcpp + bisoncpp с нативной поддержкой С++.\nПервое впечатление было, то что доктор прописал!\nСинтаксис записи лексики хоть немного и отличается от классической, но это не принципиально. Зато есть нативная и логичная поддержка С++ без оберток и выкрутасов, и как дополнительный плюс - более удобный синтаксис указания правил в парсере. Но и тут не обошлось без шероховатостей.\nВ шаблонах правил bisoncpp не поддерживает юникод (хотя сам лексер-парсер с ним справляется на ура), и совсем не понятная ситуация с поддержкой. Как я понял, разработчиком является вроде бы один человек, но пообщаться с ним насчет ошибок при обработке русских символов так и не получилось.*\nПотом еще одно непонятное поведение вылезло в другом месте. В результате решил отказаться от недружелюбной поддержки и посмотреть, какие есть еще варианты парсеров.\n*) Через два года мой тикет был закрыт с комментарием, что поддерживаются только ascii символы.\nЗаход № 5 - неродной парсер ANTLR От использования ANTLR (от англ. ANother Tool for Language Recognition — «ещё одно средство распознавания языков») — генератора нисходящих анализаторов для формальных языков, я решил сразу отказать из-за того, что он написан на Java,.\nВ этом нет никаких религиозных предпочтений, так как я искал генератор парсеров, который можно было бы сделать встроенным прямо в среду выполнения, а в случае с ANTLR и JRE это было бы затруднительно.\nТаким образом я опять вернулся к старичкам Flex и Bison, с которых все и начиналось.\nЗаход № 6, последний - возвращение к Flex + Bison Все описанные выше эксперименты заняли в общем итоге несколько месяцев, в результате которых были написаны килобайты исходного кода и тестовых примеров, прочитано десятки статей и как результат - возврат к изначальной связке Flex + Bison, но уже с солидным багажом опыта в применении различных вариантов лексеров-парсеров.\nНо самое главное, с пониманием того, что же в результате хочется получить, и очень большой базой тестовых примеров синтаксиса.\nВыводы на память В итоге для себя решил следующее: если нужен простенький шаблонизатор, то идеальный вариант re2c (если почему-то не подходит regexp). Если требуется анализировать синтаксис сложнее обычных регулярок, но в одну строку, то идеальной будет связка flex+lemon, а если нужна серьезная артиллерия, то тут однозначно flex + bison.\nОт связки flexcpp + bisoncpp отказался совсем. Что с поддержкой — не понятно, синтаксис от классики отличается не очень сильно (хотя тоже нужно ломать голову), а обход выявленных косяков не стоят того синтаксического сахара.\nИ по итогам множества экспериментов с разными вариантами синтаксиса удалось сформулировать пару важных архитектурных моментов, которые могут очень сильно упростить жизнь создателям языком программирования:\nСтратегия обработки ошибок синтаксиса Обычно принято обрабатывать синтаксические ошибки непосредственно в парсере и для этого есть определенный резон — в этом случае нет необходимости в каких либо дальнейших действиях, нужна только полностью описанная корректная грамматика.\nНо если грамматика языка очень сложная (привет C++), и её описание становится сложной задачей, то можно отказался и от анализа ошибок синтаксиса непосредственно в парсере! То есть, лучше сделать максимально широкую лексику (даже с теми вариантами, которые являются для языка ошибочными), но ловить эти ошибки уже при анализе AST!\nВ этом случае, поддерживать описание грамматики языка становится значительно проще (меньше синтаксических правил, проще их формальное описание и т.д.), а самое главное, при описании грамматики не нужно думать про lval или rval, где можно указывать ссылку, а где нет — т. е. можно указывать все и везде, а вот анализ допустимости использования конкретных терминов будет выполняться позднее при анализе AST.\nОтказа от полного анализа грамматики языка на уровне лексера — парсера и перенос проверки корректности синтаксических конструкций на этап разбора синтаксического дерева позволяет в разы, если не на порядки сократить и значительно упростить описание грамматических правил!\nПодобное допущение очень полезно на начальном этапе создания языка (можно сосредоточиться на общей концепции, вместо постоянных правок в грамматике), а так же значительно упростить в будущем поддержку и/или расширение синтаксиса.\nМакросы и модификация грамматики в Runtime Какими бы мощными не были flex+bison, но у этой связки есть одна архитектурная проблема. Логика flex и bison построена на конечных автоматах и изменить грамматику языка во время выполнения приложения невозможно, тем более Bison сам вызывает лексер для получения очередной порции данных и ему очень непросто подсунуть измененные данные прямо во время работы. А так хотелось сделать возможность раскрытия макросов и модификации синтаксиса за один проход анализатора!\nДля этого пришлось переделать логику работы flex+bison, чтобы парсер получал данные из лексера не напрямую из yylex, а через функцию — прокси. Эта промежуточная функция, складывает считанные лексемы во внутренний буфер. Данные в буфере анализируется на предмет наличия макросов и только после их раскрытия, лексемы отдаются в парсер из вершины буфера по одной за раз. Подробнее о макросах NewLang можно почитать тут.\nСамое главное при разработке грамматики! Но самый важный совет мне подсказал друг, который некогда участвовал в проекте по разработке парсера для языка программирования. И в правильности его совета - пиши тесты для грамматики - я убеждался уже множество раз. Даже так, ПИШИ ТЕСТЫ ДЛЯ ГРАММАТИКИ.\nТесты для грамматики языка гораздо более важная вещь, чем любой из используемых инструментов. Только тесты позволяют убедиться в том, что новая фича в языке не сломала старые наработки. А если все же сломала, то в первую очередь нужно добавить новый тест, который бы фиксировал сломавшийся сценарий и только после этого можно будет со спокойной душой продолжать эксперименты с новыми грамматическими конструкциями.\nИ удачи всем языкописателям!\nСсылка на первую публикаци\n","categories":"","description":"","excerpt":"\nНедавно прочитал на Хабре статью Свой язык, или как я устал от …","ref":"/ru/blog/parser-nuances/","tags":"","title":"Нюансы разработки парсера для своего языка программирования"},{"body":" Attention!!!\nThis article contains a description of the NewLnag syntax of the previous version.\nPublication source https://habr.com/articles/720416/\nThis is a translation of my own article\nThe release of NewLang language with a brand new “feature” is coming, a remodeled version of the preprocessor that allows you to extend the language syntax to create different DSL dialects using macros.\nWhat is it about? DSL (Subject Oriented Language) is a programming language specialized for a specific application area. It is believed that the use of DSL significantly increases the level of abstractness of the code, and this allows to develop more quickly and efficiently and greatly simplifies the solution of many problems.\nConditionally, we can distinguish two approaches to DSL implementation: Development of independent syntax translators using lexer and parser generators to define the grammar of the target language through BNF (Backus–Naur form) and regular expressions (Lex, Yacc, ANTLR, etc.) and then compiling the resulting grammar into machine code. Development or integration of the DSL dialect into a general-purpose language (metalanguage), including the use of various libraries or special parsers / preprocessors. We will talk about the second option, namely the implementation of DSL on the basis of general-purpose languages (metalanguages) and the new implementation of macros in NewLang as the basis for DSL development.\nTwo extremes It probably makes sense to start by describing two extremes in the implementation of a DSL based on a general-purpose language (metalanguage):\nLimited grammar. If a programming language is limited to its own fixed grammar and does not allow for its expansion, when implementing DSL the developer will be forced to use the existing grammar, the rules for recording operations and generally all syntax will remain the same as in the implementation language. For example, when using C/C++ as a base language, or using various libraries and frameworks in other general-purpose programming languages.\nIn this case, the term “DSL” will simply be a set of domain-specific terms, overridden macros and/or operators, but the use of which will be restricted by the implementation language grammar.\nUnrestricted grammar. If a language (metalanguage) allows you to modify its own grammar (for example at the level of AST), then DSL will no longer be strictly bounded by the syntax of the underlying programming language, and as a result its grammar can be whatever you want. Up to the point that “for every new project you will have to learn a new language…”. This can be done by using specialized metalanguages (Lisp, ML, Haskell, Nemerle, Forth, Tcl, Rebol, etc.).\nI strongly recommend you to read an excellent article on metaprogramming by @NeoCode [Metaprogramming: what it is and what it should be] (https://habr.com/post/258667/).\nThe following implementation of macros is offered for discussion “There is no perfection in the world”, and after the release of NewLang 0.2, I received a lot of feedback (mostly negative), about the first version of macro implementation and DSL based on it. And those criticisms were often valid. So I decided to try to redesign the macros a bit, in hopes of getting a “middle ground” between the two extremes described above when describing the DSL.\nTerminology Used Macros in NewLang, are one or more terms that are replaced by another term or by an entire lexical construct (a sequence of tokens). Macros are both an extension of basic language syntax, when implementing DSL’s own dialects, and a syntax sugar.\nThe main feature of macros is that they allow expressions to be changed before they are evaluated at runtime. Macros are expanded at runtime lexer, which allows you to substitute any other terms with them and even modify the language syntax itself.\nThat’s why if you don’t specify a modifier before the NewLang object name (****macros, **$**local_variable or **@**module), the program will first search among macros, then among local variables and finally among modules (object from module). This allows you to use terms without modifiers to specify types of objects.\nMacro definitions The definition of macros uses exactly the same syntax as for other language objects (the operators “::=”, “=” or “:=” are used respectively to create a new object, assign a new value to an existing object or to create/assign a new value to an object regardless of its presence or absence).\nIn general, a macro definition consists of three parts \u003c macro name \u003e \u003c creating/assignment operator \u003e \u003c macro body \u003e and final semicolon “;*”.\nMacro body The macro body can be a correct language expression, a sequence of tokens (framed in double backslashes, i.e. \\\\ lexem1 lexem2 \\\\) or a plain text string (framed in triple backslashes, i.e. \\\\\\ text string \\\\\\).\nTo connect two tokens into one (analogous to the ## operation in the C/C++ preprocessor), used by analogy syntax ##. A similar operator is used to frame a lexeme in quotes #, for example, \\macro($arg) := \\\\\\ func_ \\## \\$arg(\\#arg) \\;, then a call to macro(arg) will be expanded to func_arg (\"arg\");\nMacro Name The macro name can be a single identifier with the macro prefix “\\” or a sequence of several lexem. If a sequence of lexem is used as the macro name there must be at least one identifier among them and there can be one or more templates.\nA template is a special identifier that can be replaced by any single term during matching. With the help of templates the search by pattern and replacement of the set sequences of lexemes on a body of a macro is made.\nTo specify a template, you need to put a dollar sign at the beginning of the identifier (which corresponds to the local variable name record), i.e. \\\\one_lexem\\\\, \\\\total three tokens\\\\ \\\\ lexem $template1 $template2 \\\\.\nMacros are considered identical if their identifiers are equal, the number of elements in their names is the same, and identifiers and templates are in the same places.\nMacro Arguments Terms or templates in a macro name can have arguments, which are specified in parentheses. The passed arguments in the body of macro are written in the disclosure space as a local variable name, but a backslash must be added before the name, i.e. \\$name.\nAn arbitrary number of parameters in a macro is marked with a triple colon “…”, and the place for inserting these arguments is marked with the token $…. If a macro has several identifiers with arguments, the place marked with the desired identifier to insert arguments from a marked identifier, for example, $name….\nTo insert the number of actually passed arguments, the lexeme $# is used, or with the marked identifier, for example, $#name.\n*Macros work with lexem that contain various information, including the data type if it is specified. But at the moment data types in macro arguments are not handled in any way, and this is one of the mandatory features that will be implemented in the future.\nExamples: \\macros1 := 123; \\macros2(arg) := { func( \\$arg ); func2(123);}; \\\\ macros of(...) tokens \\\\ := \\\\ call1(); call2( \\$... ); call3() \\\\; \\text_macros := \\\\\\ string for the lexer \\\\\\; # Ordinary macros (macro body is a valid expression) \\macro := replace(); \\macro2($arg) := { call( \\$arg ); call() }; # The function takes the number of arguments and the arguments themselves \\\\func name1(...)\\\\ := name2( \\$#, \\$name1... ); # macro body from a sequence of tokens \\if(...) := \\\\ [ \\$... ] --\u003e \\\\; # Expression may not be complete \\else := \\\\ ,[ _ ] --\u003e \\\\; # Expression may not be complete # Macro body from text string (like in C/C++ preprocessor) \\macro_str := \\\\\\ string - macro body \\\\\\; # String for the lexer \\macro($arg) := \\\\ func_ \\## \\#arg(\\#arg)\\\\; # macro(arg) -\u003e func_arg (\"arg\") What possibilities does this offer? You can define macros in the following combinations this way:\n№ Macro name Macro body ---------------------------------------------------------------- 1. \\identifier expression 2. \\identifier \\\\lexem1 lexeme2\\\\ 3. \\Identifier \\\\\\string for the lexer\\\\\\. 4. \\\\lexeme1 lexeme2\\\\ expression 5. \\\\lexeme1 lexeme2\\\\ \\\\lexeme1 lexeme2\\\\ 6. \\\\lexeme1 lexeme2\\\\ \\\\\\ line for the lexer \\\\\\ Each of the above combinations has its own properties and limitations: Classic replacement of one term with another term or integer expression. It is handled by lexer and parser once during definition. The expression in the macro body has to be correct in terms of syntax, and if there are errors in it, a message about this is generated immediately, while still defining the macro.\nClassical replacement of one term by sequences of tokens, including incomplete syntactic constructions. It is processed by the lexer once during macro definition. The body of the macro is parsed by the parser when it is used, so possible syntax errors will be noticed only when the macro is expanded.\nClassic replacement of a single term with a text string, which is fed to the lexer’s input. Only the macro name is once processed by the lexer when it is defined, allowing you to modify the macro body and change/combine/modify lexemes before feeding them into the analyzer. Syntax errors will be noticed only when the macro is expanded.\n4, 5 и 6. Replacing a sequence of several tokens (templates) with an expression, a sequence of tokens or a text string, respectively.\nPurpose and examples of use Macros are also used to convert the basic NewLang syntax into a more familiar keyword-based syntax, because such text is much easier to understand when reading the source code later.\nIf no modifier is specified before the name of NewLang object (**\\**macros, **$**local_variable or **@**module), then macros name is searched first, then the name of local variable and last, the name of module (module object). This makes it possible to define DSL syntax in the usual way without the obligatory prefixes for different types of objects.\nFor example, writing a conditional statement in the basic syntax NewLang:\n[condition] --\u003e { ... } [ condition2 ] --\u003e { ... } [ _ ] { ... }; # With macros \\if(...) := \\\\ [ \\$... ]--\u003e \\\\; \\elif(...) := \\\\ ,[ \\$... ]--\u003e \\\\; \\else := \\\\ ,[ _ ]--\u003e \\\\; # Turns into classical notation if( condition ){ ... } elif( condition2 ){ ... } else { ... }; Or loop to 5:\ncount := 1; [ 1 ] \u003c-\u003e { [ count\u003e5 ] --\u003e { ++ 42 ++; }; count += 1; }; will look more familiar with the use of appropriate macros:\n\\while(...) := \\\\ [ \\$... ] \u003c-\u003e \\\\; \\return(...) := ++ \\$... ++; \\true := 1; count := 1; while( true ) { if( count \u003e 5 ) { return 42; }; count += 1; }; Deleting macros To delete a macro, you have to assign it an empty sequence of tokens \\macro_str := \\\\\\\\;. You can use a special syntax to delete it: \\\\\\\\ name \\\\\\\\; or \\\\\\\\ \\\\two terms\\\\ \\\\\\\\;, i.e. specify the macro name between four backslashes.\nThe necessity to use a separate syntax construct to remove macros is caused by the fact that macro names are processed by the lexer even before the parsing stage in the parser.\nWhat’s the upside? You can dilute the basic language syntax with additional keywords and turn it into a familiar “keyword-based” syntax. Macros are defined according to the language’s vocabulary, and macros are treated as normal objects. Ease of source code analysis and debugging. You can make explicit use of DSL terms and metaprogramming techniques, for example, always prefix the macro name. That way the compiler will know very well that the macro needs to be expanded. Although you can modify the language syntax significantly at your own risk, you can only do so within certain constraints (AST cannot be modified directly), which does not allow you to go very far and, for example, crash or hang the compiler. In spite of very big possibilities to modify the syntax, you get a very simple, fast and unambiguous implementation. And this positively affects the speed of source code analysis, detection and processing of possible errors and simultaneously represents a reasonable compromise between the complexity of implementation of this functionality and possibilities of defining own DSL dialects. If desired, there is room to develop metaprogramming capabilities. In the future we could add pattern-matching (e.g. based on regular expressions), make string parametrization for generating syntax in the body of a macro, including in runtime, and many other different ways to elegantly shoot yourself or your comrade in the foot. Conclusion Any feedback on this macro implementation would be appreciated. And twice as grateful if, in addition to criticism, there are suggestions for its improvement and refinement, if any point has been missed.\n","categories":"","description":"A short lead description about this content page. Text here can also be **bold** or _italic_ and can even be split over multiple paragraphs.\n","excerpt":"A short lead description about this content page. Text here can also …","ref":"/blog/dsl-domain-specific-language-implementation-with-macros/","tags":"","title":"DSL (domain-specific language) implementation with macros"},{"body":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag предыдущей версии.\nАктуальную версию синтаксиса языка можно посмотреть тут.\nБлизится релиз языка NewLang с принципиальной новой «фишкой», переделанным вариантом препроцессора, который позволяет расширять синтаксиса языка для создания различных диалектов DSL за счет макросов.\nИ, как всегда, используя ранее найденный лайфхак Хабр — ума палата, хотелось бы получить от читателей обратную связь насчет предлагаемого ниже подхода, который планируется к реализации в новом препроцессоре NewLang.\nО чем идет речь? DSL (Предметно-ориентированный язык) - язык программирования, специализированный для конкретной области применения. Считается, что использование DSL существенно повышает уровень абстрактности кода, а это позволяет вести разработку более быстро и эффективно и существенно упрощает решение многих задач.\nУсловно, можно выделить два подхода к реализации DSL: Разработка независимых трансляторов синтаксиса с помощью генераторов лексеров и парсеров для определения грамматики целевого языка посредством БНФ и регулярных выражений (Lex, Yacc, ANTLR и т. д.) и последующей компиляцией полученной грамматики в машинный код. Разработка или встраивание диалекта DSL на языке (метаязыке) общего назначения, в том числе за счет применения различных библиотек или специальных парсеров / препроцессоров. Далее речь пойдет о втором варианте, а именно, о реализации DSL на базе языков (метаязыков) общего назначения и новом варианте реализации макросов в NewLang как основы для разработки DSL.\nДве крайности Наверно имеет смысл начать с описания о двух крайностях при реализации DSL на базе языка (метаязыка) общего назначения:\nОграниченная грамматика Если язык программирования ограничен собственной фиксированной грамматикой и не допускает её расширения, то при реализации DSL разработчик будет вынужден использовать уже существующую грамматику, правила записи операций и вообще весь синтаксис будет оставаться такими же, как в языке реализации. Например, при использовании в качестве базового языка С/С++ или применении различных библиотек и фреймворков в других языках программирования общего назначения.\nВ этом случае под термином “DSL” будет скрываться просто набор специфических терминов предметной области, переопределенных макросов и/или операторов, но использование которых будет ограничено грамматикой языка реализации.\nНеограниченная грамматика Если же язык (метаязык) позволяет модифицировать собственную грамматику (например на уровне AST), то DSL уже не будет жестко огранен синтаксисом базового языка программирования, и в результате его грамматика может быть какой угодно. Вплоть до того, что «для каждого нового проекта придется изучать новый язык… ». Это можно сделать с помощью использования специализированных метаязыков (Lisp, ML, Haskell, Nemerle, Forth, Tcl, Rebol и пр.)\nОчень рекомендую прочитать о метапрограммровании великолепную статью @NeoCode Метапрограммирование: какое оно есть и каким должно быть.\nДля обсуждения предлагается следующая реализация макросов «Нет в мире совершенства», и после выпуска релиза NewLang 0.2 я получил много отзывов (по большей части негативных), по поводу первого варианта реализации макросов и DSL на их основе. И если положить руку на сердце, эта критика часто была обоснованной. Поэтому я решил попробовать немного переделать макросы, в надежде получить «золотую середину» между двумя описанными выше крайностями при описании DSL.\nИспользуемая терминология Макросы в NewLang, это один или несколько терминов, которые заменяются на другой термин или на целую синтаксическую конструкцию (последовательность лексем). Макросы являются одновременно и расширением базового синтаксиса языка, при реализации собственных диалектов DSL, и синтаксическим сахаром.\nГлавная особенность макросов в том, что они позволяют изменять выражения еще до их вычисления во время выполнения. Раскрытие макросов происходит во время работы лексера, что позволяет подменять ими любые другие термины и даже модифицировать сам синтаксис языка.\nПоэтому, если перед именем объекта NewLang модификатор не указывать (**\\**макрос, **$**локальная_переменная или **@**модуль), то сперва будет производиться поиск объекта среди макросов, потом среди локальных переменных и в последнюю очередь среди модулей (объектов модуля). За счет этого можно использовать термины без обязательных модификаторов для указания конкретных типов объектов.\nОпределение макросов Для определения макросов используется точно такой синтаксис, как и для других объектов языка (применяются операторы «::=», «=» или «:=», соответственно для создания нового объекта, присвоение нового значения уже существующему или для создания объекта / присвоения нового значения объекту не зависимо от его наличия или отсутствия).\nВ общем виде, определение макроса состоит из трех частей \u003cимя макроса\u003e \u003cоператор создания/присвоения\u003e \u003cтело макроса\u003e и завершающая точка с запятой “;”.\nТело макроса Телом макроса могут быть корректное выражение языка, последовательность лексем (которые заключается в двойные обратные слеши, т.е. \\\\лексема1 лексема1\\\\) или обычная текстовая строка (обрамленная в тройные обратные слеши, т.е. \\\\\\ текстовая строка \\\\\\).\nДля соединения двух лексем в одну (аналог операции ## в препроцессоре С/С++), используется по аналогии синтаксис ##. Похожий оператор применяется и для обрамления лексемы в кавычки #, например, \\macro($arg) := \\\\ func_ \\## \\#arg(\\#arg) \\\\;? тогда вызов macro(arg) будет преобразован в func_arg (\"arg\");\nИмя макроса Именем макроса может быть одиночный идентификатор с префиксом макроса “\\” или последовательность из нескольких лексем. Если в качестве имени макроса используется последовательность лексем, то среди них должен быть как минимум один идентификатор и может присутствовать один или несколько шаблонов.\nШаблон — это специальный идентификатор который при сопоставлении может заменяться любым одиночным термином. С помощью шаблонов производится поиск по образцу и замена заданных последовательностей лексем на тело макроса.\nДля указания шаблона в начале идентификатора нужно поставить знак доллара (что соответствует записи имени локальной переменой), т. е. \\\\одна_лексема\\\\, \\\\целых три лексемы\\\\ **\\\\**лексема $шаблон1 $шаблон2 \\\\.\nМакросы считаются одинаковыми, если их идентификаторы равны, количество элементов в их именах совпадает, а идентификаторы и шаблоны располагаются на тех же самых местах.\nАргументы макросов Термины или шаблоны в имени макроса могут иметь аргументы, которые указываются в круглых скобках. Переданные аргументы в теле макроса записываются в месте для раскрытия как имя локальной переменой, но перед именем нужно добавить обратный слеш, т.е. \\$name.\nПроизвольное количество параметров у макроса отмечается троеточием “…”, а место для вставки этих аргументов отмечается лексемой $…. Если у макроса есть несколько идентификаторов с аргументами, то для вставки аргументов из конкретного идентификатора используется лексема с указанием нужного идентификатора, например, $name….\nЧтобы вставить количество реально переданных аргументов используется лексема $#, или с указанием нужного идентификатора, например, $#name.\nМакросы работают с лексемами, которые содержат различную информацию, в том числе и о типе данных, если она указана. Но на текущий момент типы данных в аргументах макросов никак не обрабатываются и это одна из обязательных фич, которая будет реализована в будущем.\nПримеры: \\макрос1 := 123; \\макрос2(arg) := {func( \\$arg ); func2(123);}; \\\\макрос из(...) лексем\\\\ := \\\\ call1(); call2( \\$... ); call3() \\\\; \\текстовый_макрос := \\\\\\ строка для для лексера \\\\\\; # Обычные макросы (тело макроса корректное выражение) \\macro := replace(); \\macro2($arg) := { call( \\$arg ); call()}; # В функцию передается кол-во аргументов и сами аргументы \\\\func name1(...)\\\\ := name2( \\$#, \\$name1... ); # Тело макросов из последовательности лексем \\if(...) := \\\\ [ \\$... ] --\u003e \\\\; # Выражение может быть не полным \\else := \\\\ ,[ _ ] --\u003e \\\\; # Выражение может быть не полным # Тело макроса из текстовой строки (как в препроцессоре С/С++) \\macro_str := \\\\\\ строка - тело макроса \\\\\\; # Строка для лексера \\macro($arg) := \\\\\\ func_ \\## \\#arg(\\#arg)\\\\\\; # macro(arg) -\u003e func_arg (\"arg\") Какие возможности это дает? Таким образом можно определить макросы в следующих комбинациях:\n№ п/п Имя макроса Тело макроса ---------------------------------------------------------------- 1. \\идентификатор выражение 2. \\идентификатор \\\\лексема1 лексема2\\\\ 3. \\идентификатор \\\\\\строка для лексера\\\\\\ 4. \\\\лексема1 лексема2\\\\ выражение 5. \\\\лексема1 лексема2\\\\ \\\\лексема1 лексема2\\\\ 6. \\\\лексема1 лексема2\\\\ \\\\\\строка для лексера\\\\\\ Каждая из перечисленных выше комбинации имеет свои свойства и ограничения:\nКлассическая замена одного термина на другой термин или целое выражение. Однократно обрабатывается лексером и парсером при определении. Выражение в теле макроса должно быть корректным с точки зрения синтаксиса и при наличии в нем ошибок, сообщение об этом формируется сразу, еще при определении макроса.\nКлассическая замена одного термина на последовательности лексем, в том числе и не полные синтаксические конструкции. Однократно обрабатывается лексером при определении макроса. Тело макроса анализируется парсером при его использовании, поэтому возможные синтаксические ошибки будут замечены только при раскрытии макроса.\nКлассическая замена одного термина на текстовую строку, которая подается на вход лексера. Однократно обрабатывается лексером только имя макроса при его определении, что позволяет модифицировать тело макроса и изменять/комбинировать/модифицировать лексемы до их подачи в анализатор. Синтаксические ошибки будут замечены только при раскрытии макроса.\n4, 5 и 6. Замена последовательности из нескольких лексем (шаблонов) на выражение, последовательность лексем или текстовую строку соответственно.\nНазначение и примеры использования Макросы используются и для преобразования базового синтаксиса NewLang в более привычный синтаксис на основе ключевых слов, так как такой текст гораздо легче воспринимается при последующем чтении исходного кода.\nЕсли перед именем объекта NewLang модификатор не указан (**\\**макрос, **$**локальная_переменная или **@**модуль), то сперва ищется имя макроса, потом имя локальной переменной и в последнюю очередь имя модуля (объекта модуля). За счет этого получается определять синтаксис DSL в привычной записи без обязательных префиксов у разных типов объектов.\nНапример, запись условного оператора на основном синтаксисе NewLang:\n[condition] --\u003e { ... } [ condition2 ] --\u003e { ... } [ _ ] { ... }; # С помощью макросов \\if(...) := \\\\ [ \\$... ]--\u003e \\\\; \\elif(...) := \\\\ ,[ \\$... ]--\u003e \\\\; \\else := \\\\ ,[ _ ]--\u003e \\\\; # Превращается в классическую запись if( condition ){ ... } elif( condition2 ) { ... } else { ... }; Или цикл до 5:\ncount:=1; [ 1 ] \u003c-\u003e { [count\u003e5] --\u003e { ++ 42 ++; }; count+=1; }; будет выглядеть более привычно с использованием соответствующих макросов:\n\\while(...) := \\\\ [ \\$... ] \u003c-\u003e \\\\; \\return(...) := ++ \\$... ++; \\true := 1; count := 1; while( true ) { if( count \u003e 5 ) { return 42; }; count += 1; }; Удаление макросов Для удаления макроса нужно присвоить ему пустую последовательность лексем \\macro_str := \\\\\\\\;. Так же для удаления можно использовать специальный синтаксис: \\\\\\\\ name \\\\\\\\; или \\\\\\\\ \\\\два термина\\\\ \\\\\\\\;, т.е. указать имя макроса между четырьмя обратными слешами.\nНеобходимость использования отдельной синтаксической конструкции для удаления макросов вызвана тем, что имена макросов обрабатываются лексером еще до этапа анализа в парсере.\nВ чем профит? Базовый синтаксис языка можно разбавлять дополнительными ключевыми словами и превратить его в привычный «keyword-based». Определение макросов соответствует лексике языка, а сами макросы обрабатываются как обычные объекты. Простота анализа исходного кода и его отладки. Использование терминов DSL и приемов метапрограммирование можно сделать явным, например, всегда перед именем макроса указывать префикс. В этом случае компилятор будет однозначно знать, что требуется выполнить раскрытие макроса. Несмотря на то, что синтаксис языка на свой страх и риск можно значительно модифицировать, но это можно сделать только в рамках определенные ограничений (AST нельзя модифицировать напрямую), что не позволяется очень сильно разгуляться и, например, обрушить или подвесить компилятор. Несмотря на очень большие возможности по модификации синтаксиса, получается очень простая, быстрая и однозначная реализация. А это положительно сказывается на скорости анализа исходников, детектирования и обработки возможных ошибок и одновременно является разумным компромиссом между сложностью реализации данного функционала и возможностями определения собственных диалектов DSL. При желании есть куда развивать возможности метапрограммирования. В будущем можно добавить сопоставление шаблона с образцом (например, на основе регулярных выражений), сделать параметризацию строки для генерации синтаксиса в теле макроса, в том числе и в рантайме, и много других разных способов изящно выстрелить себе в ногу или ногу своего товарища. Заключение Буду благодарен за любую обратную связь по данной реализации макросов. И дважды благодарен, если кроме критики будут высказаны еще и предложения по её улучшению и доработкам, если какой-то момент был упущен.\nСсылка на первую публикаци\n","categories":"","description":"","excerpt":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag …","ref":"/ru/blog/dsl-with-macros/","tags":"","title":"Вариант реализации DSL (domain-specific language) с помощью макросов"},{"body":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag предыдущей версии.\nАктуальную версию синтаксиса языка можно посмотреть тут.\nNewLang — это язык программирования высокого уровня общего назначения. Основной особенностью языка является простой, логичный и не противоречивый синтаксис, который основан на строгой системе грамматических правил. За счет использования макросов, синтаксис языка легко расширяется до более привычного вида на основе ключевых слов.\nNewLang находится в процессе активного развития. Это третий публичный релиз в который добавлены новые существенные возможности по сравнению с предыдущей версией.\nЗачем нужен NewLang? У всех современных языков программирования происходит постоянное развитие (усложнение) синтаксиса по мере выхода новых версий. Это является своего рода платой за появление новых возможностей и воспринимается пользователями как естественное явление.\nНо одновременно является и серьезной проблемой, так как с выходом версий добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки и поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.\nУ NewLang сложность языковых конструкций ограничена естественным образом за счет разделения синтаксиса языка на две части - это упрощает его изучение и использование.\nОсновной синтаксис — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, который основан не на зарезервированных ключевых словах, а на системе строгих грамматических правил. Имеется возможность расширения основного синтаксиса за счет использования макросов. Расширенный синтаксис — программные вставки на языке реализации (С/С++), когда основного синтаксиса становится недостаточно.\nЕще одно неудобство современных языков в том, что большинство из них были созданы до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек. Это же касается и вычислений с неограниченной точностью, которые так же требуют применения дополнительных библиотечных функций.\nУ NewLang тензорные вычисления и рациональные числа неограниченной точности доступны «из коробки». Они поддерживаются на уровне синтаксиса для записи литералов соответствующих типов, а простые арифметические типы данных являются скалярами (тензорами нулевой размерности). Реализация тензорных вычислений сделана на базе библиотеки libtorch, а рациональные числа с использованием OpenSSL.\nНовые глобальные фичи и изменения в синтаксисе: Простые чистые функции удалены Раньше я пытался использовать синтаксис предикатов из Пролога, в котором проверки условий записываются через запятую. Но эта идея оказалась провальной, а сами операторы просто ужасными (тестировал разные варианты, но каждый раз получал много отрицательных отзывов), поэтому сейчас решил полностью от них отказаться.\nОни получались не только сложными для восприятия, но и по факту не нужными, так как легко заменялись обычной функцией с комбинации обычных логических операций.\nЗафиксирован синтаксис операторов проверки условия и циклов. Изменен и упрощен синтаксис операторов проверки условия (импликации) и цикла, для которых оставлено только по одному варианту. Проверка условия записывается в виде оператора математического следования –\u003e, а цикл с помощью оператора \u003c-\u003e.\nНо для упрощения записи можно пользоваться макросами, тогда в этом случае операции проверки условий и циклы превращаются в классические\n\\if(...){ ... } \\elif(...) { ... } \\else { ... }; или\n\\while( ... ){ ... }; Конструкция else у операторов цикла Теперь оператор цикла while поддерживает конструкцию else, которая выполняется если условие входа в цикл не было выполнено. Это поведение отличается от аналогичных конструкций в языке Python, у которого секция else выполняется всегда, кроме прерывания цикла по break.\nВетка else у оператора цикла записывается так же как и ветка иначе в условном операторе, т. е.\n[ cond ] \u003c-\u003e { ... }, [_] --\u003e { ... }; Или тоже самое, но с использованием макросов:\n\\while(cond) { ... } \\else { ... }; Пространства имен В синтаксис NewLang добавлены пространства имен, в стиле очень похожим на С++. Имена разделяются двойным двоеточием, а для определение пространства имен, его нужно указать перед открывающейся фигурной скобкой.\nns { name { var := 0; # Имя переменной будет ns::name::var ::var := 1; # Переменная из глобального пространства имен } } Программные модули Реализована концепция программных модулей - которая повторяет концепцию иерархического расположения файлов в структуре каталогов файловой системы, как в языках Python и Java.\nИмя модуля начинается на префикс @, а структура каталогов указывается через точку. Причем концепции программных модулей и пространства имен объединены, и полное имя переменой из предыдущего абзаца будет @root.dir.module::ns::name::var, где root и dir это каталоги в файловой системе, а module — имя файла.\nОбъектно ориентированное программирование Реализована часть концепции ООП и добавлена поддержка определения классов и их наследование, которая сейчас выглядит следующим образом:\n:NewClass := :Class() { # Новый тип (класс) field := 1; method() := {}; }; obj := :NewClass(); # Экземпляр класса Неожиданно для самого себя понял, что имея полный набор вариантов проверок при создании объектов (::= - создать новый объект, := - создать новый или присвоить значение существующему, = - только присвоить значение, а если объект не существует будет ошибка), концепция переопределения наследуемых функций не требует вообще никаких ключевых слов:\n:NewClass2 := :NewClass() { # Новый класс на базе существующего field ::= 2; # Будет ошибка, т. к. поле field уже есть в базовом классе method() = {}; # Аналог override, т.к. method должен существовать в базовом классе }; Прерывания, возврат и обработка ошибок Изменена, а точнее полностью переделана идеология возвратов из функций и обработки ошибок. Теперь она чем-то похожа на подход, примененный в Ruby. Любая последовательность команд заключенные в фигурные скобки (в том числе тело функции), рассматривается как блок кода у которого нет специального оператора аналога return, который возвращает какое либо значение. Просто любой блок кода всегда возвращает последнее вычисленное значение (это чем то похоже на оператор «запятая» в языках C/C++).\nДля того, чтобы прервать выполнение кода используются две разные команды - прерывания, которые условно можно назвать положительным и отрицательным результатом. Что примерно соответствует семантике их записи. “Отрицательное” прерывание записывается в виде двух минусов, а “положительное” прерывание в виде двух плюсов, т.е. -- или ++.\nПо умолчанию данные операции возвращают пустое значение. Чтобы прерывание вернуло результат, возвращаемые данные нужно записывать между парой соответствующих символов, т.е. -- 100 --, что является близким аналогом оператора return 100; в других языках программирования, а ++«Строка»++ - аналогом return «Строка»;.\nХотя более точным аналогом этих операторов будет все таки не return, а throw, т.к. эти команды не только прерывают выполнение последовательности команд в блоке, но их еще можно «ловить». Для этого используется блок кода с соответствующей семантикой, {+ … +} - блок кода, который перехватывает положительные прерывания и {- … -} - блок кода, который перехватывает прерывания, созданные операторами –.\nПодобная концепция (в явном виде не разделять возвраты из функций и обработку исключений), хоть и выглядит немного необычной, но позволяет реализовывать несколько очень полезных финтов, которые сложно реализуемые в обычных языках программирования.\nНапример, возврат из нескольких вложенных функций без необходимости обрабатывать результат возврата каждой из них. В этом примере функция Test перехватывает “положительные” прерывания из вложенных функций:\nTest0(arg) := { \\if($arg==0) \\return(\"DONE - 0\"); «FAIL» }; Test1(arg) := { \\if($arg==1) \\return(\"DONE - 1\"); Test0($arg); }; Test(arg) := {+ \\if($arg \u003e= 0) Test1($arg); $arg; +}; Test(0); # Вернет «DONE — 0» возврат из вложенной функции Test0 Test(1); # Вернет «DONE — 1» возврат из вложенной функции Test1 Test(2); # Вернет «FAIL» возврат из вложенной функции Test0 Test(-2); # Вернет -2 — возврат из функции Test Есть еще блок {* … *}, который перехватывает оба типа прерываний. Такой блок кода поддерживает типизацию возвращаемого значения, что позволяет в явном виде указывать типы данных, которые нужно перехватывать. Например, {* ... *} :Type1 — будет перехвачено прерывание вида ++ :Type1 ++ или --:Type1--, что позволяет очень гибко формировать логику работы программы.\nБлоки кода с перехватом исключений также поддерживают оператор иначе (\\else) который, по аналогии с оператором \\else в циклах, выполняется только тогда, если прерывания не произошло.\nМожно указать сразу несколько типов, которые нужно перехватывать:\n{* .... *} \u003c:Type1, :Type2, :Type3\u003e; Бинарная сборка под Windws: В текущем релизе версия clang повышена 15, а вызовы нативных функций опять реализованы с помощью libffi, что в итоге позволило собрать бинарную сборку не только под Linux, но и под Windows. И теперь чтобы поиграться с REPL read-eval-print loop можно скачать уже готовый бинарник.\nПодробная информация о языке: Синтаксис NewLang Подробное описание типов данных Операторы и управляющие конструкции Вся документация по NewLang на одной странице Обратная связь Если у вас появятся предложения по развитию нового или улучшению уже существующего функционала NewLang, пишите.\nПримеры кода #!../output/nlc --eval # Определение функции hello hello(str) := { # Импорт стандартной C функции printf := :Pointer('printf(format:FmtChar, ...):Int32'); # Вызов C функции с проверкой типов аргументов по строке формата printf('%s', $str); # Возврат значения из функции hello $str; }; hello('Привет, мир!'); # Вызвать функцию\u003c/code\u003e Вывод (первая строка выводится с помощью printf, а вторая — возвращаемое значение функции hello):\nПривет, мир! Привет, мир! Пример скрипта для вычисления факториала 1000\n#!../output/nlc --eval fact := 1\\1; # Рациональное число без ограничения точности mult := 1000..1..-1?; # Сделать из диапазона итератор для множителей от 1000 до 2 [mult ?!] \u003c-\u003e { # Цикл, пока не закончатся данные итератора # Получить текущий множитель и перейти на следующий элемент итератора fact *= mult !; }; fact # Вывести итоговый результат Вывод:\n402387260077093773543702433923003985719374864210714632543799910429938512398629 020592044208486969404800479988610197196058631666872994808558901323829669944590 997424504087073759918823627727188732519779505950995276120874975462497043601418 278094646496291056393887437886487337119181045825783647849977012476632889835955 735432513185323958463075557409114262417474349347553428646576611667797396668820 291207379143853719588249808126867838374559731746136085379534524221586593201928 090878297308431392844403281231558611036976801357304216168747609675871348312025 478589320767169132448426236131412508780208000261683151027341827977704784635868 170164365024153691398281264810213092761244896359928705114964975419909342221566 832572080821333186116811553615836546984046708975602900950537616475847728421889 679646244945160765353408198901385442487984959953319101723355556602139450399736 280750137837615307127761926849034352625200015888535147331611702103968175921510 907788019393178114194545257223865541461062892187960223838971476088506276862967 146674697562911234082439208160153780889893964518263243671616762179168909779911 903754031274622289988005195444414282012187361745992642956581746628302955570299 024324153181617210465832036786906117260158783520751516284225540265170483304226 143974286933061690897968482590125458327168226458066526769958652682272807075781 391858178889652208164348344825993266043367660176999612831860788386150279465955 131156552036093988180612138558600301435694527224206344631797460594682573103790 084024432438465657245014402821885252470935190620929023136493273497565513958720 559654228749774011413346962715422845862377387538230483865688976461927383814900 140767310446640259899490222221765904339901886018566526485061799702356193897017 860040811889729918311021171229845901641921068884387121855646124960798722908519 296819372388642614839657382291123125024186649353143970137428531926649875337218 940694281434118520158014123344828015051399694290153483077644569099073152433278 288269864602789864321139083506217095002597389863554277196742822248757586765752 344220207573630569498825087968928162753848863396909959826280956121450994871701 244516461260379029309120889086942028510640182154399457156805941872748998094254 742173582401063677404595741785160829230135358081840096996372524230560855903700 624271243416909004153690105933983835777939410970027753472000000000000000000000 000000000000000000000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000000000000000000000000\\1 Как посмотреть? Бинарная сборка и тесты под Windows Бинарная сборка и тесты под Ubuntu Для запуска бинарных сборок потребуются разделяемые библиотеки libLLVM-15 и libtorch (архив с библиотеками для Windows), (архив с библиотеками для Ubuntu). Так же все можно собрать напрямую из исходников по инструкции в репозитории ","categories":"","description":"","excerpt":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag …","ref":"/ru/blog/release-v0.3/","tags":"","title":"Релиз языка программрования NewLang 0.3"},{"body":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag предыдущей версии.\nАктуальную версию синтаксиса языка можно посмотреть тут.\nNewLang - это язык программирования высокого уровня в котором можно сочетать стандартные алгоритмические конструкции с декларативным программированием и тензорными вычислениями для задач машинного обучения.\nОсновной особенностью языка является простой, логичный и не противоречивый синтаксис, который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил с использованием знаков препинания (в список которых входят и операторы языка).\nNewLang находится в процессе активного развития и это второй публичный релиз в котором добавлены существенные новые возможности и произошли некоторые изменения по сравнению с предыдущей версией.\nОсобенности языка: Возможность работы как в режиме интерпретатора, так и компилятора*. Динамическая и статическая типизация с возможностью указания типов в явном виде. Статическая типизация является условно строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных, например, целое число может быть автоматически преобразовано в вещественное или рациональное, но не наоборот). Автоматическое управление памятью. ООП в виде явного наследования классов и «утиная» типизация. На уровне синтаксиса поддержка нескольких типов функций (обычные и чистые функции без побочных эффектов). Необязательные и именованные параметры функций. Возможны вставки кода на языке реализации (С/С++)*. Простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++). Имеется REPL read-eval-print loop — «цикл: чтение — вычисление — вывод». Новые глобальные фичи: Добавлены макросы. Теперь можно делать собственные языковые диалекты и использовать более привычную запись алгоритмических конструкций с использование ключевых слов. Например, цикл [ cond ] \u003c-\u003e { тело цикла }; можно записать в более привычный нотации\n\\while (cond) { тело цикла }; Добавлены итераторы для перебора элементов словарей или для запросов к другим контейнерам (например, к базам данных). На уровне базового синтаксиса поддерживается фильтрация данный, включая функциональный аналог LINQ за счет применения функций обратного вызова в качестве условия фильтра. Добавлен новый тип данных — рациональные числа с неограниченной точностью. Они записываются в виде обыкновенной дроби, у которой разделитель бекслеш, например единицу можно записать 1\\1, а число 0.5 как 1\\2. Реализован оператор распаковки словаря … (многоточие), который можно использовать чтобы передать несколько аргументов при вызове функции или для присвоения значения сразу нескольким переменным. Теперь оператор присвоения поддерживает установку значений сразу нескольким переменным. С правой стороны от оператора присвоения может находится одно или несколько значений или оператор распаковки словаря. Причем словарь может быть указан и с левой стороны от оператора присвоения и таким образом можно записать самый простой способ перебора всех его элементов, когда в цикле первый элемент словаря сохраняется в переменную item, а из самого словаря удаляется: [ dict ] \u003c-\u003e { item, dict := ... dict; }; Изменения в синтаксисе: Изменена запись циклов. Вместо двух разных типов с предусловием и постусловие, теперь используется единая форма записи, а тип цикла определяется взаимным расположением условия и его тела. Изменены названия арифметических и некоторых других типов данных на более логичные. В именах арифметических типов теперь указан их размер (Int8, Int16 … Float32, Float64 и т.д.). Многострочные комментарии стали вложенными Подробная информация о языке: Основные правила синтаксиса: Встроенные типы данных: Операторы и управляющие конструкции: Примеры кода ``` #!../output/nlc --eval Определение функции hello hello(str) := {\n# Импорт стандартной C функции printf := :Pointer('printf(format:FmtChar, ...):Int32'); # Вызов C функции с проверкой типов аргументов по строке формата printf('%s', $str); # Возврат значения из функции hello $str; };\nhello(‘Привет, мир!’); # Вызвать функцию\nВывод (первая строка выводится с помощью printf, а вторая - возвращаемое значение функции hello): Привет, мир! Привет, мир! \u003cspoiler title=\"Пример скрипта для вычисления факториала 1000\"\u003e #!../output/nlc –eval\n@fact := 1\\1; # Рациональное число без ограничения точности @mult := 1000..1..-1?; # Сделать из диапазона итератор для множителей от 1000 до 2 [mult ?!] \u003c-\u003e { # Цикл, пока не закончатся данные итератора # Получить текущий множитель и перейти на следующий элемент итератора fact *= mult !; }; fact # Вывести итоговый результат\nВывод: 402387260077093773543702433923003985719374864210714632543799910429938512398629 020592044208486969404800479988610197196058631666872994808558901323829669944590 997424504087073759918823627727188732519779505950995276120874975462497043601418 278094646496291056393887437886487337119181045825783647849977012476632889835955 735432513185323958463075557409114262417474349347553428646576611667797396668820 291207379143853719588249808126867838374559731746136085379534524221586593201928 090878297308431392844403281231558611036976801357304216168747609675871348312025 478589320767169132448426236131412508780208000261683151027341827977704784635868 170164365024153691398281264810213092761244896359928705114964975419909342221566 832572080821333186116811553615836546984046708975602900950537616475847728421889 679646244945160765353408198901385442487984959953319101723355556602139450399736 280750137837615307127761926849034352625200015888535147331611702103968175921510 907788019393178114194545257223865541461062892187960223838971476088506276862967 146674697562911234082439208160153780889893964518263243671616762179168909779911 903754031274622289988005195444414282012187361745992642956581746628302955570299 024324153181617210465832036786906117260158783520751516284225540265170483304226 143974286933061690897968482590125458327168226458066526769958652682272807075781 391858178889652208164348344825993266043367660176999612831860788386150279465955 131156552036093988180612138558600301435694527224206344631797460594682573103790 084024432438465657245014402821885252470935190620929023136493273497565513958720 559654228749774011413346962715422845862377387538230483865688976461927383814900 140767310446640259899490222221765904339901886018566526485061799702356193897017 860040811889729918311021171229845901641921068884387121855646124960798722908519 296819372388642614839657382291123125024186649353143970137428531926649875337218 940694281434118520158014123344828015051399694290153483077644569099073152433278 288269864602789864321139083506217095002597389863554277196742822248757586765752 344220207573630569498825087968928162753848863396909959826280956121450994871701 244516461260379029309120889086942028510640182154399457156805941872748998094254 742173582401063677404595741785160829230135358081840096996372524230560855903700 624271243416909004153690105933983835777939410970027753472000000000000000000000 000000000000000000000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000000000000000000000000\\1\n## Как посмотреть? - [Загрузить собранный REPL и тесты (пока только под Ubuntu)](https://github.com/rsashka/newlang/releases/download/v0.2.0/nlc_bin.tar.xz) - Для запуска бинарных файлов потребуются разделяемые библиотеки libLLVM-13 и libtorch: [архив только с нужными библиотеками](https://github.com/rsashka/newlang/releases/download/v0.2.0/nlc_so.tar.xz). - Так же все можно собрать напрямую из исходников по инструкции в [репозитории](https://github.com/rsashka/newlang) ","categories":"","description":"","excerpt":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag …","ref":"/ru/blog/release-v0.2/","tags":"","title":"Релиз языка программрования NewLang 0.2"},{"body":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag предыдущей версии.\nАктуальную версию синтаксиса языка можно посмотреть тут.\nNewLang - это язык программирования высокого уровня, в котором можно сочетать стандартные алгоритмические конструкции с декларативным программированием и тензорными вычислениями для задач машинного обучения.\nОсновной особенностью языка является простой, логичный и не противоречивый синтаксис, который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил с использованием знаков препинания (в список которых входят и операторы языка).\nНовое по сравнению с прошлым выпуском:\nРеализованы все основные алгоритмические конструкции: проверка условий, различные варианты циклов, сравнение по образцу, прерывание последовательности команд и возврат данных, обработка ошибок и т.д. Переработан основной синтаксис для отдельных языковых конструкций. Реализованы большинство операций с переменными, включая операторы раскрытие списков и тензоров. Серьезно переработана система встроенных типов, реализованы функции для их преобразования и для определения данных (последнее можно назвать data comprehensions). Добавлены новые тесты и пр. Зачем нужен NewLang? У всех современных языков программирования происходит постоянное развитие (читай усложнение) синтаксиса по мере выхода новых версий. Это является своего рода, платой за появление новых возможностей и воспринимается пользователями как естественное явление.\nНо одновременно является и серьезной проблемой, т.к. с выходом новых версий добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки и трудоемкости поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.\nУ NewLang сложность языковых конструкций естественно ограничена за счет разделения синтаксиса языка на две части, что упрощает его изучение и использование.\nОсновной синтаксис — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, который основан не на зарезервированных ключевых словах, а на строгих грамматических правилах и Расширенный синтаксис — когда основного синтаксиса становится недостаточно, или требуется использовать языковую конструкцию языка реализации.\nЕще одно неудобство современных мейнстримовых языков, большинство из них были созданы до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов.\nУ NewLang тензорные вычисления доступны «из коробки» (используется библиотека libtorch), а обычные числа являются скалярами (тензорами нулевой размерности).\nСинтаксис NewLang При разработке синтаксиса я старался придерживаться уже сложившихся в IT индустрии правил, чтобы не генерировать множественных смыслов, которые будут зависеть от контекста.\nОсновы\nОператоры разделяются точкой с запятой «;». Отступы и переводы строк игнорируются (очень хотелось иметь возможность автоматического форматирование кода). Многострочные комментарии в исходном коде соответствуют стилю С/С++ и должны располагаться между символами /* и */. Вложенность многострочных комментариев не поддерживается. Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash. Последовательность команд, которая должна выполняться как единое целое, заключается в фигурные скобки «{}». Программные вставки расширенного синтаксиса на языке реализации заключается в фигурные скобки со знаком процента %{ /* тут может быть любой код на C/C++*/ %}, как в лексерах lex и flex. Создания объектов и присвоения новых значений Для создания объектов и присвоения им новых значений в NewLang используется сразу три разных оператора:\n::= используется только для создания новых объектов, а если объект с таким именем уже существует, то генерируется ошибка. := используется для тех же целей, но если объект с таким именем уже существует, то ошибки не происходит, а новое значение присваивается уже существующему объекту. = применяется только для присвоения значения уже существующим объектам, и если объект с указанным именем отсутствует, то тоже происходит ошибка выполнения. Использование трех разных операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе.\nvar ::= 1.0; # Создать новую переменную var без указания типа var = 100; # Присвоить новое значение уже существующей переменной printf := @import('printf(format:Format, ...):Int'); /* Создать новый или переопределить объект printf, который будет результатом выполнения глобальной функции @import */ Идентификаторы объектов и модификаторы В качестве идентификаторов можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой.\nВ NewLang существует возможность указания области видимости и времени жизни объекта с помощью модификатора — специального символа перед именем переменной. Это может показаться немного похожим на венгерскую нотацию, но в отличие от нее, модификатор не имеет отношения к типу объекта и не является частью имени идентификатора. К тому же в качестве модификаторов используется строго определённые символы, назначение которых определено заранее.\n$ - в начале имени обозначает локальную переменную, время жизни которой ограничено текущей областью видимости и при её завершении локальная переменная уничтожается. @ - обозначает глобальную переменную, а сам объект сохраняет свое состояние даже после выхода из текущей области видимости. : - двоеточие вначале имени используется в качестве модификатора для указания типа. Семантика обращения к аргументам функций очень похоже на работу с аргументами в bash скриптах, где $1 или $arg — порядковый номер или имя аргумента (происходит обращение к локальным переменным в текущей области видимости).\nИспользование модификаторов является обязательным только в двух случаях: При создании нового типа данных, так как типы всегда создаются в глобальной области видимости, а их символьные имена должны быть уникальными. При обращении к объектам NewLang внутри программных вставок кода на языке реализации, так как они используется как маркеры при поиске идентификаторов NewLang в коде С/С++. В остальных случаях, для обращения к переменным указывать их модификаторы необязательно. И если при обращении к объекту модификатор не указан, то сперва ищется локальная переменная, а потом глобальная с таким же именем. Причем, локальная переменная будет перекрывать глобальную.\nТак же следует иметь в виду, что компилятор может генерировать код для прямого обращения к локальным объектам уже на этапе компиляции, тогда как для обращения к глобальным объектам, или если модификатор области видимости отсутствует, компилятор вынужден каждый раз встраивать runtime вызов функции поиска объекта в глобальной таблице символов.\nСистема типов Так как система типов языка динамическая, то явное указание типа не влияет на размер переменной и является только своего рода логическим ограничением на возможность присвоения переменной значения другого типа.\nИнформация о типах используется при проверке их совместимости, когда существующему объекту присваивается значение другого типа. Такая операция возможна только когда типы совместимы между собой и допускают автоматическое приведение. Это справедливо как во время парсинга/компиляции исходного теста, так и во время выполнения в режимах интерпретатора и/или скомпилированного файла.\nПростые типы Арифметические значения Арифметические типы данных являются тензорами — массивами чисел одного типа с произвольным количеством измерений и одинаковым размером столбцов в каждом. Единичное число тоже тензор нулевого размера.\nПоддерживаются только знаковые целые числа, т.к. в беззнаковых числах особая нужда отсутствует, а проблем с ними можно найти очень много на ровном месте.\nПроблемы беззнаковых чисел (из интернета):\nВо-первых, вычитание двух беззнаковых чисел, например 3 и 5. 3 минус 5 равно 4294967294, т.к. -2 не может быть представлено как беззнаковое число. Во-вторых, непредвиденное поведение может возникнуть при смешивании целочисленных значений со знаком и без знака. С++ может свободно преобразовывать числа со знаком и без знака, но не проверяет диапазон, чтобы убедиться, что вы не переполняете свой тип данных. В C++ всё же есть несколько случаев, когда можно (или необходимо) использовать беззнаковые числа. Во-первых, числа без знака предпочтительнее при работе с битами. Во-вторых, использование беззнаковых чисел связанных с индексацией массивов.\nНо это не мой случай, так как индекс может быть отрицательным и даже не числом, а диапазоном или многоточием.\nЗ.Ы. И даже зная об этом, все равно умудрился недавно словить баг с отрицательными индексами у словарей!\nИмена встроенных арифметических типов говорят сами за себя: Char, Short, Int, Long, Float, Double, ComplexFloat, ComplexDouble. Отдельным типом идет логический тип Bool, который может принимать значения только 0 или 1 (false/true соответственно), и в зависимости от выполняемой операции может быть отнесен к целочисленным типам, так и не входить в их состав (данный подход интерпретации логического типа данных был взят из библиотеки Torch).\n// Treat bool as a distinct \"category,\" to be consistent with type promotion // rules (e.g. `bool_tensor + 5 -\u003e int64_tensor`). If `5` was in the same // category as `bool_tensor`, we would not promote. Differing categories // implies `bool_tensor += 5` is disallowed. // // NB: numpy distinguishes \"unsigned\" as a category to get the desired // `bool_tensor + 5 -\u003e int64_tensor` behavior. We don't, because: // * We don't want the performance hit of checking the runtime sign of Scalars. // * `uint8_tensor + 5 -\u003e int64_tensor` would be undesirable. В будущем планируется добавить классы чисел для длинной арифметики и дробей, для чего зарезервированы названия типов BigNum, Currency и Fraction.\nДоступ к элементам тензора происходит по целочисленному индексу, который начинается с 0. Для многомерного тензора, индексы элемента перечисляются в квадратных скобках через запятую. Поддерживается доступ к элементам через отрицательный индекс, который обрабатывается точно так же, как в Python (-1 последний элемент, -2 предпоследний и т.д.).\nЛитерал тензор в тексте программы записывается в квадратных скобках с обязательной завершающей запятой, т.е. [1, 2,] — это литерал одномерный тензор из двух чисел. После закрывающей скобки тип тензора может быть указан в явном виде. Если тип не указан, то он выводится автоматически на основании указанных данных и выбирается минимально возможный байтовый размер, который позволяет сохранить все значения без потери точности.\nПримеры:\n$var_char := 123; # Тип Char выводится автоматически $var_short := 1000; # Тип Short выводится автоматически $var_bool := [0, 1, 0, 1,]; # Тензор из 4 элементов. Тип Bool выводится автоматически $tensor[10,10]:Int := 1; # Тензор Int размером 2x2 инициализированный 1 $scalar := $tensor[5,5]; # Присвоить скаляру значение указанного элемента тензора Строки Поддерживаются два типа строк, StrWide — символьные (широкие) и StrChar — байтовые. Различия между ними заключается в типе единичного элемента. У символьных строк единичным элементом является широкий символ wchar_t, а у байтовой строки единичным элементом является один байт (точнее char, т.е. байт со знаком). Символьные строки литералы в исходном тексте записывается в «двойных кавычках», а байтовые строки в ‘одинарных кавычках’.\nКоличество элементов символьной строки возвращается в широких символах, а размер байтовой строки в байтах, поэтому и обращение к элементу строки по индексу происходит соответственно либо к символу, либо к байту.\nВажный момент. К любой переменной можно обратиться так же, как к функции (записав после её имени круглые скобки). Результатом этой операции будет создание копии/клона объекта. Причем некоторые типы (словари, классы и символьные строки) можно использовать в качестве шаблона при создании копии объекта с модифицированными свойствами, если новые и/или изменяемые значения указать в скобках, как аргументы при вызовах функций. Так, если при создании копии в скобках указать набор новых данных, то результирующая копия будет содержать уже измененные данные.\nНапример:\n$template := \"${name} $1\"; # Обычная строка $result := $template(\"шаблон\", name = \"Строка\"); # result = \"Строка шаблон\" Системные :Pointer - указатель на системную область памяти Так как любой программе приходится взаимодействовать с внешним миром, то по неволе приходится закладывать возможность использования других библиотек и системы типов данных, и для этих целей служит тип Pointer. Он создается при импорте функций из внешних библиотек и вручную его создать нельзя. Но можно вывести его значение, например для отладки.\n:Plain - указатель на представление данных в бинарном виде Для взаимодействия с внешними библиотеками требуется еще и обмен данными. И для этих целей служит тип данных Plain - который также является указателем, но на двоичное представление данных в единой области памяти. Конечно, если их можно представить в виде единого фрагмента.\nСоставные типы данных: Словарь Словарь (:Dictionary) — набор данных произвольного типа с доступом к отдельным элементам по целочисленному индексу или по имени элемента при его наличии (он похож и на tuple и на структуру одновременно). Словари от тензоров отличаются тем, что являются только одномерными массивами, но каждый элемент может содержать произвольное количество элементов любого типа, в том числе и другие словари.\nДоступ к элементам словарей происходит по имени элемента, которое записывается через точку от имени переменной, либо по целочисленному индексу. Индекс также начинается с 0 и как у тензоров и тоже может быть отрицательным.\nЛитерал с типом «словарь» в тексте программы записывается в круглых скобках с обязательной завершающей запятой, т. е. (,) — пустой словарь, (1, 2= «2», name=3,).\nПеречисление, структура и объединение :Enum, :Struct и :Union — это такие же словари, только на их элементы накладываются определённые ограничения. Каждый элемент должен иметь уникальное имя, а его тип данных должен быть простым, т.е. числом или строкой фиксированного размера.\nКлассы Класс (реализован частично) — тип данных, с помощью которого реализуется один из принципов ООП — наследование. При создании экземпляра класса создается новая переменная, у которой сохраняется информацию о своем родителе и которая наследует от него свойства и методы. Тип данных :Class аналогичен словарю, но все свойства обязаны иметь имена (хотя доступ к свойствам класса по индексу так же возможен).\nФункции Синтаксис NewLang поддерживать несколько типов функций (а в будущем и методов классов): обычные функции, чистые функции и простые чистые функции.\nДля всех типов функций поддерживаются аргументы по умолчанию. При создании функции, её аргументы указываются как в Python, т.е. вначале идут обязательные аргументы, потом аргументы со значениями по умолчанию, где имя аргумента отделяется от его значения по умолчанию знаком равно =. Если функция допускает обработку произвольного количества аргументов, то последним в списке параметров указывается многоточие … (три точки подряд) .\nОбычная функция Обычная функция — такие функции являются именно обычными функциями в понимании С/С++. Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д.\nВнутри обычной функции можно обращаться к локальным и глобальным объектам, и они могут содержаться вставки на языке реализации*, например, для вызова функций из внешних библиотек.\nВставки на языке реализации оформляются в виде %{ %} и могут содержать любой текст на С/С++, а прямо из него можно обращаться к локальным и глобальным объектам NewLang так же, как и в обычном синтаксисе, указывая первым символом имени соответствующий модификатор ($ для локальных объектов и @ для глобальных).\nТехнически, такая программная вставка просто переносится трансплайтером непосредственно в исходный текст генерируемого файла, а все идентификаторы NewLang специальным образом декорируются (добавляются специальные маркеры для их идентификации), после этого исходный текст подается на вход обычному компилятору С++. Для локальных объектов трансплайтер может генерировать код для прямого доступа к объекту на этапе компиляции, а для работы с глобальными объектами вынужден использовать runtime вызовы функции поиска в таблице символов.\n*) - Программные вставки на языке реализации обрабатываются только во время компиляции\nНапример:\nprint(str) := { %{ printf(\"%s\", static_cast\u003cconst char *\u003e($str)); /* Прямой вызов С функции */ %} }; Чистые функции Чистая функция — это тоже обычная функция, только в том смысле, какой в него вкладывает функциональное программирование. Создания чистой функции происходит с помощью оператора :-, а сам оператор заимствован из языка Пролог. У чистой функции отсутствует доступ к контексту и глобальным переменным, поэтому она может обрабатывать только те данные, которые были ей переданы в качестве аргументов.\nПрограммные вставки на языке реализации внутри чистых функций не запрещены и могут использоваться, например, для отладки. Но делается это на страх и риск разработчика. Именно он отвечает за их «чистоту», например при вызове функций из внешних библиотек.\nSum(arg1, arg2) :- {$arg1+$arg2;}; # Вернуть сумму аргументов Простые чистые функции Простые чистые функции — отдельный класс чистых функций, которые предназначены только для вычисления логического результата (т.е. они являются предикатами) и их отличает упрощенная формой записи. Тело простой чистой функции состоит из последовательности операторов, которые разделяются запятыми и заканчиваются, как и любое выражение, точкой с запятой. Все операторы простой чистой функции всегда приводятся к булевому значению, а итоговый результат функции вычисляется по одной из возможных логических операций: И, ИЛИ и исключающее ИЛИ.\nНапример:\nfunc_and(arg1, arg2) :\u0026\u0026= arg1==3, arg2 \u003e 0; # Простая чистая функция Логическое И func_or(arg1, arg2) :||= arg1==3, arg2 \u003e 0; # Простая чистая функция Логическое ИЛИ func_xor(arg1, arg2) :^^= arg1==3, arg2 \u003e 0; # Простая чистая функция Исключающее ИЛИ Специальные типы данных: Пусто (:None) :None (пусто) — не содержит значения (точнее имеет одно значение None) и совместим с любым другим типом данных. Указывается в тексте программы как один подчерк «_». None имеют не инициализированные переменные и при попытке чтения из такой переменной возникает ошибка.\nТип переменной может быть явно указан или выведен автоматически из присваиваемого значения. Присвоить новое значение уже инициализированной переменной можно только для совместимого типа, так как неявное преобразование типов не допускаются.\n$var := _; # Создать не инициализированную переменную $var2 := var; # Ошибка!!! Нельзя прочитать неинициализированную переменную var $var = 1000; # У переменной будет тип Short (минимальный размер для хранения значения) $var = 0,5; # Ошибка!!! Short ← Float не совместимы $var = _; # Очистить значение переменной $var = 0,5; # Теперь можно, т. к. None совместим с любым типом Диапазон (:Range) Диапазон — специальный тип данных, являющейся приблизительным аналогом типа «генератор» в Python. К диапазону можно обращаться как к итератору и он будет поочередно выдавать элементы в указанном интервале с заданным шагом. Диапазон в тексте программы указывается как два или три элемента через две точки, например 1..5 — диапазон от единицы до пяти с шагом по умолчанию 1. В качестве параметров диапазона можно указывать не только литералы, но и имена переменных. Например, 0,1..$stop..0,1 — диапазон от 0,1 до значения, указанного в переменной $stop с шагом 0,1.\nДиапазон для целых чисел можно использовать в качестве индекса у тензоров (точнее, у любых объектов, которые допускают доступ к своим элементам по индексу, т.е. тензоры, словари и текстовые строки). Фактический, это поведение аналогично slice в языке Python и array[1:5] в Python означает тоже самое, что и array[1..5] в NewLang.\nВ качестве индекса у тензоров еще можно указать произвольное количество измерений с помощью многоточия, т.е.\n$tensor[…, 0] = 0; # Обнулить все первые элементы в каждом измерении. Преобразование типов Явное приведение типов Несмотря на динамическую типизацию языка, если тип переменной указан явно, то автоматическое приведение типов не выполняется, и чтобы присвоить переменой значение не совместимого типа, требуется явное преобразование.\nТак как символьные названия типов относятся к деталям реализации, то явное преобразование в конкретный тип данных производится с помощью вызова функции с именем типа, т.е. :Bool(), :StrWide(), :Long() и т.д.\nДля преобразования любого типа данных в строку ещё можно использовать оператор конкатенации строк, которой преобразует любой тип данных в строковое представление. Но, так как строковых типов два (байтовые и широкие строки), то тип строки определяется первым аргументом в операторе конкатенации/сцепления ++. Также преобразовать любое значение в строковое можно с помощью строки-шаблона.\n\"\" ++ 123; # \"123\" - Строка широких символов '' ++ 123; # '123' - Байтовая строка val := 12345; # Число \"$1\"(val); # Будет строка \"12345\" Так как тензоры могут иметь больше одного значения, то и в качестве аргументов могут принимать их произвольное количество, а итоговым результатом будет тензор, в котором все переданные данные преобразованы к требуемому типу автоматически.\nПримеры:\n\u003e tstr := :Tensor(\"Тест\"); # Создать тензор из строки широких символов [1058, 1077, 1089, 1090,]:Int \u003e t2 := :Tensor[2,2](\"Тест\"); # Тоже самое, но тензор указанной размерности [ [1058, 1077,], [1089, 1090,], ]:Int \u003e :StrWide(tstr) # Создать символьную строку из тензора Тест \u003e :Double(t2) # Изменить тип данных тезора без изменения размерности [ [1058, 1077,], [1089, 1090,], ]:Double \u003e t3 := :Char[4]( t2 ) # Изменить размерность тензора и его тип (в данном случае с частичной потерей данных) [34, 53, 65, 66,]:Char \u003e:Tensor( (1,2,3,) ); # Тензор из словаря [1, 2, 3,]:Char \u003e:Tensor( 'first second' ) # Байтовая строка в тензор [102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Char \u003e:Tensor( (first='first', space=32, second='second',) ) # Получаем тензор из словаря с такими же данными [102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Char \u003e:Double[10,2]( 0, ...) # Тензор заданного формата с нулями, где многоточие повторяет последние указанные данные до получения тензора требуемого размера [ [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], ]:Double \u003e:Int[3,2]( ... rand() ...) # Тензор со случайными данными, где между многоточиями указана функция, которую следует вызывать каждый раз при получении нового элемента тензора # Пришлось придумывать новую конструкцию, т.к. многоточие перед именем, это оператор раскрытия словаря, а многоточие после имени, это повторение последнего значения до конца заданной размерности. [ [1804289383, 846930886,], [1681692777, 1714636915,], [1957747793, 424238335,], ]:Int \u003e:Int[5,2]( 0..10 ); # Создание тензора из диапазона [ [0, 1,], [2, 3,], [4, 5,], [6, 7,], [8, 9,], ]:Int \u003e:Tensor( 0..0.99..0.1 ); # Или даже так [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9,]:Double Операторы и управляющие конструкции Операторы: Все операторы имеют парный аналог с присвоением значения:\n+ и += - сложение арифметических типов данных; - и -= - вычитание арифметических типов данных; / и /= - деление (результат число с плавающей точкой); // и //= - целочисленное деление с округлением к меньшему числу (как в Python); * и *= - умножение; ** и **= - возведение в степень (он же используется и для повторения текстовых строк); ++ и ++= - конкатенация строк с автоматическим приведением аргументов к стоковому типу (символ инкремента специально используется вместо одиночного плюса для того, чтобы в явном виде разделить конкатенацию строк и операторы арифметического сложения). Операторы сравнения: \u003c, \u003e, \u003c=, \u003e= - классические для сравнения скаляров == и != - операторы сравнения с автоматическим приведением совместимых типов для любых объектов === и !== - оператор точного сравнения для любых объектов (автоматического приведения типов не выполняется) Проверки типа (имени класса объекта): Для оператора проверки имени класса объекта используется символ тильда ~. Он немного похож на оператор instanceof в Java. Левым операндом должен быть проверяемый объект, а правым — проверяемый тип, который можно указать строкой литералом, переменной строкового типа или именем проверяемого класса непосредственно. Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта или он присутствует в иерархии наследования.\nname := \"class\"; # Строковая переменная с именем класса var ~ name; var ~ :class; # Имя типа var ~ \"class\"; # Строка литерал с именем типа Утиная типизация Оператор утиной типизации, два символа тильны ~~ — приблизительный аналог функции isinstance() в Python, который для простых типов сравнивает непосредственную совместимость типа левого операнда по отношению к правому. А для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда, т.е.:\n(field1=«value», field2=2,) ~~ (); # Истина (т. е. левый операнд словарь) (field1=«value», field2=2,) ~~ (field1=_); # Тоже истина (т. к. поле field1 присутствует у левого операнда) (field1=«value», field2=2,) ~~ (not_found=_); # Ложь, т.к. поле not_found у левого операнда отсутствует Строгая утиная типизация ~~~ — для простых типов сравнивается идентичности типов без учета совместимости, а для составных типов происходит сравнение всех свойств с помощью оператора строгого равенства. Для данной операции, пустой тип совместим только с другим пустим типом.\nУправляющие конструкции К управляющим конструкциям языка NewLang относятся условный оператор, два вида циклов, оператор оценки выражения, оператор прерывания последовательности выполнения команд и перехват прерывания. Операторы проверки условий всегда указываются в квадратных скобках, а последовательность команд для выполнения - в фигурных.\nУсловный оператор В качестве оператора проверки условия используется синтаксическая конструкция, соответствующая по смыслу термину «следует», т.е. тире и угловая скобка -\u003e или с двумя тире для большей наглядности –\u003e. Такая запись условного оператора очень похожа на математическую и легко объединяется в последовательности для проверки множественных условий вида «else if».\nВ общем случае условный оператор имеет вид: [ условие ] -\u003e действие; или [ условие ] -\u003e {действие}; или [ условие1 || условие2 ] --\u003e {действие}, [_] --\u003e {действие иначе};\nДля наглядности записанный с отступами:\n[ условие1 ] -\u003e { действие1 }, [ условие2 ] -\u003e действие2, [ условие3 ] -\u003e действие3, [_] -\u003e {действие_иначе}; Оценка выражения Синтаксическая конструкция с помощью которой реализуется аналог оператора switch выглядит следующим образом:\n[ $var ] ==\u003e { [1] -\u003e { code }; # Выполнится проверка условия $var == 1 [1, 2] -\u003e { code }; # Выполнится проверка условия ($var == 1 || $var == 2) [_] -\u003e { code default }; # Ветка условия иначе }; Причем в качестве оператора для оценки могут быть использован любые имеющиеся операторы сравнения на равенство:\n==\u003e - проверка на равенство с приведением типов; ===\u003e - проверка на точное равенство; ~\u003e - проверка типа (имени класса); ~~\u003e - утиная типизация; ~~~\u003e - строгая утиная типизация. И если в качестве оператора сравнения использовать оператор утиной типизации, то оценка выражения превращается в классический Pattern Matching:\n$value := (f1=1, f2=\"2\",); [ $value ] ~~~\u003e { [ (f1=_, ), (f1=_, f2=0, ) ] -\u003e { code }; # Поле f2 отсутствует или число [(f1=_, f2=\"\",), (f1=_, f2='',)] -\u003e { code }; # Поле f2 строка [_] -\u003e { code default }; # Код по умолчанию }; Операторы циклов Для указания операторов циклов используются управляющие -» или –» (с двумя стрелками по направлению от проверки условия к телу цикла). И в зависимости от расположения условия и тела цикла, он может быть с предусловием (while) или постусловием (do while). Хотя пока эти синтаксические конструкции не “отлежались” и их можно считать временными из-за того, что их легко перепутать с условным оператором, и, возможно, имеет смысл заменить разные операторы цикла одной единственной конструкцией вида: \u003c–\u003e или «-», которая сильнее отличается от оператора следования.\nНо в настоящий момент циклы реализованы вот так:\n[условие while] -\u003e\u003e { тело цикла while }; { тело цикла do while } \u003c\u003c-- [условие do while]; Реализация цикла foreach на примере суммирования всех элементов словаря (или одномерного тензора):\nsumma := 0; dict := (1,2,3,4,5,); [ dict ] --\u003e\u003e { # Условие цикла, пока есть данные item, dict := ... dict; # Результат оператора раскрытия словаря - первый его элемент перемещается в item summa += item; # Вычисление суммы всех элементов словаря }; Операторы прерывания (возврата) В качестве оператора прерывания/возврата используется два символа минус –. Оператор позволяет прервать выполнение последовательности команд и/или вернуть данные из текущей функции/блока кода и является самым близким аналогом оператора return и throw одновременно. Для того чтобы вернуть данные, их необходимо указать между двумя операторами прерывания, т.е. --100--; # Вернуть указанное значение. Если возвращаемое значение не указано явно, то будет возвращено значение None.\nСледование (блок кода/лямбда функция) Алгоритмическая конструкция, которая отвечает последовательное выполнение нескольких команд/операторов и возвращающая результат выполнения последнего из них. Также, результатом выполнения может быть значение, которое возвращается с помощью оператора прерывания (возврата). Это очень похоже на классическую лямбда функцию, только она выполняется сразу во время определения, а в переменную сохраняется уже результат её выполнения.\nСледование без перехвата прерывания оформляется в виде последовательности обычных и фигурных скобок, т.е. (){ run code }; или тоже самое, но сохраняет результата выполнения в переменной: $result := (){ run(); code() };. Но если внутри такой функции будет выполнен оператор прерывания, то она никогда вернет управления и не сохранит возвращаемое значение в переменой $result!\nЧтобы перехватывать прерывания, в том числе и возвращаемые значения, необходимо использовать конструкция следования с перехватом прерываний, которая оформляется в виде последовательности обычных и двойных фигурных скобок, т.е. $error := (){{ run(); error();code() }};. Такая конструкция перехватывает все возвраты и прерывания, если они возникают во время выполнения последовательности команд. В этом случае любой результат будет сохранен в переменной $error как при нормальном завершении, так и в случае возникновения ошибки.\nДля более тонкой настройки перехвата прерываний следует использовать типизированную конструкцию, когда в явном виде указывается, какие типы прерываний следует перехватывать. $runtime := (){{ run(); error(); code() }}:ErrorRuntime;. Такая конструкция вернет результат только в случае успешного завершения (когда с помощью оператора прерывания возвращается не типизированное значение, например, --\"Строка\"--;), или при создании прерывания с указанием конкретного типа –:ErrorRuntime(“Описание ошибки”)–;. А вот при возникновении любого другого типизированного прерывания, значение перехвачено не будет и все отработает как самый первый вариант, т.е. без перехвата прерывания и без сохранения возвращаемого значения в переменную.\nСтратегия обработки ошибок Обработка ошибок состоит из комбинации двух элементов: оператора прерывания выполнения с указанием типа возвращаемого значения и алгоритмической конструкции следование с возможностью перехвата прерывания заданного типа.\nЭто немного отличается от классического варианта обработки исключений, который в обычных языках программирования обычно оформляется ключевыми словами try… catch… finally с различными вариациями. Ведь основная цель подобных синтаксических конструкций — выделить участок кода, где возможно возникновение ошибки, перехватить и обработать правильный тип данных (исключений), т.к. NewLang не делает различий между операторами возврата и генерации исключения.\nПодход к обработке исключений следующий: Программный код, который может привести к ошибке, заключается в двойные фигурные скобки, а результат выполнения такого блока кода присваивается переменной. После этого анализируется возвращенное значение, например, оператором сравнения по образцу:\n$result := (){{ # начало аналога блока try $value := call_or_exception1(); [условие1] -\u003e { -- :Error -- }; [условие2] -\u003e { -- $value -- }; $value := call_or_exception2(); }}; # конец аналога блока try [$result] ~\u003e { # Для сравнения по образцу использовать оператор проверки типа (имени класса) [:ErrorParser] -\u003e {Код обработки ошибок парсера}; [:ErrorRunTime] -\u003e {Код обработки ошибок времени выполнения}; [:Error] -\u003e { Код обработки остальных ошибок }; [_] -\u003e { Обработка нормальных данных $value без ошибок }; }; Сборка REPL из исходников (пока только под Linux) Подготовка репозитория Скачать исходники Скачать и развернуть архив libtorch в каталоге contrib (PyTorch Build: Stable (1.10.*) -\u003e Your OS: Linux -\u003e Package: LibTorch -\u003e Language: C++ / Java -\u003e Compute Platform: CPU -\u003e Download here (cxx11 ABI): libtorch-cxx11-abi-shared-with-deps-1.10.2+cpu.zip) Активировать и скачать исходники субмодулей (git submodule init \u0026\u0026 git submodule update) В каталоге contrib запустить файл build.sh для сборки библиотеки libffi В каталоге core запустить файл compile_syntax.sh для генерации файлов парсера и лексического анализатора. Также может потребоваться установка утилит flex и bison. Если что, у меня установлены flex 2.6.4 и bison (GNU Bison) 3.7.4 Собрать Юнит-тесты (newlang_test): в каталоге core выполнить команду make CONF=UnitTest* Интерпретатор (nlc): в каталоге core выполнить команду make CONF=Debug* *) - Сборка проекта выполняется обычной утилитой make, но сборочные файлы генерируются автоматически в давно устаревшей версии NetBeans 8.2, т.к. это единственная универсальная среда разработки с поддержкой Makefile “из коробки”, тогда как в текущей версии Apache NetBeans полноценная поддержка разработки на С/С++ вообще отсутствует. Начал постепенный переход на использование редактора VSCodium (аналога VSCode, в котором вычищена телеметрия от Microsoft) и генерацию скриптов сборки с помощью сmake, но этот процесс пока не завершен.\nПланы на будущее Текущая версия языка значительно обогатилась возможностями, но все еще является тестовой платформой для проверки декларируемых концепций и основного синтаксиса. Если говорить о планах, то в настоящий момент роадмап развития NewLang следующий:\nРеализовать макросы для более привычного использования языка (за счет использования DSL); Добавить в арифметические типы длинные числа и дроби; Сделать какую-нибудь логическую игру (крестики нолики, судоку или что-то похожее) с алгоритмическим выбором следующего хода и его вычислением с помощью машинного обучения; Написать еще больше разных примеров для оценки синтаксиса; Зафиксировать синтаксис с учетом полученного опыта и обратной связи; Восстановить работоспособность компилятора для генерации исполняемых файлов; Сделать очередную большую чистку кода; Переработать и задокументировать получившуюся семантику языка с учетом всех возможностей и выпустить первую полнофункциональную версию NewLang. ","categories":"","description":"","excerpt":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag …","ref":"/ru/blog/release-v0.1/","tags":"","title":"Релиз языка программрования NewLang"},{"body":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag предыдущей версии.\nАктуальную версию синтаксиса языка можно посмотреть тут.\nБолее года назад я начал публикацию статей с описанием особенностей нового языка программирования. С тех пор утекло много воды, было протестировано множество идей, в итоге несколько раз все поменялось кардинальным образом и сейчас представляю на суд читателей описание предфинальной версии языка и его особенностей.\nДанная статья предназначена в первую очередь для проверки основных концепций нового языка программирования, а также для получения обратной связи от читателей Хабра. Ведь согласно наблюдению Хабр-ума палата, не замыленный взгляд со стороны очень сильно помогает в проработке новых идей.\nЭтот проект очень долго был без собственного названия и в публикациях назывался просто и абстрактно “новый язык”. Но после нескольких статей, временное название “новый язык” постепенно превратилось в имя собственное NewLang, которое я и решил в конечном итоге оставить (что еще раз подтверждает поговорку, что нет ничего более постоянного, чем что-то временное).\nNewLang - это язык программирования высокого уровня в котором можно сочетать стандартные алгоритмические конструкции с декларативным программированием и тензорными вычислениями для задач машинного обучения.\nОсновной особенностью языка является легкий, логичный и непротиворечивый синтаксис, который основан не на использовании зарезервированных ключевых слов, а на строгой системе грамматических правил с использованием знаков препинания (в список которых входят и операторы языка). Основные свойства и особенности языка:\nВозможность работы как в режиме интерпретатора, так и компилятора. Динамическая и статическая типизация с возможностью указания типов в явном виде. Статическая типизация является условно строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных, например, целое число может быть автоматически преобразовано в вещественное, но не наоборот) Автоматическое управление памятью. ООП в виде явного наследования классов и утиная типизация. На уровне синтаксиса поддержка нескольких типов функций (обычные и чистые функции без побочных эффектов). Необязательные и именованные параметры функций. Возможны вставки кода на языке реализации (С/С++). Простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных и функций из С/С++). Имеется REPL read-eval-print loop — «цикл: чтение — вычисление — вывод». Зачем нужен NewLang? У всех современных языков программирования происходит постоянное развитие (читай усложнение) синтаксиса по мере выхода новых версий. Это является своего рода, платой за появление новых возможностей и воспринимается пользователями как естественное явление.\nНо одновременно является и серьезной проблемой, т.к. с выходом новых версий добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для новых пользователей. Еще одним следствием этого процесса становится постоянное повышение сложности разработки и трудоемкости поддержки уже созданных программных продуктов, когда старый код дорабатывается с применением уже новых стандартов.\nУ NewLang сложность языковых конструкций естественно ограничена за счет разделения синтаксиса языка на две части, что упрощает его изучение и использование. Основной синтаксис — для написания программ в объектно-ориентированном (императивном) и декларативном стилях, который основан не на зарезервированных ключевых словах, а на строгих грамматических правилах и Расширенный синтаксис — когда основного синтаксиса становится недостаточно, или требуется использовать языковую конструкцию языка реализации.\nЕще одно неудобство современных мейнстримовых языков, большинство из них были созданы до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек, а не встроены в основной синтаксис языка и систему базовых типов. У NewLang тензорные вычисления доступны «из коробки» (используется библиотека libtorch), а арифметические типы данных являются скалярами (тензорами нулевой размерности).\nОсновной синтаксис Основной синтаксис NewLang - простой и логичный за счет того, что он построен исключительно на грамматических правилах и не использует каких либо зарезервированных ключевых слов, а все буквенно-символьные последовательности рассматриваются как идентификаторы в которых можно использовать любые не-ASCII символы.\nИдеализированная цель отказа от ключевых слов, приблизить чтение исходного текста программы к чтению обычного текста за счет использования знаков препинания при описании логики работы алгоритма.\nКонечно запятая человек может вычленять ключевые управляющие слова языка и слеш или учитывать форматирование программы запятая чтобы на их основе понимать синтаксические конструкции запятая хотя при обычном чтении мы привыкли опираться именно на семантику знаков препинания точка мы конечно можем писать знаки препинания и обычным текстом точка но согласитесь запятая что тогда открытая скобка например запятая вот такой вот текст закрытая скобка будет очень не удобно читать точка\nНазвания встроенных типов или имена служебных функций системной библиотеки определяются конкретной реализацией языка, поэтому не являются зарезервированными ключевыми словами и при необходимости могут быть переопределены, например, для создания собственного, предметно-ориентированного диалекта (DSL - domain-specific language), если в этом возникнет необходимость. Но сама структура программы и логика выполняемого алгоритма все равно останутся понятны всем, кто знаком с правилами основного синтаксиса NewLang.\nПример скрипта Hello world! на NewLang\n#!./nlc --eval # Определение функции hello hello(str) := { printf := @import('printf(format:Format, ...):Int'); # Импорт стандартной C функции printf('%s\\n', $str); # Вызов C функции с проверкой типов аргументов по строке формата }; hello('Привет, мир!'); # Вызвать функцию Вывод: Привет, мир!\nРасширенный синтаксис Расширенный синтаксис — это возможность вставить в текст программы NewLang исходный код на языке реализации. Сейчас это С/С++, что позволяет использовать любые возможности этого мощного языка программирования.\nОбработка расширенного синтаксиса происходит на этапе компиляции приложения, а взаимодействие между основным и расширенным синтаксисами происходит за счет совместного использования идентификаторов, которое полностью прозрачно для пользователя и подчиняется единым грамматическим правилам основного синтаксиса.\nЕще немного примеров: Любая последовательность вычислений возвращает результат выполнения последнего оператора. Поэтому выполнение одной команды или последовательности команд всегда возвращает какой-либо результат, а оператор возврата из функции необязателен, так как результатом будет значение последнего вычисленного выражения.\nСоздание переменных\nscalar := 42 42 tensor := [1,2,3,4,5,] # Тип тензора выводится автоматически [1, 2, 3, 4, 5,]:Char str := '$1 string' $1 string Арифметические операции\ntensor * 2 [2, 4, 6, 8, 10,]:Short tensor * 20 [20, 40, 60, 80, 100,]:Short tensor * 0.5 [0.5, 1, 1.5, 2, 2.5,]:Double tensor / 2 # Результат деления — число с плавающей точкой [0.5, 1, 1.5, 2, 2.5,]:Double tensor // 2 # Целочисленное деление без остатка [0, 1, 1, 2, 2,]:Char\u003c/source\u003e tensor % 2 # Целочисленный остаток от деления [1, 0, 1, 0, 1,]:Char\u003c/source\u003e Строковые операции\nstr = 'сцепеление строк ' ++ str; сцепеление строк $1 string str('строка как шаблон'); сцепеление строк строка как шаблон string Преобразование тензоров В эпоху машинного обучения тензоры являются основными элементами вычислений, поэтому для конвертирования данных в тензоры используется отдельная синтаксическая конструкция, состоящая из двойных квадратных скобок [[ данные ]]. Подробнее про особенности преобразования типов можно прочитать далее.\ntstr := [[\"Тест\"]] # Создать тензор из строки широких символов [1058, 1077, 1089, 1090,]:Int t2 := [[ \"Тест\" ]]:Int[2,2] # Тоже самое, но тензор двухмерный [ [1058, 1077,], [1089, 1090,], ]:Int\u003c/source\u003e StrWide(tstr) # Конвертировать тензор обратно в строку Тест Double(t2) # Изменить тип данных тезора [ [1058, 1077,], [1089, 1090,], ]:Double t3 := [[ t2 ]]:Char[4] # Преобразовать тип данных тензора и его размерность [34, 53, 65, 66,]:Char Синтаксис NewLang: При разработке синтаксиса я старался придерживаться уже сложившихся правил, чтобы не создавать множественных смыслов, зависящих от контекста. И одновременно «объять необъятное»\nОсновы Операторы разделяются точкой с запятой «;». Отступы и переводы строк игнорируются (очень хотелось иметь возможность автоматического форматирование кода). Многострочные комментарии в исходном коде соответствуют стилю С/С++ и должны располагаться между символами /* и */. Вложенность многострочных комментариев не поддерживается. Однострочные комментарии начинаются с символа «#» до перевода строки, что соответствует комментариям в стиле Python и Bash. Последовательность выполняемых команд, которая должна выполняться как единое целое, заключается в фигурные скобки «{}». Программные вставки расширенного синтаксиса на языке реализации заключается в фигурные скобки со знаком процента %{ /* тут может быть любой код на C/C++*/ %}. Создания объектов и присвоения новых значений Для создания объектов и присвоения им новых значений в NewLang используется сразу три разных оператора.\nОператор «::=» используется только для создания новых объектов, а если объект с таким именем уже существует, то генерируется ошибка.\nОператор «:=» используется для тех же целей, но если объект с таким именем уже существует, то ошибки не происходит, а новое значение присваивается уже существующему объекту.\nИ последний оператор «=» применяется только для присвоения значения уже существующим объектам, и если объект с указанным именем отсутствует, то тоже происходит ошибка.\nИспользование трех разных операторов для создания/изменения объектов позволяет более гибко контролировать подобные операции и выявлять логические ошибки в коде на более раннем этапе.\nvar ::= 1.0; # Создать новую переменную var без указания типа var = 100; # Присвоить новое значение уже существующей переменной printf := @import('printf(format:Format, ...):Int'); /* Создать новый или переопределить объект printf, который будет результатом выполнения глобальной функции @import */ Идентификаторы объектов и модификаторы В качестве идентификаторов можно использовать буквы, цифры и знаки подчеркивания в любых комбинациях, при условии, что первый символ идентификатора не является цифрой.\nВ NewLang существует возможность указания области видимости и времени жизни объекта с помощью модификатора — специального символа перед именем переменной. Это может показаться немного похожим на венгерскую нотацию, но в отличие от нее, модификатор не имеет отношения к типу объекта и не является частью имени идентификатора. К тому же в качестве модификаторов используется строго определённые символы, назначение которых определено заранее.\nТак, символ «$» в начале имени обозначает локальную переменную, время жизни которой ограничено текущей областью видимости и при её завершении локальная переменная уничтожается. Символ «@» обозначает глобальную переменную, а сам объект сохраняет свое состояние даже после выхода из текущей области видимости. Так же обозначаются и имена типов данных, например, при создания новых типов, а в качестве модификатора используется символа двоеточия «:»\nСемантика обращения к аргументам функций очень похоже на работу с аргументами в bash скриптах, где $1 или $arg — порядковый номер или имя аргумента (происходит обращение к локальным переменным в текущей области видимости).\nИспользование модификаторов является обязательным только в двух случаях: - При создании нового типа данных, так как типы всегда создаются в глобальной области видимости, а их символьные имена должны быть уникальными - При обращении к объектам NewLang внутри программных вставок кода на языке реализации, так как они используется как маркеры при поиске идентификаторов NewLang в коде С/С++.\nВ остальных случаях, для обращения к переменным указывать их модификаторы не обязательно. И если при обращении к объекту модификатор не указан, то сперва ищется локальная переменная, а потом глобальная с таким же именем. Причем, локальная переменная будет перекрывать глобальную.\nТак же следует иметь в виду, что компилятор может генерировать код для прямого обращения к локальным объектам уже на этапе компиляции, тогда как для обращения к глобальным объектам, или если модификатор области видимости отсутствует, компилятор вынужден каждый раз встраивать runtime вызов функции поиска объекта в таблице символов.\nСистема типов Так как система типов языка динамическая, то явное указание типа не влияет на размер переменной и является только своего рода логическим ограничением на возможность присвоения переменной значения другого типа.\nИнформация о типах используется при проверке их совместимости, когда существующему объекту присваивается значение другого типа. Такая операция возможна только когда типы совместимы между собой и допускают автоматическое приведение. Это справедливо как во время парсинга/компиляции исходного теста, так и во время выполнения в режимах интерпретатора и/или скомпилированного файла.\nАрифметические типы: Арифметические типы данных являются тензорами - массивами чисел одного типа с произвольным количеством измерений и одинаковым размером столбцов в каждом. Единичное число тоже тензор нулевого размера.\nПоддерживаются только знаковые целые числа, т.к. в беззнаковых числах особая нужда отсутствует, а проблем с ними можно найти очень много на ровном месте.\nПроблемы беззнаковых чисел (из интернета)\nВо-первых, вычитание двух беззнаковых чисел, например 3 и 5. 3 минус 5 равно 4294967294, т.к. -2 не может быть представлено как беззнаковое число. Во-вторых, непредвиденное поведение может возникнуть при смешивании целочисленных значений со знаком и без знака. С++ может свободно преобразовывать числа со знаком и без знака, но не проверяет диапазон, чтобы убедиться, что вы не переполняете свой тип данных.\nВ C++ всё же есть несколько случаев, когда можно (или необходимо) использовать беззнаковые числа. Во-первых, числа без знака предпочтительнее при работе с битами. Во-вторых, использование беззнаковых чисел связаных с индексацией массивов.\nНо это мой случай, так как индекс может быть отрицательным и даже не числом, а диапазоном или многоточием. З.Ы. И даже зная об этом, все равно умудрился недавно словить баг с отрицательными индексами у словарей!\nИмена встроенных арифметических типов говорят сами за себя: Char, Short, Int, Long, Float, Double, ComplexFloat, ComplexDouble. Отдельным типом идет логический тип Bool, который может принимать значения только 0 или 1 (false/true соответственно), и в зависимости от выполняемой операции может быть отнесен к целочисленным типам, так и не входить в их состав.\n(данный подход интерпретации логического типа данных был взят из библиотеки Torch)\n// Treat bool as a distinct \"category,\" to be consistent with type promotion // rules (e.g. `bool_tensor + 5 -\u003e int64_tensor`). If `5` was in the same // category as `bool_tensor`, we would not promote. Differing categories // implies `bool_tensor += 5` is disallowed. // // NB: numpy distinguishes \"unsigned\" as a category to get the desired // `bool_tensor + 5 -\u003e int64_tensor` behavior. We don't, because: // * We don't want the performance hit of checking the runtime sign of Scalars. // * `uint8_tensor + 5 -\u003e int64_tensor` would be undesirable. В будущем планируется добавить классы чисел для длинной арифметики и дробей, для чего зарезервированы названия типов BigNum, Currency и Fraction.\nДоступ к элементам тензора происходит по целочисленному индексу, который начинается с 0. Для многомерного тензора, индексы элемента перечисляются в квадратных скобках через запятую. Поддерживается доступ к элементам через отрицательный индекс, который обрабатывается точно так же, как в Python (-1 последний элемент, -2 предпоследний и т.д.).\nЛитерал тензор в тексте программы записывается в квадратных скобках с обязательной завершающей запятой, т.е. [1, 2,] - это литерал одномерный тензор из двух чисел. После закрывающей скобки тип тензора может быть указан в явном виде. Если тип не указан, то он выводится автоматически на основании указанных данных и выбирается минимально возможный байтовый размер, который позволяет сохранить все значения без потери точности.\nПримеры:\n$var_char := 123; # Тип Char выводится автоматически $var_short := 1000; # Тип Short выводится автоматически $var_bool := [0, 1, 0, 1,]; # Тензор из 4 элементов. Тип Bool выводится автоматически $tensor[10,10]:Int := 1; # Тензор Int размером 2x2 инициализированный 1 $scalar := $tensor[5,5]; # Присвоить скаляру значение указанного элемента тензора Строковые типы данных: Поддерживаются два типа строк, StrWide - символьные (широкие) и StrChar — байтовые. Различия между ними заключается в типе единичного элемента. У символьных строк единичным элементом является широкий символ wchar_t, а у байтовой строки единичным элементом является один байт (точнее char, т. е. байт со знаком). Символьные строки литералы в исходном тексте записывается в «двойных кавычках», а байтовые строки в ‘одинарных кавычках’.\nКоличество элементов символьной строки возвращается в широких символах, а размер байтовой строки в байтах, поэтому и обращение к элементу строки по индексу происходит соответственно либо к символу, либо к байту.\nВажный момент. К любой переменной можно обратиться так же, как к функции (записав после её имени круглые скобки). Результатом этой операции будет создание копии/клона объекта. Причем некоторые типы (словари, классы и символьные строки) можно использовать в качестве шаблона при создании копии объекта с модифицированными свойствами, если новые и/или изменяемые значения указать в скобках, как аргументы при вызовах функций. Так, если при создании копии в скобках указать набор новых данных, то результирующая копия будет содержать уже измененные данные.\nНапример:\n$template := \"${name} $1\"; # Обычная строка $result := $template(\"шаблон\", name = \"Строка\"); # result = \"Строка шаблон\" Составные типы данных: Словарь Словарь — набор данных произвольного типа с доступом к отдельным элементам по целочисленному индексу или по имени элемента при его наличии (он похож и на tuple и на структуру одновременно). Словари от тензоров отличаются тем, что являются только одномерными массивами, но каждый элемент может содержать произвольное количество элементов любого типа, в том числе и другие словари.\nДоступ к элементам словарей происходит по имени элемента, которое записывается через точку от имени переменной, либо по целочисленному индексу. Индекс также начинается с 0 и как у тензоров, тоже может быть отрицательным.\nЛитерал с типом «словарь» в тексте программы записывается в круглых скобках с обязательной завершающей запятой, т.е. (,) - пустой словарь, (1, 2= «2», name=3,).\nПеречисление Перечисление - это не отдельный тип данных, а обычный словарь, у которого все элементы имеют уникальные имена и целочисленные значение, которое явно указывается при определении или вычисляется автоматически (на единицу больше предыдущего элемента). У перечислений тип значения указывается сразу после закрывающей скобки через двоеточие (ONE=1, TWO=, THREE=): Int.\nКлассы Класс (реализовано частично) - тип данных, с помощью которого реализуется один из принципов ООП - наследование. При создании экземпляра класса создается новая переменная, у которой сохраняется информацию о своем родителе и которая наследует от него свойства и методы. Тип данных «класс» аналогичен словарю, но все свойства обязаны иметь имена (хотя доступ к свойствам класса по индексу так же возможен). Литерал с типом «Класс» в тексте программы записывается в круглых скобках без завершающей запятой, т. е. () - пустой класс, (1, 2= «2», name=3).\nПока остальные детали классов до конца не реализованы, поэтому описывать их не буду, т. к. в итоговом варианте синтаксис классов и определения их методов могут поменяться.\nФункции Синтаксис NewLang поддерживать несколько типов функций (а в будущем и методов классов): обычные функции, чистые функции и простые чистые функции.\nДля всех типов функций поддерживаются аргументы по умолчанию. При создании функции, её аргументы указываются как в Питоне, т.е. вначале идут обязательные аргументы, потом аргументы со значениями по умолчанию, где имя аргумента отделяется от его значения по умолчанию знаком равно «=». Если функция допускает обработку произвольного количества аргументов, то последним в списке параметров указывается многоточие.\nОбычная функция Обычная функция — такие функции являются именно обычными функциями в понимании С/С++. Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д.\nВнутри обычной функции можно обращаться к локальным и глобальным объектам, и они могут содержаться вставки на языке реализации, например, для вызова функций из внешних библиотек.\nВставки на языке реализации оформляются в виде %{ %} и могут содержать любой текст на С/С++, а прямо из него можно обращаться к локальным и глобальным объектам NewLang так же, как и в обычном синтаксисе, указывая первым символом имени соответствующий модификатор ($ для локальных объектов и @ для глобальных).\nТехнически, такая программная вставка просто переносится трансплайтером непосредственно в исходный текст генерируемого файла, а все идентификаторы NewLang специальным образом декорируются (добавляются специальные маркеры для их идентификации), после этого исходный текст подается на вход обычному компилятору С++. Для локальных объектов трансплайтер может генерировать код для прямого доступа к объекту на этапе компиляции, а для работы с глобальными объектами вынужден использовать runtime вызовы функции поиска в таблице символов.\nНапример:\nprint(str) := { %{ printf(\"%s\", static_cast\u003cconst char *\u003e($str)); /* Прямой вызов С функции */ %} }; Чистые функции Чистая функция - это тоже обычная функция, только в том смысле, какой в него вкладывает функциональное программирование. Создания чистой функции происходит с помощью оператора «:-». У чистой функции отсутствует доступ к контексту и глобальным объектам, поэтому она может обрабатывать только те данные, которые были ей переданы в качестве аргументов.\nПрограммные вставки на языке реализации внутри чистых функций не запрещены и могут использоваться, например, для отладки. Но делается это на страх и риск разработчика. Именно он отвечает за их «чистоту», например при вызове функций из внешних библиотек.\nSum(arg1, arg2) :- {$arg1+$arg2;}; # Вернуть сумму аргументов Так как в языке отсутствует оператор возврата данных из текущего блока выполнения (аналог оператора return \u003cданные\u003e), то возвращаемым значением функции / блока кода всегда является результат выполнения последней операции.\nПростые чистые функции Простые чистые функции — отдельный класс чистых функций, которые предназначены только для вычисления логического результата (т.е. они являются предикатами) и их отличает упрощенная формой записи. Тело простой чистой функции состоит из последовательности операторов, которые разделяются запятыми и заканчиваются, как и любое выражение, точкой с запятой. Все операторы простой чистой функции всегда приводятся к булевому значению, а итоговый результат функции вычисляется по одной из возможных логических операций: И, ИЛИ и исключающее ИЛИ.\nНапример:\nfunc_and(arg1, arg2) \u0026\u0026= arg1==3, arg2 \u003e 0; # Простая чистая функция Логическое И func_or(arg1, arg2) ||= arg1==3, arg2 \u003e 0; # Простая чистая функция Логическое ИЛИ func_xor(arg1, arg2) ^^= arg1==3, arg2 \u003e 0; # Простая чистая функция Исключающее ИЛИ Специальные типы данных: None None (пустой тип) — не содержит значения (точнее имеет одно значение None) и совместим с любым другим типом данных. Указывается в тексте программы как один подчерк «_». Значение None имеют не инициализированные переменные и при попытке чтения из такой переменной возникает ошибка.\nТип переменной может быть явно указан или выведен автоматически из присваиваемого значения. Присвоить новое значение уже инициализированной переменной можно только для совместимого типа, так как неявное преобразование типов не допускаются.\n$var := _; # Создать переменную со значением None $var2 := var; # Ошибка!!! Нельзя прочитать неинициализированную переменную var $var = 1000; # У переменной будет тип Short (минимальный размер для хранения значения) $var = 0,5; # Ошибка!!! Short ← Float не совместимы $var = _; # Очистить значение переменной $var = 0,5; # Теперь можно, т. к. None совместим с любым типом Диапазон (Range) Диапазон (реализовано частично) — специальный тип данных, являющейся приблизительным аналогом типа «генератор» в Python. К диапазону можно обращаться как к итератору и он будет поочередно выдавать элементы в указанном интервале с заданным шагом. Диапазон в тексте программы указывается как два или три элемента через две точки, например 1..5 — диапазон от единицы до пяти с шагом по умолчанию 1. В качестве параметров диапазона можно указывать не только литералы, но и имена переменных. Например, 0,1..$stop..0,1 — диапазон от значения 0,1 до значения, указанного в переменной $stop с шагом 0,1.\nДиапазон для целых чисел можно использовать в качестве индекса у тензоров (точнее, у любых объектов, которые допускают доступ к своим элементам по индексу, т.е. тензоры, словари и текстовые строки). Фактический, это поведение аналогично slice в языке Python и array[1:5] в Python означает тоже самое, что и array[1..5] в NewLang.\nВ качестве индекса у тензоров еще можно указать произвольное количество измерений с помощью многоточия, т.е.\n$tensor[…, 0] = 0; # Обнулить все первые элементы в каждом измерении. Итераторы Итераторы (в разработке) - самый сложный и неоднозначный тип данных для работы с элементами коллекций.\nДля работы с итераторами зарезервированы символы “!” и “?”, но сами итераторы пока не реализованы.\nПреобразование типов Явное приведение типов Несмотря на динамическую типизацию языка, если тип переменной указан явно, то автоматическое приведение типов не выполняется, и чтобы присвоить переменой значение не совместимого типа, требуется явное преобразование.\nТак как символьные названия типов относятся к деталям реализации, то явное преобразование в конкретный тип данных производится с помощью вызова функции с системным именем, т. е. Bool(), StrWide(), Long и т. д. Причем у тензоров при таком преобразовании изменяется только тип данных, но размерность тензора не меняется.\nДля преобразования любого типа данных в строку ещё можно использовать оператор конкатенации строк, которой преобразует любой тип данных в строковое представление. Но так как строковых типов два (байтовые и широкие строки), то тип строки определяется первым аргументом в операторе конкатенации, т. е.\n\"\" ++ 123 # \"123\" - Строка широких символов '' ++ 123 # '123' - Байтовая строка Или преобразовать любое значение в строковое с помощью строки-шаблона: val := 12345; \"$1\"(val) # Будет строка \"12345\" Tensor comprehensions В эпоху машинного обучения тензоры являются основным элементом вычислений, поэтому для конвертирования данных в тензоры используется отдельная синтаксическая конструкция, состоящая из двойных квадратных скобок [[ данные ]]. Фактически это оператор и функция времени выполнения в зависимости от указанных между двойные квадратными скобками выражения.\nЧтобы преобразовать любую переменную в тензор (с учетом допустимости такого преобразования), её достаточно указать между двойными квадратными скобками. Выражение [[ varibale ]] - преобразует переменную varibale в одномерный тензор с автоматическим выводом типа данных. Для преобразования в одномерный тензор конкретного типа используется выражение [[ varibale ]]:Type, где _Type- - любой из арифметических типов.\nЕсли требуется преобразовать переменную не в одномерный тензор, а в тензор конкретного типа и заданной размерности, то это делается выражением [[ varibale ]]:Type[2,2], которая вернет тензор с размерностью 2х2 и типом Type у элементов.\nВнутри двойных квадратных скобок может быть не только любое выражение, но и литерал или диапазон. В этом случае, они также раскрываются в тензор по таким же правилам.\nВ будущем планирую добавить возможность указания сразу нескольких значений через запятую для их объединения в один тензор.\nПримеры:\n\u003e[[(1,2,3)]] # Тензор из словаря [1, 2, 3,]:Char \u003e[['first second']] # Байтовая строка в тензор [102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Char \u003e [[(first='first', space=32, second='second')]] # Получаем тензор из словаря с такими же данными [102, 105, 114, 115, 116, 32, 115, 101, 99, 111, 110, 100,]:Char \u003e[[ 0 ... ]]:Double[10,2] # Тензор заданного формата с нулями [ [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], [0, 0,], ]:Double \u003e[[ rand() ... ]]: Int[3,2] # Тензор со случайными данными [ [1804289383, 846930886,], [1681692777, 1714636915,], [1957747793, 424238335,], ]:Int \u003e[[ 0..10 ]]: Int[5,2] # Тензор из диапзона [ [0, 1,], [2, 3,], [4, 5,], [6, 7,], [8, 9,], ]:Int \u003e[[ 0..0.99..0.1 ]] # Или даже так [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9,]:Double\u003c/source\u003e Операторы и управляющие конструкции Операторы: Все операторы имеют парный оператор с присвоением значения.\n+ и += сложение арифметических типов данных и -= вычитание арифметических типов данных / и /= деление (результат число с плавающей точкой) // и //= целочисленное деление с округлением к меньшему числу (как в Python) и *= умножение ** и **= возведение в степень (он же используется и для повторения текстовых строк) ++ и ++= конкатенация строк с автоматическим приведением аргументов к стоковому типу (символ инкремента специально используется вместо одиночного плюса для того, чтобы в явном виде разделить конкатенацию строк и операторы арифметического сложения) Операторы сравнения: \u003c, \u003e, \u003c=, \u003e= классические для сравнения скаляров ==, != операторы сравнения с автоматическим приведением совместимых типов для любых объектов ===, !== оператор точного сравнения для любых объектов (автоматического приведения типов не выполняется)s Проверки типов (в разработке): Проверка имени класса «~» - немного похож на оператор instanceof в Java. Левым оператором должен быть проверяемый объект, а правым оператором - название типа, строка литерал или объект строкового типа с именем класса. Результатом операции будет истина, если правый операнд содержит название класса проверяемого объекта или он присутствует в иерархии наследования у проверяемого класса.\nname := \"class\"; # Строка с именем класса var ~ :class; var ~ \"class\"; var ~ name; (field1=«value», field2=2, field3=«33»,) ~~ (); # Истина (т. е. левый операнд словарь) (field1=«value», field2=2, field3=«33»,) ~~ (field1=_); # Тоже истина (т. к. поле field1 присутствует у левого операнда) Утиная типизация «~~» - приблизительный аналог функции isinstance() в Python, который для простых типов сравнивает совместимость типа левого операнда по отношению к правому, а для словарей и классов в левом операнде проверяется наличие всех имен полей, присутствующих у правого операнда. т. е.\n(field1=«value», field2=2, field3=«33»,) ~~ (); # Истина (т. е. левый операнд словарь) (field1=«value», field2=2, field3=«33»,) ~~ (field1=_); # Тоже истина (т. к. поле field1 присутствует у левого операнда) Строгая утиная типизация «~~~» - для простых типов сравнивается идентичности типов без учета совместимости, а для составных типов происходит строгое сравнение всех свойств. Для данной операции, пустой тип совместим только с другим пустим типом!\nУправляющие конструкции (в разработке) Условный оператор В качестве оператора проверки условия используется синтаксическая конструкция, соответствующая по смыслу термину «следует», т.е. тире и угловая скобка «-\u003e». Такая запись условного оператора очень похожа на математическую и легко объединяется в последовательности для проверки множественных условий вида «else if».\nВ общем случае условный оператор имеет вид:\nусловие -\u003e действие; или (условие) -\u003e {действие}; или (условие1 || условие2) -\u003e {действие} -\u003e {действие иначе}; Или расширенный вариант «else if», для наглядности записанный с отступами:\n(условие1) -\u003e {действие1} (условие2) -\u003e {действие2} (условие3) -\u003e {действие3} -\u003e {действие_иначе}; Операторы циклов (в планах) Операторы циклов пока в разработке , т. к. плотно связаны с итераторами.\nПока планирую для циклов использовать конструкции: (условие) \u003c–\u003e {тело цикла};\nИли так: (условие) -» {тело цикла};\nИ хотя синтаксис мне не очень нравится, но я решил пока не ломать над этим голову и планирую попробовать несколько вариантов оформления циклов.\nОператоры прерывания потока выполнения команд (реализовано частично) Оператором прерывания потока выполнения команд и возврата из текущей функции, т.е. самым близким аналогом оператора return\nявляется оператор два символа минус «–». Но в отличие от классического return, оператор возврата не возвращает значения, т.к. значение из любой функции или блока кода возвращается всегда и им является результат выполнения самой последней операции (или None, если такая операция отсутствует).\nПока не придумал, как оформлять оператор прерывания потока выполнения в случае ошибки (при его выполнении будет происходить генерация исключения), поэтому, если будут предложения, пишите в комментариях к статье (и про оформление циклов тоже).\nОбработка ошибок (в планах) В самом начале работ я ориентировался на классический вариант обработки исключений, который в обычных языках программирования обычно оформляется ключевыми словами try .. catch .. finally с различными вариациями. Но в условиях жестких ограничений на синтаксис языка, и невозможности использовать ключевые слова, комбинировать символы для указания разных типов блоков при обработке исключений, было бы крайне сомнительной затеей. Ведь основная цель разработки NewLang — простота и понятность кода, а тут с самого начала могут появиться комбинации скобочек, стрелочек, палочек и других подобных символов.\nИ тут в голову пришла очень простая мысль. А ненужно повторять логику обработки ошибок из классических языков программирования! Ведь основная цель подобных синтаксических конструкций - выделить участок кода где возможно возникновение ошибки, перехватить и обработать правильный тип исключения. Ведь классические языки программирования изначально были жестко привязаны к машинному представлению данных в оперативной памяти компьютера и тип данных для них играл принципиально важное значение. Но это не является ограничением для языков с динамической типизацией!\nПоэтому, подход к обработке исключений планируется следующий: Программный код, который может привести к ошибке, заключается в двойные фигурные скобки {{ любой код или вызов одиночной функции }}, а результат выполнения такого блока кода присваивается переменной. После этого анализируется возвращенное значение и тип исключения может обрабатываться обычным условным оператором.\nНаверно, это проще показать на примере:\n$error := {{ # начало блока try call_or_exception1(); call_or_exception2(); }}; # конец блока try # Обычные условные операторы вместо типизированных блоков catch ($error ~ :type1)-\u003e{ код обработки ошибки 1} ($error ~ :type2)-\u003e{ код обработки ошибки 2}; Самое удивительное, что при таком подходе значительно упрощается и семантика блоков try … finally, которые вообще становятся не нужны.\nИсходный код на Java:\ntry { try { throw new Exception(\"a\"); } finally { throw new IOException(\"b\"); } } catch (IOException ex) { System.err.println(ex.getMessage()); } catch (Exception ex) { System.err.println(ex.getMessage()); } Эквивалентный ему на NewLang:\n$catch := {{ $finally := {{ Error1(\"1\"); }}; Error2(\"2\"); # Строка выполнится даже при возникновении исключении Error1 $finally;\t# Error1 вернется, если не будет Error2 }} ($catch ~ :Error1) -\u003e printf(«%s», $catch) ($catch ~ :Error2) -\u003e printf(«%s», $catch); Как все это попробовать? Сейчас сборка проекта реализована только под Linux и если кроме текстового описания захочется в живую поэкспериментировать на своей машине, то придется собрать интерпретатор из исходников самостоятельно.\nТак как текущий вариант предназначен первую очередь для отработки концепции, то часть из описанных возможностей пока не реализована (алгоритмические конструкции, наследование классов, итераторы, некоторые операции и т. д).\nНо можно поиграться с созданием переменных, вызовом функций и выполнением арифметических операций над данными, чтобы оценить синтаксис, основанный на правилах, и может быть, предложить свои собственные мысли и доработки для его улучшения.\nСборка REPL из исходников (пока только под Linux) Подготовка репозитория Скачать исходники Скачать и развернуть архив libtorch в каталоге contrib (PyTorch Build: Stable (1.10.*) -\u003e Your OS: Linux -\u003e Package: LibTorch -\u003e Language: C++ / Java -\u003e Compute Platform: CPU -\u003e Download here (cxx11 ABI): libtorch-cxx11-abi-shared-with-deps-1.10.2+cpu.zip) Активировать и скачать исходники субмодулей (git submodule init \u0026\u0026 git submodule update) В каталоге contrib запустить файл build.sh для сборки библиотеки libffi В каталоге core запустить файл compile_syntax.sh для генерации файлов парсера и лексического анализатора. Может потребоваться установка утилит flex и bison. Если что, у меня установлены flex 2.6.4 и bison (GNU Bison) 3.7.4 Собрать Юнит-тесты (newlang_test): в каталоге core выполнить команду make CONF=UnitTest Интерпретатор (nlc): в каталоге core выполнить команду make CONF=Debug Утилита nlc (NewLangCompiler) В текущее время nlc поддерживать работу только в режиме интерпретатора (несмотря на название). Для тестирования и простой проверки компилятор не нужен, хотя на первых порах я делал именно его. Но трудоемкость работ по постоянной переделке под новый синтаксис оказалась очень высокой, поэтому на время первичной отладки языковых конструкций было принято волевое решение ограничиться интерпретатором, как более простым и быстрым способом проверки различных гипотез, а разработку настоящего компилятора (в виде трансплайтера на язык С++), отложить до окончательной проработки синтаксиса.\nПланы на будущее Естественное, одна статья и несколько маленьких примеров не дают исчерпывающей информации о возможностях языка. Да и сами возможности пока не раскрыты в полной мере. Ведь текущая версия, это скорее тестовая платформа для проверки декларируемых концепций и основного синтаксиса.\nПока остаются не реализованными некоторые из заявленных возможностей и очень важных хотелок. Но протестировать основной подход можно уже сейчас, и я буду благодарен за любую обратную связь и предложения.\nЕсли говорить о планах (естественно, в будущих версиях что-то может добавиться или измениться порядок их реализации), но в настоящий момент роадмап развития NewLang мне видится следующим образом:\nДоделать стандартные управляющие конструкции, обработку ошибок и итераторы. Доработать систему типов с учетом множественного наследования классов. Реализовать длинную арифметику и дроби. Сделать какую нибудь логическую игру (крестики нолики, судоку или что-то похожее) с алгоритмическим выбором следующего хода и его вычислением с помощью машинного обучения. Написать много разных примеров для оценки синтаксиса. Доработать синтаксис с учетом полученного опыта и обратной связи. Восстановить работоспособность компилятора для генерации исполняемых файлов. Сделать очередную большую чистку кода. Переработать и задокументировать получившуюся семантику языка с учетом всех возможностей и выпустить первую полнофункциональную версию NewLang. Ссылка на первую публикаци\n","categories":"","description":"","excerpt":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag …","ref":"/ru/blog/newlang/","tags":"","title":"Новый язык программирования"},{"body":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag предыдущей версии.\nАктуальную версию синтаксиса языка можно посмотреть тут.\nПри разработке своего собственного языка программирования автор должен определиться, какими свойствами его язык должен обладать, ведь в конечном итоге именно это и будет определять назначение языка и особенности его использования. Причем некоторые свойства настолько сильно влияют на итоговую концепцию языка и его синтаксис, что впоследствии их изменение невозможно в принципе, либо новый синтаксис получается очень запутанным и непонятным. Наверно из-за этого многие свойства языков программирования рассматриваются и изучаются как взаимоисключающие.\nДо недавнего времени я считал, что императивная и декларативная парадигмы написания программ являются антагонистами и взаимоисключающими понятиями. Ведь выбор стиля написания кода, изначально определяется автором языка еще на стадии его проектирования и оказывает влияние на все последующие аспекты.\nНо сейчас я думаю, что это не верно. Императивный и декларативный стили программирования не являются взаимоисключающими, а писать программы только в одной из указанных парадигм подталкивают правила синтаксиса, реализованные в языке!\nДругими словами, использовать только императивную или только декларативную парадигмы разработчик вынужден не потому, что он не умеет или не хочет писать код по другому, а из-за того, что все более-менее мейнстримные языки программирования ориентированы на использование только одной парадигмы. И выбор только одной парадигмы написания кода, это ограничение, которое навязано программистам создателями языка. Ведь если они изначально ориентировались только на одну концепцию разработки кода, то и разрабатывали синтаксис языка в соответствии с этой парадигмой.\nДанная статья — размышление о совместимости декларативной и императивной парадигм программирования и возможности их одновременного использования в рамках одного языка программирования одновременно.\nЧто такое “Декларативное программирование”? Вначале мне захотелось разобраться, а существуют ли чисто декларативные языки программирования? Такие, которые могут полностью обходятся без императивных конструкций?\nНо чуть не споткнулся уже в самом начале, т.к. даже само определение «декларативное программировании», в вики описывается следующим образом:\nДекларати́вное программи́рование — парадигма программирования, в которой задаётся спецификация решения задачи, то есть описывается, что представляет собой проблема и ожидаемый результат. Противоположностью декларативного является императивное программирование, описывающее на том или ином уровне детализации, как решить задачу и представить результат.\nУже в изначальном определении закладывается противопоставление парадигм, а дальше идут рассуждения о «направлении» программирования. И хоть вики сама и не является авторитетным источником информации, но даже такая заготовка статьи смогла показать направление поиска ответов на первый поставленный вопрос.\nИ заставил задуматься один абзац в конце статьи следующего содержания:\n«Чисто декларативные» компьютерные языки зачастую неполны по Тьюрингу — так как теоретически не всегда возможно порождение исполняемого кода по декларативному описанию. Это иногда приводит к спорам о корректности термина «декларативное программирование» (менее спорным является «декларативное описание решения» или, что то же самое, «декларативное описание задачи»).\nСудя по наличию такой оговорки, ставится под сомнение наличие «чисто декларативных» языков. И как только пришлось задуматься над это мыслью, то сразу стало очевидным, что какой бы декларативный язык программирования не существовал, то в нем должна быть как минимум одна императивная конструкция, которая будет запускать поиск решения! Ведь любой синоним слова «выполнить» или «запустить» по определению будет императивом!\nНапример в языке Prolog, который обычно и приводят в качестве примера декларативного языка программирования, “замаскированным” императивным оператором является знак вопроса. Он кажется естественным и логичным, как же без него? Но по своей сути, это императивная конструкция!\nТоже самое касается и языка SQL. Он тоже как бы декларативный, но неожиданно все его команды являются императивными по сути. SELECT, CREATE, ALTER, DROP, INSERT, UPDATE, DELETE и т. д., а декларативными являются только описания условий их выполнения!\nВ результате, у меня так и не получилось найти чисто-декларативный язык программирования без императивных операторов (может быть, Вики права и такого языка программирования и вовсе не существует?).\nА что отличает декларативные языки программирования от императивных? Согласно определению, декларативными языками программирования их называют из-за возможности записать некие условия в декларативном стиле. Но кроме этого, в декларативных языках как правило присутствует и некий внутренний механизм поиска решений. Подобный “вычислитель” есть и в SQL и Prolog и во многих других декларативных языках.\nИнтересно, а является ли внутренняя система поиска решений обязательным признаком декларативного стиля программирования или это только особенность конкретного языка программирования, которая не зависит от декларативного стиля написания кода?\nЧтобы проверить данные предположения, можно было попробовать написать классическую декларативную программу на императивном языке, у которого отсутствует внутренний механизм поиска решений.\nА заодно, таким образом можно будет и изучить вопрос, получится ли написать программу в декларативном стиле используя обычный императивный язык программирования?\nДля примера, решил попробовать повторить уже классическую программу в декларативном стиле на Прологе.\nparent(\"Tom\",\"Jake\"). parent(\"Janna\",\"Jake\"). parent(\"Tom\",\"Tim\"). male(\"Tom\"). male(\"Tim\"). male(\"Jake\"). female(\"Janna\"). brother(X,Y):-parent(Z,X),parent(Z,Y),male(X),male(Y),X\\=Y. ? brother Получилась вот такая функционально - эквивалентная программа на С++, которая максимально приближена по стилю к декларативному прототипу:\nenum sex_ { male, female }; struct human; typedef std::vector\u003chuman *\u003e parent_; struct human { const char *name; sex_ sex; parent_ parent; }; human Tom{\"Tom\", male,{}}; human Janna{\"Janna\", female,{}}; human Jake{\"Jake\", male,{\u0026Tom, \u0026Janna}}; human Tim{\"Tim\", male,{\u0026Tom}}; std::vector\u003chuman *\u003e humans{\u0026Tom, \u0026Janna, \u0026Jake, \u0026Tim}; auto brothers = [](human * a, human * b) { auto intersec = [](parent_ \u0026a, parent_ \u0026 b) { for (auto elem_a : a) { for (auto elem_b : b) { if(elem_a \u0026\u0026 elem_b \u0026\u0026 elem_a == elem_b) { return true; } } } return false; }; return a \u0026\u0026 b \u0026\u0026 a != b \u0026\u0026 a-\u003esex == male \u0026\u0026 b-\u003esex == male \u0026\u0026 (intersec(a-\u003eparent, b-\u003eparent)); }; for (auto a : humans) { for (auto b : humans) { if(brothers(a, b)) { std::cout \u003c\u003c a-\u003ename \u003c\u003c \" and \" \u003c\u003c b-\u003ename \u003c\u003c \"\\n\"; } } } Конечно, текст на С++ получается значительно многословней, чем вариант на Прологе, но по сути, это почти дословное повторение декларативного стиля написания кода. Тем более, не стоит забывать про рассуждения в начале статьи об изначальном выборе концепции при создании языка и “принуждении” программистов пользоваться только одной, изначально выбранной парадигмой разработки.\nТаким образом, можно с высокой долей уверенности утверждать, что теоретически можно писать код одновременно в разных стилях.\nНо что тогда мешает в рамках одного языка программирования писать с использованием императивного и декларативного стиля? Неужели только убежденность создателей языков в том, что императивный и декларативный стили программирования являются взаимоисключающими? И только из-за этого получаются языки программирования, синтаксис которых подходит для использования одной единственной парадигмы?\nНо если это так, то что мешает попробовать разработать синтаксис языка программирования, в котором можно было бы использовать сразу императивный и декларативный стили программирования одновременно?\nЧто мешает совместить императивный и декларативный стили написания в рамках одной программы? В любой компьютерной программе всегда существует разделение кода на описание данных и на языковые конструкции для их обработки, т.е. фактически это разделение на данные и на функции. Мне кажется, что основная сложность, которая не дает использовать разные стили программирования в рамках одного языка, это необходимость разделять описываемые сущности на «данные» и «управляющие конструкции». Ведь это свойство (необходимость разделения сущностей на “данные” и “функции”), является неотъемлемой частью любого языка программирования.\nЭто не удивительно, ведь на заре становления ИТ индустрии, создатели первых языков программирования ориентировались исключительно на императивный стиль, потому что назначением любого компилятора было - преобразовать исходный текст программы в машинные инструкции. И на примерах модульного, структурного и объекто-ориентированного подходах показана и доказана необходимость оформления исполняемого кода в выделенные процедуры с последующей их группировкой в модули и классы.\nА декларативный стиль написания программ стал появляться только после создания высокоуровневых языков программирования. И основная цель создания данных языков сместилась на поиск решения конечного пользователя, а не на упрощение генерации бинарных файлов с машинными инструкциями. Если внимательно посмотреть на приведенные выше примеры кода, то можно заметить, что в них определения данных и операторы для их обработки идут вперемешку, (для примера на С++ это определение лямбд функции), что кардинально отличается от императивного подхода.\nТак может быть, основная особенность декларативного стиля как раз и заключается в том, что в нем не разделяются «данные» и «действия над данными»? Или как вариант, можно не указывать выполняемые действия над данными вовсе (как в некоторых SQL конструкциях)?\nМожет быть как раз именно эта особенность (возможность последовательной записи программного кода в соответствии с собственными логическими рассуждениями, в которых могут перемежаться «данные» и «функции», как это происходит при человеческом мыслительном процессе), не дает в полной мере реализовать возможность совмещения императивных и декларативных стилей программирования?\nИ если это так, тогда можно попробовать разработать такой синтаксис, который будет поддерживать определение как данных, так и декларацию функций в рамках единого потока языковых конструкций!\nПроверка гипотезы в новом языке программирования Для поверки данного предположения, я решил добавить в свой новый язык программирования (синтаксис которого допускает определение функций в одном потоке с описанием обрабатываемых данных), недостающие алгоритмические конструкции, которые позволяли бы реализовать императивный стиль программирования, несмотря на изначальную ориентацию только на декларативную парадигму.\nПравда с учетом изначальных ограничений синтаксиса нового языка (запрет на применение операторов в виде зарезервированных ключевых слов), в качестве оператора проверки условия была выбрана синтаксическая конструкция, соответствующая по смыслу термину «следует», т.е. тире и угловая скобка «-\u003e».\nВ результате, условный оператор получился практически математический, который легко объединяется в последовательности для реализации проверки множественных условий вида «else if». А для объединения сразу нескольких логического операторов между собой и для отделения их от последующего действия, операторы проверки условия можно заключать в круглые скобки.\nВ общем случае условный оператор в новом языке программирования имеет вид:\nусловие -\u003e действие; или (условие) -\u003e {действие}; или (условие1 || условие2) -\u003e {действие} -\u003e {действие иначе}; Или расширенный вариант, для наглядности записанный с отступами:\n(условие1) -\u003e {действие1} (условие2) -\u003e {действие2} (условие3) -\u003e {действие3} -\u003e {действие_иначе}; Тогда и операторы циклов можно будет записать практически аналогично, только выбрав в качестве оператора, не оператор следования, а следование с возвратом (раз уж нужно указывать циклическое действие).\nЦикл пока:\n(условие) \u003c-\u003e {тело цикла}; счетный цикл для работы с итератором:\n(счетчик_или_данные!)? \u003c-\u003e {тело цикла}; В этом случае, решение тестового примера декларативной программы на Прологе можно будет легко оформить, как в императивном, так и в декларативном стилях одновременно!\nм := \"муж.\"; ж := \"жен.\"; human @= term(пол=, parent=[,]); Tom @= human(пол=м); Janna @= human(пол=ж); Jake @= human(м, [\u0026Tom, \u0026Janna,]); Tim @= human(пол=м, parent=[\u0026Tom,]); brother(h1, h2) \u0026\u0026= $h1!=$h2, $h1.пол==м, $h2.пол==м, $h1.parent \u0026 $h2.parent; // Оператор «\u0026» побитовое «И» для чисел или операция пересечения для множеств // Запись алгоритма поиска решения в императивном стиле (h1=human!, h2=human!)? \u003c-\u003e { (brother(h1, h2)) -\u003e { @print($h1, $h2, «\\n»); } }; // Краткая запись алгоритма поиска решения в императивном стиле (h1=human!, h2=human!)? \u003c-\u003e brother($h1, $h2) -\u003e @print($h1, $h2, «\\n»); // Запись поиска решения в декларативном стиле brother(human!, human!)?; Примерно это и требовалось показать!\nЗ.Ы. Я почти закончил эксперименты с синтаксисом языка. И теперь, после добавления в него недостающих алгоритмический конструкций (ветвления и циклов), планирую, что следующая статья о новом языке программирования будет посвящена описанию его полного синтаксиса и публикации исходников прототипа компилятора для возможности поиграться на реальных примерах.\nЗ.З.Ы В комментариях @gbg привел очень простой ответ на один из поднятых вопросов. Причем в более элегантном виде и без написания кода!\nНу и пять копеечек про ООП. Как ни странно:\nВ нем таки есть декларативная часть, все эти pubic, private, virtual, etc Эта декларативная часть, внезапно, элегантно позволяет реализовывать декомпозицию и управление сложностью. При наличии перегрузок, можно поиграть в алгебраическое мышление, рассматривая взаимодействие двух объектов как бинарную операцию. Ух ты, ООП - это обкатанная практикой технология, которая совмещает декларатив с императивом и вроде позволяет освоившим ее вкусно кушать и мягко спать!\nСсылка на первую публикаци\n","categories":"","description":"","excerpt":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag …","ref":"/ru/blog/prog-styles-same-time/","tags":"","title":"Можно ли использовать декларативный и императивный стили написания программ одновременно?"},{"body":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag предыдущей версии.\nАктуальную версию синтаксиса языка можно посмотреть тут.\nХочу представить на обсуждение читателей немного необычный концепт языка программирования, в котором отсутствует проблема, присущая практически всем промышленным языкам - постоянное увеличение сложности синтаксиса языка из-за его естественного развития по мере выхода новых версий и добавления новых фич. Эта проблема описана в статье “Простое сложное программирование” и Какая “идеальная” цель развития у языков программирования?\nПосле нескольких экспериментов с синтаксисом, хочется проверить выработанную идею на широкой аудитории Хабра, которая как нельзя лучше подходит для этих целей.\nОсобенности языка:\nНизкий порог входа и естественное ограничение уровня сложности в течение длительного времени даже при условии постоянного развития самого языка. Возможность писать код программы как в декларативной, так и в императивной парадигме с использованием процедурного, модульного и объектно-ориентированного подхода. Ну и в соответствии с собственным наблюдением Хабр — ума палата, буду рад любым комментариям и предложениям, которые помогут протестировать или улучшить предлагаемое решение.\nВведение Первой необычной особенностью языка является полное отсутствие зарезервированных ключевых слов. Точнее, планируется использовать только одно единственное ключевое слово (название языка), которое может быть как главной точкой входа в приложение, так и способом доступа к настройкам языка под конкретную предметную область, например при необходимости реализации DSL парадигмы.\nВ настоящий момент название языка не выбрано, поэтому для примеров используется просто слово lang, которое в будущем будет изменено.\nДанная особенность (отсутствие зарезервированных ключевых слов) реализуется за счет того, грамматика языка основана на использовании общеупотребительных символов и классических знаков препинания, а все остальные букво-символьные последовательности при парсинге программы рассматриваются как “токены”.\nКомпилятор языка реализуется как transpiler - преобразование исходного кода программы, написанной на одном языке программирования, в эквивалентный исходный код на другом языке. Первые эксперименты с синтаксисом я начинал на Python, но после осознания необходимости разработки не только интерпретатора, но и компилятора непосредственно в исполняемый код, решил остановиться на C++. Хотя в принципе, язык реализации может быть любым.\nИспользование транспиляции при реализации компилятора решает сразу множество очевидных и не очень задач. Сразу отпадает необходимость разрабатывать низкоуровневый компилятор в исполняемый процессорный код, а в моем случае основным бонусом такого подхода становится возможность использования императивной парадигмы программирования за счет вставок кода непосредственно в исходный код приложения на языке реализации.\nИ именно этот момент позволяет естественно разделить декларативный и императивный способ написания программы. В этом случае в декларативной парадигме реализуется только одна из трех базовых управляющих конструкций, необходимых и достаточных при реализации любого алгоритма — следование.\nДругими словами, в декларативном стиле описывается только последовательность операций, которые следуют одна за другой, но отсутствует возможность запрограммировать циклы или ветвление (переходы) по условию. Из-за этого в декларативном стиле можно записать только следующие типы языковых конструкций:\nкомментарий определение переменной и присвоение ей значения создание объекта и назначение его свойствам значений по умолчанию создание функции (метода для всего класса объектов) вызов функции или итератора непосредственная вставка кода на языке реализации Так как цель текущей публикации - протестировать общую концепцию, то начну сразу с примеров без длинного описания подробностей, а некоторые нюансы буду комментировать по ходу дела. Тем более, самая главная цель “низкий порог входа” само собой подразумевает возможность самостоятельно разобраться в синтаксисе. Тем не менее, совсем без знаний языка реализации не обойтись и начальные знания в программировании на С/С++ все равно необходимы.\n“Привет, мир!” в императивной парадигме Определение обычной функции выполняется с помощью оператора присвоения “:=”, а программный код на языке реализации (в данном случае на C++) заключается в фигурные скобки. Простой пример вывода строки на экран выглядит примерно так:\nprint(str=\"\") := { printf(\"%s\", static_cast\u003cchar *\u003e($str)); } Функция print с аргументом по умолчанию в виде пустой строки внутри себя вызывает обычный printf из стандартной библиотеки.\nСоответственно “Привет, мир!” в императивной парадигме программирования будет выглядеть тривиально:\n#!/bin/lang print(str=\"\") := { printf(\"%s\", static_cast\u003cchar *\u003e($str)); }; @print(\"Привет, мир!\\n\"); Из примера видно, что обращение к аргументам внутри С++ кода происходит с использованием символа $, который указывается вначале именованного аргумента. Кроме этого, для доступа к аргументам функции можно обращаться по их порядковым номерам начиная с первого ($1, $2, $3 и т. д.). Зарезервированный аргумент $0 содержит сам объект, метод которого вызывается или nullptr, если функция не принадлежит объекту.\nОбычные функции являются именно обычными функциями в понимании С/С++. Внутри них можно писать совершенно любой код, включая проверки условий, циклы, вызовы других функций и т.д. Технически, код такой функции парсится на предмет замены использованных аргументов, специальным образом декорируется её имя и добавляются специальные маркеры для идентификации содержимого. После этого исходный текст готов для сборки обычным С++ компилятором для превращения в динамическую библиотеку и после её загрузки функцию можно будет вызвать в любой момент (для вызова функции перед её именем необходимо указать символ \"@\").\nНепосредственное выполнение файла в режиме интерпретатора происходит в два этапа. На первом этапе из текста программы генерируется временный С++ файл с исходным кодом всех функций, этот файл компилируется gcc и собирается динамическая библиотека.\nНа втором этапе, собранная динамическая библиотека загружается средой выполнения, а исходный текст программы начинает последовательно выполнятся интерпретатором (все строки, за исключением определений функций).\nЕсть еще вариант, когда вместо интерпретации кода программы, генерируется С++ файл не только для функций, но и для основной части приложения. Тогда на выходе компилятора будет уже обычный бинарный файл, хотя в том случае оперативно поправить текст программы уже не получится.\nЛогическое программирование в декларативной парадигме Так как самым известным языком логического программирования в декларативном стиле считается Prolog, поэтому приведу простой пример программы Brother (поиска братьев) на Прологе и эквивалентный ему код на новом языке.\nProlog:\nmale(\"Tom\"). male(\"Tim\"). male(\"Jake\"). female(\"Janna\"). parent(\"Tom\",\"Jake\"). parent(\"Janna\",\"Jake\"). parent(\"Tom\",\"Tim\"). brother(X,Y):- parent(Z,X),parent(Z,Y),male(X),male(Y),X\\=Y. Вывод: (Jake, Tim) (Tim, Jake)\nТот же самый пример:\n#!/bin/lang human:=@term(sex=,parent=); Tom:=@human(male); Janna:=@human(female); Jake:=@human(male, (Tom, Janna,)); Tim:=@human(sex=male, parent=(Tom,)); human::brother(test=human!) \u0026\u0026= $0!=$test, $0.sex==male, @intersec($0.parent, $test.parent); human.brother? Вывод: [Tim.brother(Jake), Jake.brother(Tim),]\nНадеюсь, что синтаксис интуитивно понятен, особенно при наличии эквивалентного кода на Прологе, но на всякий случай поясню отдельные моменты.\nhuman:=@term(sex=,parent=); В этой строке создается объект с именем “human” и двумя свойствами “sex” и “parent”, значения которых по умолчанию не определены, а родителем является системный объект “term”. Использование символа \"@\" в начале термина обозначает вызов существующей функции с параметрами, указанными в скобках. В данном случае вызывается конструктор системного объекта “term”, а возвращаемым результатом является новый термин “human”, который можно воспринимать как один экземпляр класса, так и как имя целого класса, если он будет выступать в качестве родителя для других объектов.\nTom:=@human(male); Janna:=@human(female); Jake:=@human(male, (Tom, Janna,)); Tim:=@human(parent=(Tom,), sex=male); Первые две строки создают объекты “Tom” и “Janna”, у которых свойство “sex” установлено в значения “male” и “female” соответственно. А в последней строке при создании объекта Tim значения свойств задается с указанием их имени.\nКонструкции (Tom, Janna,) и (Tom,), это определение константного литерала с типом словарь, которые присваиваются указанным свойствам.\nЧтобы определение словаря не путать с указанием аргументов при вызове функции, в нем содержится обязательная финальная запятая перед закрывающей скобкой. Это правило (финальная запятая перед закрывающей скобкой) действует и при определении литерала массива, только для записи которого используются скобки не круглые, а квадратные (например [,] - пустой массив). Основным отличием словаря от массива, заключаются в способах доступа к их элементам. Для доступа к элементу массива используется целочисленный индекс, а в словаре может быть использован как индекс, так и имя элемента при его наличии. Между словарем и массивом есть еще отличия, но сейчас они не принципиальны.\nИ предпоследняя строка в примере:\nhuman::brother(test=human !) \u0026\u0026= $0 != $test, $0.sex==male, @intersec($0.parent, $test.parent);\nэто определение простой чистой функции “brother” для всех объектов, производных от “human”. Данная функция принимает один именованный аргумент “test”, значением по умолчанию которого является итератор объектов класса “human”.\nОператор \u0026\u0026= означает определение простой чистой функции, т. е. функции без внешних зависимостей, которая не имеет доступа к глобальному контексту, а результат выполнения которой является логическое значение, которое вычисляется по схеме логическое И для всех условий, указанных в теле функции через запятую.\nВыполнение и вывод результата выполнения программы происходит в строке human.brother?\nВосклицательный и вопросительный знаки обозначают итератор. Итератор “!” возвращает один текущий элемент из коллекции и передвигает указатель на следующий, а итератор “?” возвращает сразу всю коллекцию объектов целиком.\nДругими словами при выполнении строки программы human.brother ? происходит последовательный перебор всей коллекции объектов типа “human”, где у каждого объекта выполняется функция “brother” с аргументами по умолчанию. А так как в качестве аргумента по умолчанию указан итератор human !, то в качестве аргумента последовательно предается каждый из элементов указанного класса. По сути, при выполнении этой строки происходит полный перебор всех возможных комбинаций объектов класса “human” каждый с каждым.\nБолее подробное описание работы итератора и причина выбора такого синтаксиса опубликовано в отдельной статье Лаконичный итератор для декларативного синтаксиса\nРезультат выполнения будет состоять из тех пар объектов, для которых функция “brother” вернет истину, т.е. результат выполнения будет массив из двух пар объектов [Tim.brother(Jake), Jake.brother(Tim),].\nФормулировка проверяемой концепции Тестируемая концепция заключается в следующем. Синтаксис языка программирования состоит как бы из двух частей, каждая из которых является относительно независимой и в тоже время они связаны между собой.\nПервая часть сложная — предназначена для описания алгоритмов в императивном стиле на обычном языке программирования, поэтому внутри функций разработчику доступны все возможности языка реализации.\nВторая часть простая (по сравнению с первой) — предназначена только для логического описания задачи в декларативном стиле. Именно эта часть используется для начального уровня использования, а естественное ограничение только на последовательное выполнение операторов (т.е. отсутствие циклов и ветвлений) не доставляет чрезмерных сложностей в понимании исходного текста программы даже в будущем по мере развития языка.\nСвязь между двумя вариантами синтаксиса прозрачна и реализуется за счет совместного использования переменных и функций, декларация и обращение к которым происходит в едином стиле в обоих случаях за счет унификации синтаксиса на уровне использования знаков препинания.\nСейчас я специально не привожу полного синтаксиса и подробного описания остальных возможностей языка, т.к. компилятор пока не готов для публичной презентации. Но буду крайне благодарен за любой отклик или дельные предложения в отношении предложенной концепции.\nОсобенно это касается возможных конфликтов по синтаксису в представленных примерах.\n","categories":"","description":"","excerpt":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag …","ref":"/ru/blog/unusual-prog/","tags":"","title":"Необычная концепция синтаксиса языка программирования"},{"body":"\nВ очередной раз увидел на Хабре статью про сложное дело под названием «программирование». И то, что программирование действительно является делом не простым воспринимается как факт и обычно не требует какого либо подтверждения.\nНо понятие «сложность» сродни термину «куча». Для кого-то и пять кокосов это не куча, а кого-то съел один и «больше не хочется» - значит для него и единственного кокоса будет много.\nТак и со сложностью ПО. Вроде бы увеличение сложности является для всех очевидным и наблюдается во всех сферах применения IT технологий, да и сами языки программирования по мере своего развития становятся все сложнее, а вот оценивать «сложность» с помощью численных метрик — дело заведомо неблагодарное, но и «нельзя управлять тем, что невозможно измерить …».\nОбычно разговоры о «сложности» включают в себя только оценочные суждения без какой либо численной оценки. А так как лично меня интересует вопрос сложности языков программирования, то я решил посчитать сложность реализации компилятора gcc в каких нибудь условных попугаях. Вдруг можно будет увидеть какие нибудь закономерности?\nВыбор «попугаев» для измерения Я не стал придумывать свои или вычислять эмпирические метрики программного кода, и в качестве «попугая» решил взять самую простую метрику SLOC (англ. Source Lines of Code) — количество строк исходного текста компилятора, которая очень легко вычисляется.\nПравда, с её помощью можно будет оценивать сложность языка только при следующем допущении — сложность языка должна находиться в прямой зависимости от сложности его реализации, если для простых синтаксических конструкций будет требовать меньше кода, чем для более сложных.\nКонечно, использование метрики «количество строк исходного кода» имеет и свои недостатки, т.к. она сильно зависит от используемого языка программирования, стиля оформления исходного кода и в общем случае не позволяет сравнивать несколько разных проектов между собой.\nНо для численной оценки сложности кода в рамках одного проекта, метрика SLOC подходит хорошо.\nМетодика подсчета SLOC Изначально попробовал использовать простой bash скрипт с поиском по маске и подсчетом числа строк в файлах исходника через wc -l. Но через некоторое время стало понятно, что приходится изобретать очередной велосипед.\nПоэтому решил взять уже готовый. После быстрого поиска остановился на утилите SLOCCount, которая умеет анализировать почти три десятка типов исходников.\nСписок типов файлов для автоматического анализа 1. Ada (.ada, .ads, .adb) 2. Assembly (.s, .S, .asm) 3. awk (.awk) 4. Bourne shell and variants (.sh) 5. C (.c) 6. C++ (.C, .cpp, .cxx, .cc) 7. C shell (.csh) 8. COBOL (.cob, .cbl) as of version 2.10 9. C# (.cs) as of version 2.11 10. Expect (.exp) 11. Fortran (.f) 12. Haskell (.hs) as of version 2.11 13. Java (.java) 14. lex/flex (.l) 15. LISP/Scheme (.el, .scm, .lsp, .jl) 16. Makefile (makefile) — not normally shown. 17. Modula-3 (.m3, .i3) as of version 2.07 18. Objective-C (.m) 19. Pascal (.p, .pas) 20. Perl (.pl, .pm, .perl) 21. PHP (.php, .php[3456], .inc) as of version 2.05 22. Python (.py) 23. Ruby (.rb) as of version 2.09 24. sed (.sed) 25. SQL (.sql) — not normally shown. 26. TCL (.tcl, .tk, .itk) 27. Yacc/Bison (.y) \u003c/code\u003e Причем, считает не просто количество строк исходного текста, но и умеет игнорировать комментарии, исключает из подсчета дубли файлов (сравнивает их хеш суммы), а также выводит расчетную трудоемкость, примерную оценку стоимости разработки анализируемого проекта и другие характеристики.\nМеня изначально интересовал объем исходников на С/С++ и может быть еще на Ассемблере, если таких файлов окажется достаточно много. Но после начала работы очень обрадовался, что не стал изобретать велосипед, а взял готовую тулзу, т.к. она отдельно считала статистику исходных файлов синтаксического анализатора Yacc/Bison (.y), который и определяет фактическую сложность парсера (читай сложность синтаксиса языка программирования).\nСтарые исходники gcc брал с https://gcc.gnu.org/mirrors.html, но перед запуском анализатора удалил каталоги других компиляторов (ada, fortran, java и т.д.), чтобы они не попадали в итоговую статистику.\nРезультаты в попугаях Итоговая статистика\nОбъем кода синтаксического анализатора Yacc/Bison\nОбъем общей которой базы GCC (только для языков C и C++)\nВыводы К сожалению, синтаксический анализатор Yacc/Bison использовался только до 3 версии, а после его использование свелось на нет. Поэтому оценить сложность синтаксиса С/С++ с помощью объема кода парсера можно лишь примерно до 1996-98 года, после чего его стали постепенно выпиливать, т.е. чуть менее, чем за десять лет. Но даже за этот период объем кодовой базы синтаксического анализатора вырос двукратно, что примерно соответствует по времени реализации стандарта C99.\nНо даже если не учитывать код синтаксического анализатора, то объем общей кодовой базы так же коррелирует с внедрением новых стандартов C++: C99, С11 и C14.\nНа графике не видно выраженного пика для С+17 и следующих версий, но предполагаю, что при текущем объеме кодой базы (более 4 миллионов строк только С и С++ кода), несколько тысяч строк, необходимых для поддержки синтаксических конструкций новых стандартов просто незаметно.\nВывод первый - очевидный. Рост сложности инструментов разработки Фактически на примере проекта GCC можно видеть постоянный и неотвратимый рост сложности рабочих инструментов программистов.\nИ как бы не говорили о деградации разработки в статье “Хорошие времена рождают слабаков”, о системном кризисе программного обеспечения, который носит поколенческом характер, но мне кажется тут дело немного в другом.\nОбновление персонала и как следствие — необходимость обучения новых сотрудников старым наработкам, тут дело не сколько в передаче знаний, сколько в возможности эти знания усваивать.\nПричем возможность усвоения знаний для разных поколений будет разная, но не из-за того, что предыдущее поколение было умнее, а у нового поколения не хватает толку в этом разобрать. Просто изменяется окружение и усложняются рабочие инструменты, по сравнению с теми, которые были в ходу у предыдущего поколения.\nВывод второй — порог входа Представьте, что нужно «сделать свой сайт». Естественно нужно определить, какую CMS для него использовать и какой брать хостинг. И если с хостингом вопрос решается очень просто, конечно же в TimeWeb, да еще и с бонусом по ссылке, то при выборе CMS приходится подумать.\nИ если для простых сайтов существуют и простые решения, то для тех, кто не ищет легких путей существует CMS Drupal, который примечателен тем, что имеет фантастически высокий порог входа для начала использования.\nЭто я к чему? При использовании любого инструмента, как и языка программирования, существует некий минимальный уровень комфортного использования. Причем этот уровень прямо пропорционально связан с размером той целевой аудитории, для которой он предназначен. Точнее, размер возможной аудитории определяется в том числе и требованиями к уровню начальных знаний и квалификации потенциального пользователя.\nИтоговый вывод — не утешительный Если рассматривать увеличение сложности только самого ПО, то это одно дело. Вот к примеру:\nСтатистика ядра Linux с вики\n17 сентября 1991: Linux версии 0.01 (10 239 строк кода). 14 марта 1994: Linux версии 1.0.0 (176 250 строк кода). Март 1995: Linux версии 1.2.0 (310 950 строк кода). 9 июня 1996: Linux версии 2.0.0 (777 956 строк кода). 25 января 1999: Linux версии 2.2.0, изначально довольно недоработанный (1 800 847 строк кода). 4 января 2001: Linux версии 2.4.0 (3 377 902 строки кода). 18 декабря 2003: Linux версии 2.6.0 (5 929 913 строк кода). 23 марта 2009: Linux версии 2.6.29, временный символ Linux — тасманский дьявол Tuz (11 010 647 строк кода). 22 июля 2011: релиз Linux 3.0 (14,6 млн строк кода). 24 октября 2011: релиз Linux 3.1. 15 января 2012: релиз Linux 3.3 преодолел отметку в 15 млн строк кода. 23 февраля 2015: первый релиз-кандидат Linux 4.0 (более 19 млн строк кода). 7 января 2019: первый релиз-кандидат Linux 5.0 (более 26 млн строк кода). А что делать, если сложность программного обеспечения накладывается на тенденцию постоянного усложнения самих рабочих инструментов? Ведь постоянное развитие языков программирования неизбежно повышает порог входа для всех начинающих и только усугубляет проблему сложности разработки ПО.\nДругими словами, не зависимо от того, как хорошо документирован код и как полно он покрыт тестами, через некоторое время устаревают используемые инструменты, завершаются жизненные циклы внешних зависимостей, и самое главное, приходят новые люди взамен тех, кто разработал или сумел разобраться в системе.\nИ у новых людей возникает необходимость разбираться в системе с самого начала, но в других начальных условиях. И из-за этого, сложность изучения системы для всех новых людей будет выше просто по факту того, что изменились внешние условия и усложнились рабочие инструменты, которыми приходится использовать новым сотрудникам.\nПонятно, что чем дальше, тем проще уже не будет. Ведь область IT , это среда с самой высокой конкуренцией. И как уж тут не вспомнить Льюиса Кэррола, что его крылатое выражение\nНужно бежать со всех ног, чтобы только оставаться на месте, а чтобы куда-то попасть, надо бежать как минимум вдвое быстрее!\nВедь это относится не только к Алисе в стране чудес, но и ко всем информационным технологиям в целом!\nПервоначальная публикация\n","categories":"","description":"","excerpt":"\nВ очередной раз увидел на Хабре статью про сложное дело под названием …","ref":"/ru/blog/complex-prog/","tags":"","title":"Простое сложное программирование"},{"body":"\nС постоянной периодичностью появляется информация о выходе новой версии того или иного языка программирования. И с каждой новой версией расширяются его возможности, добавляются новые синтаксические конструкции или иные улучшения.\nИ это очень сильно напоминает развитие технологий, как и в любой другой области техники. Когда с очередным этапом совершенствуются создаваемые творения. Быстрее, выше, сильнее … и одновременно значительно сложнее.\nОб этой проблеме меня заставила задуматься первоапрельская статья «Доказательное программирование».\nПонятно, что дата публикации статьи говорит сама за себя. Тем не менее, новые стандарты С++, постоянно выходящие спецификации Java или новый синтаксис у PHP 8, невольно заставляют задуматься, а в нужную ли сторону идет развитие языков программирования? Ведь большинство нововведений добавляют сложность в основной рабочий инструмент и решая одни проблемы, неявно добавляя множество других.\nА что должно быть в конце прогресса у развития такой дисциплины как программирование? Или хотя бы у одного конкретного языка? Ради достижения какой конечной «идеальной» цели разрабатываются новые стандарты языков программирования?\nЕсли фантазировать об идеальной конечной цели развития, например транспорта, то это будет мгновенное перемещение на любое расстояние с произвольной полезной нагрузкой и нулевым потреблением энергии.\nИли, например, какая может быть идеальная цель у медицины? Бедные не болели, а богатые не выздоравливали, вероятно, лечение любых болезней и биологическое бессмертие.\nКонечно, «идеальная» цель это очень упрощенное понятие. Фактически, «идеальная» это синоним «недостижимая», т.к. она всегда будет упираться необходимость соблюдать компромисс между различными взаимно-исключающими граничными условиями.\nНо сравнивать разработку средств программирования с процессом развития в других технических дисциплинах напрямую нельзя. Ведь при создание конечного продукта в любой технической области, все сложные производственные операции, которые требуют непосредственного участия человека, практически всегда можно разделить на отдельные, более простые части или этапы.\nЭто делается, в том числе и для того, чтобы сложность одной выполняемой операции не была запредельной для исполнителя. Но как это можно сделать при разработке программного обеспечения?\nВ данном случае, я имею ввиду конечную ограниченность возможностей одного конкретного человека в противовес возможностям разделения технологических процессов на отдельные этапы, каждый из которых может выполняться совершенно разными людьми (как пример, это обычный конвеер с его разделением труда на элементарные операции или узкая специализация врачей-специалистов в одной конкретной области).\nВедь даже сложно себе представить фантастическую организацию труда программистов в виде конвеера:\nПервый разработчик пишет только интерфейсы функций и их вызовы, после чего передает код второму сотруднику. Второй пишет в тексте программы только условия проверки и безусловные переходы и передает текст третьему. Третий отвечает за написание циклов и общее форматирование кода и т.д. и результате ожидаемо получится полный бред. Из-за этого индустрия разработки ПО вынуждена идти по экстенсивному пути развития (т.е. за счет увеличения используемых в производстве ресурсов). Современные промышленные языки программирования имеют очень богатые возможности по разделению кода приложения на отдельные функции/модули/компоненты, что позволяет вести разработку сложного программного продукта сразу множеству сотрудников одновременно.\nНо и такое развитие имеет естественное ограничение. И этим ограничением является сам человек, так как каждый разработчик должен знать и уметь пользоваться своим рабочим инструментом, т.е. языком программирования.\nЕсли взять приведенную выше аналогию с конвеером, то в ней каждый рабочий должен был бы досконально знать большую часть используемых станков и инструментов на всем заводе, независимо от того, какую одну конкретную операцию он выполняет на своем рабочем месте.\nВедь парадокс развития языков программирования заключается в том, что добавляя новые возможности и синтаксические конструкции, мы усложняем рабочий инструмент, предназначенный как для совместного, так и для индивидуального использования!\nИ получается, что одновременно с процессом постоянного наращивания возможностей средств разработки идет и обратный процесс — увеличение сложности разработки кода отдельно взятым разработчиком. Фактически, это и есть то самое взаимоисключающее непреодолимое противоречие.\nМожет быть именно поэтому невозможно найти «серебряную пулю», которая бы повышала производительность труда одного программиста? Ведь внимание и возможности человека не безграничны. И любые новшества и улучшения рабочего инструмента программиста вынужденно толкают всю IT индустрию на экстенсивный путь развития.\nВозможно следует разрабатывать принципиально новые подходы, а не гнаться за синтаксическим сахаром в языках программирования из прошлого века? Или и вовсе не париться, продолжать пользоваться тем, что есть, а теория дедушки Дарвина все сама расставит по своим местам?\nПервоначальная публикация\n","categories":"","description":"","excerpt":"\nС постоянной периодичностью появляется информация о выходе новой …","ref":"/ru/blog/lang-final/","tags":"","title":"Какая «идеальная» цель развития у языков программирования?"},{"body":"\nНекоторое время назад я писал про «Интернациональное программирование на естественных языках», в которой попытался представить достойную цель для абстрактного языка программирования, попробовав примерить на него роль связующего звена между миром программистов с компьютерами и не программистов.\nНо в результате оказалось, что это не нужно в принципе, т.к. «не программистам» просто не требуется учиться писать программы. А если иногда такое желание и возникает, то вполне хватает обычных формализованных языков программирования, которых уже сейчас насчитывается наверно более десяти тысяч.\nА пользователи, как программисты, так и не программисты, просто хотят решать возникающие перед ними задачи. И хотя задачи бывают совершенно разные, но если способ (алгоритм) её решения известен, то выбрать язык для её решения не составит никакого труда.\nЗа исключением одного класса задач. Задач, решение которых нельзя описать в виде алгоритма. Но можно указать некие критерии, которым должно удовлетворять искомое решение.\nЯ имею ввиду логические языки программирования и Пролог, как самый яркий представитель этого класса.\nЕще помню воспоминание из юности, когда удалось достать дискету с этим языком. Ух, с каким задором горели мои глаза, когда мне казалось, ну вот, еще чуть-чуть и будет создана система с базой знаний, у которой и можно будет получить заветный ответ 42 на любой вопрос.\nТак почему этого так и не случилось? В чем проблема Пролога, да и любой системы / языка программирования, назначение которых анализировать факты и искать ответы на вопросы?\nЭта проблема называется «Комбинаторный взрыв» - экспоненциальная (или более) зависимость времени работы алгоритма от количества входных данных. И есть как минимум два решения этой проблемы.\nПодходы к написанию программ Прежде чем переходить к частностям, следует сказать пару слов про парадигмы программирования. Обычно противопоставляют между собой два разных стиля в написании программ: императивный и декларативный.\nИмперативный — это классический вариант написания программы, при котором программист сам задает шаги алгоритма для получения конечного результата. А сам текст программы состоит из последовательности команд, которые читают, сохраняют и обрабатывают данные или вызывают другие команды.\nДекларативный — в этом стиле программист описывает условия задачи и правила для получения требуемого результата, но не требуется детально описывать все шаги работы алгоритма, оставляя их на усмотрения компьютера.\nИменно к декларативному стилю относится язык Пролог, да и все остальные логические языки программирования. К декларативному стилю написания программ следует относить и язык структурированных запросов (SQL).\nИ проблема под называнием «комбинаторный взрыв» сильнее всего оказывает негативное влияние как раз на подобные языки. Ведь в императивном подходе программист сам отвечает за последовательность выполняемых команд, и если он запрограммировал алгоритм полного перебора всех возможных вариантов решений, то он сам себе злобный Буратино.\nДругое дело, программирование в декларативном стиле. Разработчик хоть и может указать ограничения, которые следует применять при поиске решения, но это возможно только в том случае, когда известен алгоритм решения задачи. Но если алгоритм решения известен, то проще использовать императивный стиль, как раз и реализуя этот алгоритм!\nПоэтому основное применения языков программирования в декларативном стиле — отказаться от необходимости описания четкого алгоритма поиска решения, отдав это компьютеру на откуп. Для которого самое простое решение «в лоб» - полный перебор возможных вариантов.\nИменно в этом случае и начинается экспоненциальный рост времени выполнения алгоритма. И начиная с определенного порога, время ожидания ответа становится неприемлемым для реального использования. Это и означает «Комбинаторный взрыв», резкий («взрывной») рост времени выполнения алгоритма при увеличении размера входных данных.\nПроблема поиска решений В языке Пролог эта проблема решалась за счет использования механизма отката и отсечений. Иногда еще уточняли про «красное» и «зеленое» отсечение решений. Но в любом случае, это были алгоритмические механизмы для ограничения количества размера дерева возможных решений, а необходимость их применения все равно остается на программисте.\nНо чтобы их правильно реализовывать, нужно знать алгоритм решения, что опять возвращает нас к утверждению о том, что если известен алгоритм, то и программировать его удобнее в императивном стиле.\nА если полный алгоритм решения задачи не известен (или не подходит, например из-за большого времени для его работы), то в результате остается либо увеличивать производительность системы, чтобы сократить время выполнения алгоритма, либо искать другое решение, в том числе, сокращая вычислительную сложность поиска решений, например, исключая заведомо не подходящие данные, чтобы уменьшить возможные комбинации их перебора.\nМасштабирование производительности Увеличение производительности тоже бывает разным и работает не во всех случаях. Вертикальное масштабирование производительности одного узла вычислительной среды имеет свой естественный предел. И даже многократное увеличение скорости работы компьютера может лишь отдалить порог терпения пользователя при ожидании получения результата, но не в состоянии принципиально решить саму проблему.\nДругое дело горизонтальное масштабирование, при котором выполнение алгоритма запускается на отдельных узлах, которые параллельно решают одну и ту же задачу. Такой способ масштабирования позволяет уже значительно сократить время получения итогового результата для сложных вычислительных задач. И хотя это способ является решением «в лоб», но успехи в области data science доказывают успешность такого подхода.\nКонечно, у горизонтального масштабирования тоже есть подводные камни. В первую очередь, сам алгоритм должен допускать возможность параллельного выполнения независимо от других узлов. Также требуется автоматизация управления заданиями, самими вычислительными узлами, да и всей системой в целом.\nТут частично может помочь парадигма функционального программирования, которая ограничивает результат вычисления функций только входными параметрами и результатом выполнения других функций, но сам результат не зависит от состояния системы или иных внешних данных.\nПоиск обобщенного решения Вторым способом решения решения проблемы комбинаторного взрыва является уменьшение вычислительной сложности решения. Тут имеется ввиду не выбор другого алгоритма или решение задачи в символьном виде. Если такое возможно, то все опять сразу сведется к императивному стилю программированию.\nЯ имею ввиду возможность поиска самого алгоритма решения. Точнее не совсем алгоритма, а возможность применения к входным данным различные методы отбора, чтобы исключить необходимость их полного перебора. По сути, это сводится к применению различных методов и механизмов обработки входных данных с учетом различных закономерностей.\nЭто возможно как алгоритмическими методами (откат и отсечение в Прологе), так и с применением машинного обучения, которое очень хорошо справляется с поиском различных закономерностей.\nЕстественно, такой способ подходит не для всех классов задач. Он не подходит для выявления ВСЕХ возможных решений. Но там где это не требуется, подобные способы уменьшения вычислительной сложности имеют право на существование.\nНапример, не требуется искать все возможные лекарства от конкретной болезни, достаточно одного, с учетом определенных ограничений, которое гарантированно подействует.\nК тому же, даже при нахождении частных решений, всегда существует шанс, что с их помощью получится увидеть не очевидные на первый взгляд закономерности, которые помогут показать новые пути алгоритмического уменьшения вычислительной сложности основной задачи.\nОбласть не решаемых задач Как вы считает, а реально ли создать язык логического программирования, который бы сам умел автоматизировать поиск решений для задач подобных классов? Или хотя бы имел в своем арсенале встроенные механизмы для автоматизации подобной деятельности?\nРезультаты опроса из оригинальной публикации - 57.47% Ха-ха! То, что хочет автор и называется искусственным интеллектом (50 голосов) - 27.59% Поиск решений нельзя автоматизировать (24 голоса) - 19.54% Это уже есть и все давно придумано (17 голосов) - 9.2% Такой язык не нужен, т.к. нейросети могут всё (8 голосов) - 3.45% Свой вариант написал в комменатрии (3 голоса) Проголосовали 87 пользователей. Воздержались 62 пользователя.\n","categories":"","description":"","excerpt":"\nНекоторое время назад я писал про «Интернациональное программирование …","ref":"/ru/blog/logic-prog/","tags":"","title":"Проблема логических языков программирования"},{"body":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag предыдущей версии.\nАктуальную версию синтаксиса языка можно посмотреть тут.\nВ последнее время часто попадаются на глаза статьи о новых языках программирования, а так же различные рейтинги и прогнозы, связанные с популярностью компьютерных языков.\nЗаявляют о себе и новые инструментальные средства, которые в своей работе используют собственные форматы описания конфигурационных файлов или последовательности выполняемых команд, которые так же очень сильно приближает их к понятию «язык программирования».\nЦель написания данной статьи — формулировка ожиданий и возможной реализации абстрактного языка программирования, который может стать универсальным инструментом для общения между компьютером и человеком.\nО программистах Если начинать с самого начала, то когда-то давно я слышал перефразированное высказывание, «каждый программист должен написать свою базу данных, текстовый редактор и язык программирования». И если первые две вещи я уже давным давно написал, то с языком программирования пока не сложилось.\nВедь как обычно создаются языки программирования?\nУ каждого программиста всегда есть какой-то своей предыдущий опыт:\nзнания одного или нескольких языков программирования (как же без этого) негативный опыт от их использования (в противном случае, если все устраивает, то зачем придумывать что-то новое?) желания получить новые возможности (когда в существующих языках чего-то не хватает) А перед тем, как описывать синтаксис, выбирать ключевые слова и начинать основную работу: лексер, парсер, базовые библиотеки, нужно дать ответ на основные вопросы:\nКомпилятор/интерпретатор/транспилятор(transpiler)? Статическая или динамическая типизация? Ручное управление памятью или автоматическое со сборщиком мусора? Модель программирования: ООП, функциональное, структурное или что-то новое? Разрешены ли вставки из других языков программирования и т. д.? У меня, наверно, как и у большинства читателей, присутствует опыт использования нескольких языков программирования. Поэтому давно сложилось практика, что для решения задачи лучше взять известный язык или даже выучить новый, вместо того, чтобы начинать писать собственный.\nТем более, что не хочется придумывать еще один язык просто ради галочки или ради самого языка. Я считаю, что цель его создания должна быть за пределами потребностей самого разработчика.\nИ мне кажется, что удалось определить область, для которой разработка языка программирования может быть востребованной, а потраченные на него усилия могут принести реальную пользу.\nО не программистах Эта область — программирование для «не программистов» на «естественном» языке. Я специально взял слова «не программистов» и «естественном» в кавычки, т.к. эти термины являются очень условными.\nВедь если не программист начинает программировать, то сам того не осознавая, он автоматически становится программистом ;-). А «естественным» язык программирования быть не может по определению. Точнее для компьютеров скорее всего «естественным» будет язык Assembler или набор машинных команд.\nПоэтому, цель максимум — приблизить язык программирования к естественному человеческому языку.\nЭто не только сделает чтение текста программы более понятным для не профессионалов, но и позволит начинать составлять программы просто освоив письменную речь, используя самый минимум основных правил.\nНо в подобной формулировке кроется очень большая проблема!\nЛюбой язык программирования является интернациональным, т.к. его синтаксис не зависит от естественного языка, на котором общается программист.\nА если текст программы будет на “естественном” языке, то она станет понятной только для знающих этот язык, одновременно становясь непонятной для всех остальных.\nВ качестве иллюстрации: раз или два. Если пофантазировать насчет хотелок к такому языку, то видятся следующие требования и ограничения:\nТак как каждый пользователь является носителем своего родного естественного языка (или даже нескольких), то жестко задавать ключевые слова невозможно, из чего следует, что основой такого языка должны стать только правила пунктуации, но никак не лексика или грамматика. Компилятор/транслятор должен уметь преобразовывать исходный текст программы не только в машинный код для компьютера, но в другой вариант “естественного” языка, чтобы пользователь мог работать с исходным текстом на известном ему “естественном” языке. Очень хочется видеть в новом языке толерантность терпимость к очепяткам. Подобная «фича» присутствует в письме на естественном языке, и несмотря на наличие опечаток, практически всегда сохраняется смысл. Естественно, в данном случае не стоит доходить до фанатизма. Компилятор не читает мысли и не может в действительности «понять», что имел ввиду пользователь, и все же довольно часто можно игнорировать опечатки в тексте программы исходя из контекста (пусть и с выводом предупреждающих сообщений). Тем не менее, такой язык должен оставаться именно языком программирования со всеми возможностями создания программ любого уровня сложности, включая функциональное и объектно-ориентированное программирование и однозначное понимание написанного.\nО гипотетическом языке Если взять за основу правила письменной речи, то основные соглашения и пунктуация для нового языка могут выглядеть примерно так:\nЛюбой текст состоит из предложений и комментариев. Предложения обрабатываются, а комментарии игнорируются. Предложение состоит из последовательности терминов, литералов и символов, разделенных пробелами и знаками препинания и завершается символом конца предложения. Термин — слитно написанная последовательность букв, цифр и символов “:” и “_”. Литерал — константы, включаемые непосредственно в текст программы, тип которой определяется однозначно. Это символьные строки в кавычках, целые и вещественные числа, и некоторые специальные форматы (время, дата). Символы — все остальное символы, которые не относятся к знакам препинания, пробельным символам, цифрам и буквам. Знаки препинания — символы пунктуации, имеющие специальное значение при разборе текста программы: «.»,«;»,«!»,«?»,«…» — конец предложения. «=» — присвоение значения. \"\" (кавычки) — определение символьной строки. «()» - передача параметров/аргументов или группировка операторов для определения приоритета выполнения операций. «[]» - массив или обращение к элементу массива. «{}» - включение в текст исходного кода программы на обычном языке программирования. «$» — системная переменная. «@» — системная функция. «,» (запятая) — перечисление. «:» (двоеточие) — список или логическая связь. Если с символом присвоения, кавычками, круглыми и квадратными скобками все должно быть более-менее понятно, т.к. их назначение соответствует аналогичному в подавляющем большинстве языков программирования, то про назначение остальных символов (фигурных скобок, двоеточия, запятой и системных функций/переменной), следует немного пояснить.\nРаз цель гипотетического языка программирования все же написание программ, то необходимо предусмотреть возможность делать вставки обычного программного кода без учета всех возможностей и неоднозначностей, которые присущи любому естественному языку.\nТак же эта возможность требуется для реализации низкоуровневых функций и для взаимодействия с внешними библиотеками.\nПри создании подобных вставок и могут использоваться фигурные скобки, весь текст между которыми будет вставляться в итоговый файл практически без обработки.\nДля похожих целей служат и символы «$» — системная переменная и «@» — системная функция. Если такой символ поставить в начале слова, тогда он станет обозначать объект с соответствующим назначением. Например «@exit» — будет означать функцию, а «$var» — переменную с соответствующими именами, а сами объекты станут доступны как в обычном коде, так и в программных вставках внутри фигурных скобок.\nАналогичным образом организуется и доступ к отдельным полям/методам объектов: «объект@метод» или «объект$поле».\nСимвол запятая «,» применяется для указание последовательности равноправных логических блоков в одном предложении или для создания списков.\nСимвол двоеточия «:» используется для создания списков и для обозначения логической связи между двумя частями слова/текста, в том числе для указания полного пути модуля.\nНапример, создание списка:\nВ_строку: элемент 1, элемент 2, последний элемент.\nФорматированный_список: - элемент 1; - элемент 2; - последний элемент. Логическое следствие/указание связи:\nmodule:calc //термин «calc», который находится в модуле «module» super:module:example$var //переменная «$var» которая находится в указанной иерархии. Как можно заметить, использование знаков препинания взято из их прямого назначения, принятого в письменной речи, что должно обеспечить определенный компромисс между синтаксисом в стандартных языках программирования и письмом на естественном языке.\nО компьютерах Так как речь идет все же о языке программирования, то не обойтись без стандартных алгоритмических конструкций: следования, ветвления и циклов.\nСледование легко описывается обычными правилам письма на естественном языке. В случае последовательного выполнения в одном предложении, операции и вызовы функций записываются последовательно через запятую. Если они располагаются в разных предложениях, то они записываются так же друг за другом. Причем форматирование по абзацам служит только для лучшего восприятия текста и логического разделения отдельных фрагментов.\nПри создании условных и циклических управляющих конструкций уже потребуются ключевые слова. Но так как согласно исходным пожеланиям к языку, резервировать обычные термины для записи алгоритмических конструкций нельзя, то перед ключевыми словами достаточно указывать символ системной функции, что позволит отличить обычный термин от ключевого (управляющего) слова.\nЕстественно, при программировании, данными терминами хоть и можно будет пользоваться, но делать это совсем не обязательно. Так как при настройке под конкретный естественный язык, системным функциям и ключевым словам нужно обязательно присвоить конкретные термины и пользоваться уже ими, например:\nперейти = @goto, метка = @label, продолжить = @continue, прервать=@break и т.д. И последняя по очереди, но наверно самая важная по сути конструкция: передача параметров при вызовах функций. Если стремиться к полностью естественному синтаксису, тогда мы получим тот самый естественный язык, который очень сложно анализировать.\nТем не менее, мне кажется, что можно скомбинировать оба два подхода, если отказаться от обязательного использования круглых скобок, там, где это допустимо по синтаксису.\nКомпьютерный: функция(параметр1, функция2(), параметр3=значение). Естественный: функция параметр1 функция2 параметр3=значение. Но:\nКомпьютерный: функция( функция2(параметр) ). Естественный: функция функция2(параметр). Или так: функция (функция2 параметр). Другими словами, для естественного порядка указания аргументов, скобки для функций и запятые между параметрами могут быть опущены. Хотя их использование должно определяться в первую очередь целевым естественным языком, а не синтаксисом.\nО возражениях Предвижу обоснованные возражения против использования подобного языка со стороны программистов. Программа на нем по любому получится значительно многословнее, чем с использованием строгого формального синтаксиса обычных компьютерных языков.\nПоэтому напомню про его обязательное свойство - умение преобразовывать текст программы с одного языка на другой. Это позволяет писать программы как с использованием строго формального синтаксиса без использования переопеределенных терминов на естественном языке, так и преобразовывать исходный текст в “естественный” язык для “не программиста”.\nСсылка на первую публикаци\n","categories":"","description":"","excerpt":"\nВнимание!!!\nДанная статья содержит описание синтаксиса NewLnag …","ref":"/ru/blog/inter-prog/","tags":"","title":"Интернациональное программирование на естественных языках"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":" Welcome to the NewLang project website! Documentation Articles Playground GitHub NewLang — NewLang is a general-purpose high-level programming language with a syntax based on a strict system of grammatical rules. But with the help of preprocessor macros, the syntax is turned into DSL based on keywords..\nTensor calculations and rationals of unlimited precision are supported at the level of language syntax and basic data types without the use of additional libraries.\nThe ownership-based memory management model does not require the use of a garbage collector and eliminates major errors at the stage of compiling the source code of the program.\nThe main properties and features: the ability to work both in interpreter and compiler mode* dynamic and static typing with the ability to specify types explicitly static typing is conditionally strong (there is no automatic type casting, but conversion between some data types is allowed. For example, an integer can be automatically converted to real or rational, but not vice versa) automatic memory management without garbage collector* bject-oriented programming in the form of explicit class inheritance and \"duck typing\"* several types of functions (regular and pure functions without side effects) are supported at the syntax level of the language optional and named function arguments direct insertion of C/C++ code is possible* easy integration with existing software libraries (including import of native variables, functions and classes* from C/C++). there is a REPL (read-eval-print loop) symbolic calculations** *) These features are planned for implementation when the compiler is created. **) Symbolic calculations are supported at the syntax level, but not implemented. Why do we need NewLang? All modern programming languages have a constant development (complication) of syntax as new versions are released.\nThis is a kind of payment for the emergence of new features and is perceived by users as a natural process. But at the same time it is also a serious problem, since with the release of versions new keywords and syntactic constructions are added, which inevitably raises the entry threshold for new users. Another consequence of this process is the constant increase in the complexity of developing and supporting already created software products, when the old code is being finalized using the already new standards. NewLang naturally limits the complexity of language constructs by splitting the syntax of the language into two parts, making it easier to learn and use. Basic syntax - for writing programs in object-oriented (imperative) and declarative styles, which is based not on reserved keywords, but on a system of strict grammar rules. It is possible to extend the basic syntax through the use of macros.\nExtended syntax - program inserts in the implementation language (C / C ++), when the main syntax becomes insufficient. Another disadvantage of modern languages is that most of them were created before the era of machine learning, therefore, tensor calculations are performed in the form of separate libraries.\nThe same applies to calculations with unlimited precision, which also require the use of additional library functions. NewLang has tensor calculus and unlimited-precision rationals out of the box.\nThey are supported at the syntax level for writing literals of the corresponding types, and simple arithmetic data types are scalars (tensors of dimension zero).\nThe implementation of tensor calculations is based on the library libtorch, and rational numbers using OpenSSL. Hello world script example in NewLang #!../output/nlc printf('Hello, world!'); Output: Hello, world! 14 An example of calculating factorial 40 on NewLang (base syntax) #!../output/nlc ### Example of calculating factorial of 40 using basic syntax fact := 1\\1; # Rational number 1 (no precision limit) mult := 40..1..-1?; # Iterator from range for factors from 40 to 2 [mult ?!] \u003c-\u003e { # Loop until the iterator data runs out fact *= mult !; # Get the current multiplier and move to the next iterator element }; @assert(fact == 815915283247897734345611269596115894272000000000\\1); fact # Return final result Output: 815915283247897734345611269596115894272000000000\\1 Same code using DSL syntax #!../output/nlc ### Example of calculating factorial 40 using DSL syntax fact := 1\\1; # Rational number 1 (no precision limit) mult := @iter( 40..1..-1 ); # Iterator from range for factors from 40 to 2 @while( @curr(mult)) { # Loop until the iterator data runs out fact *= @next(mult); # Get the current multiplier and move to the next iterator element }; @assert(fact == 815915283247897734345611269596115894272000000000\\1); fact # Return final result Output: 815915283247897734345611269596115894272000000000\\1 More code examples Syntax description All documentation Articles ","categories":"","description":"","excerpt":" Welcome to the NewLang project website! Documentation Articles …","ref":"/","tags":"","title":"NewLang"},{"body":" Добро пожаловать на сайт проекта NewLang! Документация Статьи Playground GitHub NewLang — это язык программирования высокого уровня общего назначения c базовым синтаксисом на основе грамматических правил. С помощью макросов препроцесора, базовый синтаксис легко преобразуется в DSL на основе ключевых слов.\nТензорные вычисления и рациональные числа не ограниченной точности поддерживаются на уровне синтаксиса языка и базовых типов данных без использования дополнительных библиотек.\nМодель управления памятью на основе владения не трубет использования сборщика мусора и исключет основные ошибки еще на этапе компиляции исходного текста программы.\nОсновные свойства и особенности языка: возможность работы как в режиме интерпретатора, так и компилятора* динамическая и статическая типизация с возможностью указания типов в явном виде статическая типизация является условно-строгой (автоматическое приведение типов отсутствует, но допускается преобразование между некоторыми типами данных. Например, целое число может быть автоматически преобразовано в вещественное или рациональное, но не наоборот) автоматическое управление памятью без сборщика мусора на основе владения* ООП* в виде явного наследования классов и «утиная типизация» на уровне синтаксиса поддерживается несколько типов функций (обычные и чистые функции без побочных эффектов) необязательные и именованные параметры функций простая интеграция с уже существующими программными библиотеками (в том числе импорт нативных переменных, функций и классов* из С/С++.) имеется REPL (read-eval-print loop — «цикл: чтение — вычисление — вывод») символьные вычисления** *) Данные возможности запланированы к реализации **) Символьные вычисления поддерживаются на уровне синтаксиса, но не реализованы Зачем нужен NewLang? У всех современных языков программирования происходит постоянное развитие (усложнение) синтаксиса по мере выхода новых версий.\nЭто является своего рода платой за появление новых возможностей языка и воспринимается пользователями как естественное явление. Но одновременно является и серьезной проблемой, так как с выходом новых версий языка в него добавляются новые ключевые слова и синтаксические конструкции, что неизбежно повышает порог входа для всех новых пользователей. Еще одним следствием этого процесса становится постоянное увеличение сложности разработки и поддержки уже созданных программных продуктов, когда старый программный код дорабатывается с применением уже новых стандартов и постоянным увеличением старого легаси кода. У NewLang сложность языковых конструкций ограничена естественным образом за счет разделения синтаксиса языка на несколько частей, что упрощает его изучение и использование. Основной (базовый) синтаксис — на системе строгих грамматических правил. Синтаксис DSL (domain-specific language) — хотя базовый синтаксис самодостаточен и полснотью покрывает все возможные сценарии использования, но его применение разработчиками напрямую не всегда эффекстивно с точки зрения последующего чтения исходноиков. Поэтому более правильным вариантом написания исходного кода программы будет применение предметно-ориентированного языка, который реализуется с помощью макросов препроцессора и превращает базовый синтаксис на основе грамматических правил в синтаксис на основе ключевых слов. Расширенный синтаксис — программные вставки на языке реализации (С/С++), когда основного или DSL синтаксиса становится недостаточно. Еще одно неудобство современных языков в том, что большинство из них были созданы еще до начала эпохи машинного обучения, поэтому тензорные вычисления у них выполнены в виде отдельных библиотек. Это же касается и вычислений с неограниченной точностью, которые также требуют использования дополнительных библиотечных функций. У NewLang тензорные вычисления и рациональные числа неограниченной точности доступны «из коробки». Они поддерживаются на уровне синтаксиса для удобной записи литералов, а простые арифметические типы данных являются скалярами (тензорами нулевой размерности). Реализация тензорных вычислений сделана на базе библиотеки libtorch, а рациональные числа с использованием OpenSSL. Пример скрипта Hello world! на NewLang #!../output/nlc --eval hello(str) := { # Импорт и вызов функции printf стандартной библиотеки printf(format:FmtChar, ...):Int32 := %printf...; printf('call: %s', $str); $str; }; hello('Привет, мир!'); Вывод: call: Привет, мир! Привет, мир! Пример вычисления факториала 40 на NewLang (базовый синтаксис) #!../output/nlc --eval fact := 1\\1; # Рациональное число 1 (без ограничения точности) mult := 40..1..-1?; # Итератор из диапазона для множителей от 40 до 2 [mult ?!] \u003c-\u003e { # Цикл, пока не закончатся данные итератора fact *= mult !; # Получить текущий множитель и перейти на следующий элемент итератора }; fact # Вывести итоговый результат Вывод: 815915283247897734345611269596115894272000000000\\1 Тот же код с использованием DSL синтаксиса #!../output/nlc --eval fact := 1\\1; mult := iter( 40..1..-1 ); while( curr(mult) ) { fact *= next(mult); }; fact; Вывод: 815915283247897734345611269596115894272000000000\\1 Еще примеры кода Описание синтаксиса Вся документация Статьи ","categories":"","description":"","excerpt":" Добро пожаловать на сайт проекта NewLang! Документация Статьи …","ref":"/ru/","tags":"","title":"NewLang"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/tags/%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B/","tags":"","title":"Итераторы"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B/","tags":"","title":"Итераторы"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/tags/%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/","tags":"","title":"Коллекции"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/","tags":"","title":"Коллекции"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/tags/%D0%BE%D0%BE%D0%BF/","tags":"","title":"ООП"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%D0%BE%D0%BE%D0%BF/","tags":"","title":"ООП"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/tags/%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B/","tags":"","title":"Системые Типы"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B/","tags":"","title":"Системые Типы"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/tags/%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8/","tags":"","title":"Строки"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/tags/%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","tags":"","title":"Типы Данных"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","tags":"","title":"Типы Данных"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ru/tags/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8/","tags":"","title":"Функции"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8/","tags":"","title":"Функции"}]